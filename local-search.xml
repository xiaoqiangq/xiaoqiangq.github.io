<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>GATK使用方法详解-变异检测</title>
    <link href="/2024/01/23/GATK4%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95%E8%AF%A6%E8%A7%A3-%E5%8F%98%E5%BC%82%E6%A3%80%E6%B5%8B/"/>
    <url>/2024/01/23/GATK4%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95%E8%AF%A6%E8%A7%A3-%E5%8F%98%E5%BC%82%E6%A3%80%E6%B5%8B/</url>
    
    <content type="html"><![CDATA[<p>GATK4是最新的GATK版本，它在算法上进行了优化，运行速率得到提高，而且整合了picard。GATK4依然是用java 语言开发的，但使用方式上更加人性化，比如所有命令都是gatk cmd方式，这里的cmd是任何可以用的cmd。GATK4 的最佳实践给出了5套pipeline: <strong>Germline SNP&#x2F;Indel</strong>, Somatic SNV&#x2F;Indel, RNAseq SNP&#x2F;Indel, Germline CNV, Somatic CNV。目前版本号是 4.2.4 <a href="https://gatk.broadinstitute.org/hc/en-us">https://gatk.broadinstitute.org/hc/en-us</a> </p><h1 id="1-建立索引"><a href="#1-建立索引" class="headerlink" title="1. 建立索引"></a>1. 建立索引</h1><ol><li>gatk  CreateSequenceDictionary -R hg19.fa -O hg19.dict</li><li>samtools faidx genome.fasta # .fai</li><li>bwa index ref.fa # .amb, .ann, .bwt, .pac, .sa</li><li>qplot –reference ucsc.hg19.fasta  –create_gc ucsc.hg19.winsize100.gc #.winsize100.gc</li><li>bowtie-build ucsc.hg19.fasta ucsc.hg19 ##</li><li>bowtie2-build human_g1k_v37.fa human_g1k_v37 #bowtie2-2.4.1</li></ol><h1 id="2-比对"><a href="#2-比对" class="headerlink" title="2. 比对"></a>2. 比对</h1><ul><li>BWA for DNA, STAR for RNA-seq</li></ul><h2 id="2-1-bwa-比对"><a href="#2-1-bwa-比对" class="headerlink" title="2.1 bwa 比对"></a>2.1 bwa 比对</h2><p>bwa mem -M -t 4 -R ‘@RG\tID:id1\tPL:illumina\tSM:test’ ref.fa test_1.fq test_2.fq | samtools view -bS - &gt;test.bam</p><p><strong>参数</strong><br>-R 设置reads group，gatk必须要的信息，其中ID，PL和SM信息是必须要的<br>GATK 要求read group的格式</p><h2 id="2-2-排序"><a href="#2-2-排序" class="headerlink" title="2.2 排序"></a>2.2 排序</h2><p>samtools sort -@ 3 -o test.sorted.bam test.bam<br>samtools index test.sorted.bam<br>rm -rf test.bam</p><p>ID &#x3D; Read group identifier<br>　　每一个read group 独有的ID，每一对reads 均有一个独特的ID，可以自定义命名；</p><p>PL &#x3D; Platform<br>　　测序平台；ILLUMINA, SOLID, LS454, HELICOS and PACBIO，不区分大小写；</p><p>SM &#x3D; sample<br>　　reads属于的样品名；SM要设定正确，因为GATK产生的VCF文件也使用这个名字;</p><p>LB &#x3D; DNA preparation library identifier<br>　　对一个read group的reads进行重复序列标记时，需要使用LB来区分reads来自那条lane;有时候，同一个库可能在不同的lane上完成测序;为了加以区分，</p><p>　　同一个或不同库只要是在不同的lane产生的reads都要单独给一个ID. 一般无特殊说明，成对儿read属于同一库，可自定义，比如：library1</p><p>若是忘记添加read group信息还以通过 AddOrReplaceReadGroups 添加</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">gatk AddOrReplaceReadGroups -I .bam -O .add.bam -LB library1 -PL illumina -PU pl1 -SM name<br><br><span class="hljs-comment">##参数</span><br>-I Input file (BAM <span class="hljs-keyword">or</span> SAM <span class="hljs-keyword">or</span> a GA4GH url)；<br>-O  Output file (BAM <span class="hljs-keyword">or</span> SAM)；<br>-LB <span class="hljs-keyword">Read</span>-<span class="hljs-keyword">Group</span> <span class="hljs-title">library</span>；<br>-PL  <span class="hljs-keyword">Read</span>-<span class="hljs-keyword">Group</span> <span class="hljs-title">platform</span> (e.g. ILLUMINA, SOLID)；<br>-PU <span class="hljs-keyword">Read</span>-<span class="hljs-keyword">Group</span> <span class="hljs-title">platform</span> unit (eg. run barcode)；<br>-SM <span class="hljs-keyword">Read</span>-<span class="hljs-keyword">Group</span> <span class="hljs-title">sample</span> name<br><br></code></pre></td></tr></table></figure><h2 id="2-3-标记重复序列"><a href="#2-3-标记重复序列" class="headerlink" title="2.3 标记重复序列"></a>2.3 标记重复序列</h2><p>gatk  MarkDuplicates -I test.sorted.bam -O test.sorted.markdup.bam -M test.sorted.markdup_metrics.txt –CREATE_INDEX true -VALIDATION_STRINGENCY LENIENT</p><p>rm -f test.sorted.bam test.sorted.bam.bai</p><p>##参数<br>-I 排序后的一个或者多个bam或者sam文件<br>-M 输出重复矩阵<br>-O 输出文件</p><h2 id="2-4-BQSR-BaseRecalibrator"><a href="#2-4-BQSR-BaseRecalibrator" class="headerlink" title="2.4 BQSR BaseRecalibrator"></a>2.4 BQSR BaseRecalibrator</h2><ul><li>所谓的变异位点，就是与参考基因组不同的部分，假设原始数据中就存在着一些由于测序仪器产生的系统性误差，那么变异位点识别过程中找到的variant，就会存在大量的假阳性。这一步主要目的是调整原始碱基的质量分数。</li></ul><p>gatk –java-options “-Xmx8g -XX:+UseParallelGC -XX:ParallelGCThreads&#x3D;1” BaseRecalibrator -R hg19.fa -I test.sorted.markdup.bam –known-sites $hash_config{“dbsnp”} –known-sites $hash_config{“Mills_and_1000G_gold_standard_indels”}  -O sample.recal.grp –default-base-qualities 1 2&gt;&gt;$log_dir/$sample.log 1&gt;&gt;$log_dir/$sample.log&#x2F;;  ##–known-sites $hash_config{“KG_phase1_indels”}</p><p>gatk –java-options “-Xmx8g -XX:+UseParallelGC -XX:ParallelGCThreads&#x3D;1” ApplyBQSR -R hg19.fa -I test.sorted.markdup.bam -bqsr sample.recal.grp -O sample.recal.bam</p><h2 id="2-5-检测变异"><a href="#2-5-检测变异" class="headerlink" title="2.5 检测变异"></a>2.5 检测变异</h2><p>##两种方法</p><p>##（1）多样本一起call，此次只有一个样本，若有多个样本，则继续用 -I 参数添加即可<br>gatk –java-options -Xmx4G HaplotypeCaller -I test.sorted.markup.bam -O test.gvcf1 -R ref.fa</p><h2 id="（2）单个样本call，然后在合并"><a href="#（2）单个样本call，然后在合并" class="headerlink" title="（2）单个样本call，然后在合并"></a>（2）单个样本call，然后在合并</h2><h2 id="生成中间文件gvcf"><a href="#生成中间文件gvcf" class="headerlink" title="生成中间文件gvcf"></a>生成中间文件gvcf</h2><p>gatk –java-options -Xmx4G HaplotypeCaller -I test.sorted.markup.bam -O test.gvcf -R ref.fa –emit-ref-confidence GVCF</p><p>gatk –java-options “-Xmx8g -XX:+UseParallelGC -XX:ParallelGCThreads&#x3D;1” HaplotypeCaller -R hg19.fa -I test.sorted.markup.recal.bam –dbsnp $hash_config{“dbsnp”} -O sample.1.g.vcf.gz –emit-ref-confidence GVCF</p><p>##通过gvcf检测变异, -V 添加上步得到的gvcf<br>gatk GenotypeGVCFs -R ref.fa -V test.gvcf -O test.vcf</p><p>##参数<br>-I BAM&#x2F;SAM&#x2F;CRAM file<br>-O  输出文件<br>-R 参考基因组<br>–java-options: 若设置java则需要添加<br>-Xmx4G：内存为4G，防止内存太大<br>-V  A VCF file containing variants</p><h1 id="2-6-qplot"><a href="#2-6-qplot" class="headerlink" title="2.6 qplot"></a>2.6 qplot</h1><h1 id="2-7-merge-gvcf"><a href="#2-7-merge-gvcf" class="headerlink" title="2.7 merge gvcf"></a>2.7 merge gvcf</h1><p>-按照每条染色体<br>gatk –java-options “-Xmx16g” CombineGVCFs -R hg19.fa $inputgvcf -O combine.1.g.vcf.gz -L 1 </p><h1 id="2-8-calling-variants"><a href="#2-8-calling-variants" class="headerlink" title="2.8 calling variants"></a>2.8 calling variants</h1><p>gatk –java-options “-Xmx8g -XX:+UseParallelGC -XX:ParallelGCThreads&#x3D;1” GenotypeGVCFs -R hg19.fa -V sample.1.g.vcf.gz -O sample.1.vcf.gz –dbsnp $hash_config{“dbsnp”} -L 1</p><h1 id="3-VQSR-or-hardFilter"><a href="#3-VQSR-or-hardFilter" class="headerlink" title="3. VQSR or hardFilter"></a>3. VQSR or hardFilter</h1><h2 id="3-1-VQSR"><a href="#3-1-VQSR" class="headerlink" title="3.1 VQSR"></a>3.1 VQSR</h2><p>#SNP calling</p><h1 id="rescource-文件需要先index，参考文件尽量全，最后三行的文件都是输出"><a href="#rescource-文件需要先index，参考文件尽量全，最后三行的文件都是输出" class="headerlink" title="rescource 文件需要先index，参考文件尽量全，最后三行的文件都是输出"></a>rescource 文件需要先index，参考文件尽量全，最后三行的文件都是输出</h1><h1 id="步骤1-4"><a href="#步骤1-4" class="headerlink" title="步骤1-4"></a>步骤1-4</h1><p>$ time gatk VariantRecalibrator -R &#x2F;path&#x2F;to&#x2F;hg38.fa -V 19P0126636WES.HC.vcf <br>-resource:hapmap,known&#x3D;false,training&#x3D;true,truth&#x3D;true,prior&#x3D;15.0 &#x2F;gatkdoc&#x2F;hapmap_3.3.hg38.vcf <br>-resource:omini,known&#x3D;false,training&#x3D;true,truth&#x3D;false,prior&#x3D;12.0 &#x2F;gatkdoc&#x2F;resources_broad_hg38_v0_1000G_omni2.5.hg38.vcf <br>-resource:1000G,known&#x3D;false,training&#x3D;true,truth&#x3D;false,prior&#x3D;10.0 &#x2F;gatkdoc&#x2F;resources_broad_hg38_v0_1000G_phase1.snps.high_confidence.hg38.vcf <br>-resource:dbsnp,known&#x3D;true,training&#x3D;false,truth&#x3D;false,prior&#x3D;2.0 &#x2F;gatkdoc&#x2F;resources_broad_hg38_v0_Homo_sapiens_assembly38.dbsnp138.vcf <br>-an DP -an QD -an FS -an SOR -an ReadPosRankSum -an MQRankSum -mode SNP -tranche 100.0 <br>-tranche 99.9 -tranche 99.0 -tranche 95.0 -tranche 90.0 <br>-O 19P0126636WES.snp.recal <br>–tranches-file 19P0126636WES.snp.tranches <br>–rscript-file 19P0126636WES.snp.plots.R</p><h1 id="步骤5"><a href="#步骤5" class="headerlink" title="步骤5"></a>步骤5</h1><p>$time gatk ApplyVQSR -R &#x2F;path&#x2F;to&#x2F;hg38.fa -V 19P0126636WES.HC.vcf <br>–ts-filter-level 99.0 –tranches-file 19P0126636WES.snp.tranches <br>–recal-file 19P0126636WES.snp.recal <br>-mode SNP<br>-O 19P0126636WES.snps.VQSR.vcf.gz</p><h2 id="查看数据文件"><a href="#查看数据文件" class="headerlink" title="查看数据文件"></a>查看数据文件</h2><p>$ cat 19P0126636WES.snp.tranches</p><h1 id="Variant-quality-score-tranches-file"><a href="#Variant-quality-score-tranches-file" class="headerlink" title="Variant quality score tranches file"></a>Variant quality score tranches file</h1><h1 id="Version-number-5"><a href="#Version-number-5" class="headerlink" title="Version number 5"></a>Version number 5</h1><p>targetTruthSensitivity,numKnown,numNovel,knownTiTv,novelTiTv,minVQSLod,filterName,model,accessibleTruthSites,callsAtTruthSites,truthSensitivity<br>90.00,1096434,69773,2.1008,1.6731,5.6910,VQSRTrancheSNP0.00to90.00,SNP,665207,598687,0.9000<br>95.00,1200002,98879,2.0923,1.6863,5.0278,VQSRTrancheSNP90.00to95.00,SNP,665207,631946,0.9500<br>99.00,1285374,122947,2.0888,1.6682,3.0695,VQSRTrancheSNP95.00to99.00,SNP,665207,658554,0.9900<br>99.90,1320241,151100,2.0868,1.6411,-1.4500,VQSRTrancheSNP99.00to99.90,SNP,665207,664541,0.9990<br>100.00,1334104,169658,2.0828,1.5982,-1179.7969,VQSRTrancheSNP99.90to100.00,SNP,665207,665207,1.0000</p><ul><li>-tranche默认是输出[100,99.9,99.0,90.0]4个tranche阈值的统计结果，如果想看其他阈值的结果，需要自行加上；结果就是看19P0126636WES.snp.tranches，而19P0126636WES.snp.recal文件则是用于ApplyVQSR的</li></ul><h3 id="INDEL-calling"><a href="#INDEL-calling" class="headerlink" title="INDEL calling"></a>INDEL calling</h3><p>#加了–max-gaussians 6用于设定Gaussians（clusters of variants that have similar properties）的数目，即减少聚类的组数，从而使得每个组的变异位点数目达到要求<br>$time gatk VariantRecalibrator -R &#x2F;path&#x2F;to&#x2F;hg38.fa -V 19P0126636WES.snps.VQSR.vcf.gz <br>-resource:mills,known&#x3D;true,training&#x3D;true,truth&#x3D;true,prior&#x3D;12.0 &#x2F;gatkdoc&#x2F;resources_broad_hg38_v0_Mills_and_1000G_gold_standard.indels.hg38.vcf <br>-an DP -an QD -an FS -an SOR -an ReadPosRankSum -an MQRankSum <br>-mode INDEL –max-gaussians 6 <br>–rscript-file 19P0126636WES_L1.snp.indel.plots.R <br>–tranches-file 19P0126636WES.snp.indel.tranches <br>-O data&#x2F;19P0126636WES.snp.indel.recal</p><p>$ time gatk ApplyVQSR -R &#x2F;path&#x2F;to&#x2F;hg38.fa -V data&#x2F;19P0126636WES.snps.VQSR.vcf.gz <br>–ts-filter-level 99.0 <br>–tranches-file 19P0126636WES.snp.indel.tranches –recal-file 19P0126636WES.snp.indel.recal <br>-mode INDEL <br>-O 19P0126636WES.VQSR.vcf.gz<br>（上面这个就是我们千辛万苦想得到的文件啦！）</p><p>VQSR大概步骤：</p><ol><li>GATK认为VQSR比根据各种annotations进行hard-filtering过滤要好，减少了人为阈值的局限性，避免了一刀切的弊端，从而在sensitivity和specificity之间达到一定的平衡</li><li>VQSR根据机器学习算法从highly validated变异位点数据集（每个位点的annotation profile，一般使用5-8个annotation）中获取到good variants&#x2F;bad variants</li><li>根据上述的位点从我们自己数据集中挑选出一个变异子集（probably true positives）来建模训练，获得一个可识别good variants的模型；bad variants的模型也是如此获得</li><li>然后根据上述获得的模型，对自己数据集的每个变异位点进行一个总的打分</li><li>最后根据设定的sensitivity阈值对变异位点进行过滤</li></ol><p>按照官方教程，<br>SNP的VQSR过滤，选用的resource datasets为：</p><ul><li>HapMap，hapmap_3.3.hg38.vcf.gz，truth&#x3D;true表示VQSR将这个数据集中的变异位点作为真位点true sites，training&#x3D;true表示VQSR将true sites用于训练recalibration model，并赋予这些变异位点prior likelihood值为Q15 (96.84%)</li><li>Omni，1000G_omni2.5.hg38.vcf.gz，truth&#x3D;true，training&#x3D;false（文档中写着是true，参数建议中写着的是false。。。我就按照参数上的来了），Q12 (93.69%)</li><li>1000G，1000G_phase1.snps.high_confidence.hg38.vcf.gz，truth&#x3D;false表示VQSR考虑到在1000G数据集中的不仅包含了true variants还有false positives，training&#x3D;true，Q10 (90%)</li><li>dbSNP，dbsnp_146.hg38.vcf.gz&#x2F;dbsnp_138.hg38.vcf.gz，truth&#x3D;false表示VQSR未将dbSNP数据集中的位点作为可信数据集，training&#x3D;false表示不用于训练数据集，known&#x3D;true表示stratify output metrics such as Ti&#x2F;Tv ratio by whether variants are present in dbsnp or not，Q2 (36.90%)</li></ul><p>INDEL的VQSR过滤，选用的resource datasets为：</p><ul><li>Mills，Mills_and_1000G_gold_standard.indels.hg38.vcf.gz，truth&#x3D;true，training&#x3D;true，Q12 (93.69%)</li><li>dbSNP，dbsnp_146.hg38.vcf.gz&#x2F;dbsnp_138.hg38.vcf.gz，truth&#x3D;false，training&#x3D;false，known&#x3D;true，Q2 (36.90%)</li></ul><h2 id="3-2-gatk-VariantFiltration-O-test-snp-fil-vcf-temp-V-test-snp-vcf-–filter-expression-‘QUAL-30-0-QD-2-0-FS-60-0-SOR-4-0’-–filter-name-lowQualFilter-–cluster-window-size-10-–cluster-size-3-–missing-values-evaluate-as-failing"><a href="#3-2-gatk-VariantFiltration-O-test-snp-fil-vcf-temp-V-test-snp-vcf-–filter-expression-‘QUAL-30-0-QD-2-0-FS-60-0-SOR-4-0’-–filter-name-lowQualFilter-–cluster-window-size-10-–cluster-size-3-–missing-values-evaluate-as-failing" class="headerlink" title="3.2 gatk VariantFiltration -O test.snp.fil.vcf.temp -V test.snp.vcf –filter-expression ‘QUAL &lt; 30.0 || QD &lt; 2.0 || FS &gt; 60.0 ||  SOR &gt; 4.0’ –filter-name lowQualFilter –cluster-window-size 10  –cluster-size 3 –missing-values-evaluate-as-failing"></a>3.2 gatk VariantFiltration -O test.snp.fil.vcf.temp -V test.snp.vcf –filter-expression ‘QUAL &lt; 30.0 || QD &lt; 2.0 || FS &gt; 60.0 ||  SOR &gt; 4.0’ –filter-name lowQualFilter –cluster-window-size 10  –cluster-size 3 –missing-values-evaluate-as-failing</h2><h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><p>-O 输出filt.vcf文件<br>-V 输入vcf文件<br>–filter-expression 过滤条件, VCF INFO 信息<br>–cluster-window-size 以10个碱基为一个窗口<br>–cluster-size 10个碱基为窗口，若存在3以上个则过滤<br>–filter-name 被过滤掉的SNP不会删除，而是给一个标签， 比如 Filter<br>–missing-values-evaluate-as-failing 当筛选标准比较多的时候，可能有一些位点没有筛选条件当中的一条或几条，例如下面的这个表达式；QUAL &lt; 30.0 || QD &lt; 2.0 || FS &gt; 60.0 || MQ &lt; 40.0 || HaplotypeScore &gt; 13.0 并不一定所有位点都有这些信息，这种情况下GATK运行的时候会报很多WARNING信息，用这个参数可以把这些缺少某些FLAG的位点也给标记成没有通过筛选的。</p><h1 id="4-annovar"><a href="#4-annovar" class="headerlink" title="4. annovar"></a>4. annovar</h1><p>################<br>##4.2 ANNOVOR<br>################<br>###annovar database download<br>#gene-based<br>.&#x2F;annotate_variation.pl -buildver hg19 -downdb -webfrom annovar refGene humandb ## RefSeq does not have mitochondria gene definition<br>.&#x2F;annotate_variation.pl -buildver hg19 -downdb -webfrom annovar knownGene humandb ## UCSC Known Gene<br>.&#x2F;annotate_variation.pl -buildver hg19 -downdb -webfrom annovar ensGene humandb # Ensembl Gene<br>.&#x2F;annotate_variation.pl -build hg19 -downdb wgEncodeGencodeBasicV19  humandb #pass</p><p>#region-based<br>.&#x2F;annotate_variation.pl -buildver hg19 -downdb phastConsElements46way humandb&#x2F; # Conserved by 46-way<br>.&#x2F;annotate_variation.pl -buildver hg19 -downdb phastConsElements100way humandb&#x2F; # by 100-way alignment<br>.&#x2F;annotate_variation.pl -build hg19 -downdb tfbsConsSites humandb&#x2F; # Transcription factor binding site annotation<br>.&#x2F;annotate_variation.pl -buildver hg19 -downdb cytoBand humandb&#x2F; # represent cytogenetic bands<br>.&#x2F;annotate_variation.pl -build hg19 -downdb wgRna humandb&#x2F; # Identify variants disrupting microRNAs and snoRNAs<br>.&#x2F;annotate_variation.pl -build hg19 -downdb targetScanS humandb&#x2F; # Identify variants disrupting predicted microRNA binding sites<br>.&#x2F;annotate_variation.pl -buildver hg19 -downdb genomicSuperDups humandb&#x2F; # Identify variants located in segmental duplications<br>.&#x2F;annotate_variation.pl -build hg19 -downdb dgvMerged humandb&#x2F; # Identify previously reported structural variants in DGV (Database of Genomic Variants). deletions and duplications<br>.&#x2F;annotate_variation.pl -buildver hg19 -downdb gwasCatalog humandb&#x2F; # Identify variants reported in previously published GWAS</p><p>#now only for hg18. Identify variants in ENCODE annotated regions (transcribed regions, H3K4Me1 regions, H3K4Me3 regions, H3K27Ac regions, DNaseI hypersensitivity regions, transcription factor ChIP-Seq regions, etc)<br>.&#x2F;annotate_variation.pl -downdb wgEncodeCaltechRnaSeqRawSignalRep1Gm12878CellLongpolyaBb12x75 humandb&#x2F;<br>.&#x2F;annotate_variation.pl -downdb wgEncodeBroadChipSeqPeaksGm12878H3k4me1 humandb&#x2F;<br>.&#x2F;annotate_variation.pl -downdb wgEncodeRegDnaseClustered humandb&#x2F;<br>.&#x2F;annotate_variation.pl -downdb wgEncodeRegTfbsClustered humandb&#x2F;<br>.&#x2F;annotate_variation.pl -downdb wgEncodeBroadHmmGm12878HMM humandb&#x2F; #Identify non-coding variants that disrupt enhancers, repressors, promoters<br>.&#x2F;annotate_variation.pl -downdb wgEncodeUwDnaseSeqHotspotsRep2Gm12878 humandb&#x2F; #Identify variants in other genomic regions annotated with other functions</p><p>#filter-based<br>.&#x2F;annotate_variation.pl -buildver hg19 -downdb 1000g2015aug humandb&#x2F;<br>.&#x2F;annotate_variation.pl -buildver hg19 -downdb -webfrom annovar avsnp150  humandb&#x2F;<br>.&#x2F;annotate_variation.pl  -build hg19 -downdb -webfrom annovar popfreq_all humandb&#x2F; #?? PopFreqMax 1000G2012APR_ALL 1000G2012APR_AFR 1000G2012APR_AMR 1000G2012APR_ASN 1000G2012APR_EUR ESP6500si_ALL ESP6500si_AA ESP6500si_EA CG46.<br>.&#x2F;annotate_variation.pl  -build hg19 -downdb -webfrom annovar nci60 humandb&#x2F;<br>.&#x2F;annotate_variation.pl  -build hg19 -downdb -webfrom annovar popfreq_max humandb&#x2F; </p><p>.&#x2F;annotate_variation.pl -buildver hg19 -downdb -webfrom annovar dbnsfp35a humandb<br>.&#x2F;annotate_variation.pl -buildver hg19 -downdb -webfrom annovar dbnsfp31a_interpro humandb<br>.&#x2F;annotate_variation.pl -buildver hg19 -downdb -webfrom annovar dbscsnv11 humandb<br>.&#x2F;annotate_variation.pl -downdb -buildver hg19 -webfrom annovar gerp++gt2 humandb&#x2F;</p><p>.&#x2F;annotate_variation.pl -buildver hg19 -downdb -webfrom annovar esp6500siv2_all humandb&#x2F;<br>.&#x2F;annotate_variation.pl -buildver hg19 -downdb -webfrom annovar esp6500siv2_aa humandb&#x2F;<br>.&#x2F;annotate_variation.pl -buildver hg19 -downdb -webfrom annovar esp6500siv2_ea humandb&#x2F;<br>.&#x2F;annotate_variation.pl -buildver hg19 -downdb -webfrom annovar clinvar_20200316 humandb<br>或者 <a href="ftp://ftp.ncbi.nlm.nih.gov/pub/clinvar/">ftp://ftp.ncbi.nlm.nih.gov/pub/clinvar/</a> # <a href="ftp://ftp.ncbi.nlm.nih.gov/pub/clinvar/vcf_GRCh37//weekly/clinvar_20220115.vcf.gz">ftp://ftp.ncbi.nlm.nih.gov/pub/clinvar/vcf_GRCh37//weekly/clinvar_20220115.vcf.gz</a></p><p>.&#x2F;annotate_variation.pl -buildver hg19 -downdb -webfrom annovar cadd13gt10 humandb&#x2F;<br>.&#x2F;annotate_variation.pl -buildver hg19 -downdb -webfrom annovar cosmic70 humandb&#x2F;</p><p>.&#x2F;annotate_variation.pl -buildver hg19 -downdb -webfrom annovar exac03 humandb&#x2F;<br>.&#x2F;annotate_variation.pl -buildver hg19 -downdb -webfrom annovar exac03nontcga humandb&#x2F;<br>.&#x2F;annotate_variation.pl -buildver hg19 -downdb -webfrom annovar exac03nonpsych humandb&#x2F;<br>.&#x2F;annotate_variation.pl -buildver hg19 -downdb -webfrom annovar kaviar_20150923 humandb&#x2F;<br>.&#x2F;annotate_variation.pl -buildver hg19 -downdb -webfrom annovar hrcr1 humandb&#x2F;<br>.&#x2F;annotate_variation.pl -buildver hg19 -downdb -webfrom annovar intervar_20180118 humandb&#x2F;</p><p>.&#x2F;annotate_variation.pl -buildver hg19 -downdb -webfrom annovar mitimpact24 humandb&#x2F;</p><p>perl ..&#x2F;prepare_annovar_user.pl -dbtype cosmic CosmicMutantExport.tsv  -vcf CosmicCodingMuts.vcf &gt; hg38_cosmic91.txt<br>perl ..&#x2F;prepare_annovar_user.pl -dbtype cosmic CosmicNCV.tsv  -vcf CosmicNonCodingVariants.vcf &gt; hg38_cosmic91.txt.noncoding</p><p>cosmic,clinvar</p><p>&#x2F;scratch&#x2F;cgg&#x2F;software&#x2F;annovar&#x2F;2014Jul14&#x2F;table_annovar.pl vcf.avi &#x2F;scratch&#x2F;cgg&#x2F;software&#x2F;annovar&#x2F;2014Jul14&#x2F;humandb&#x2F; -buildver hg19 -out myanno2 -remove -protocol refGene,cytoBand,genomicSuperDups,dgvMerged,popfreq_all,snp138,ljb23_all,caddgt10,cosmic68,clinvar_20140702,gwasCatalog,phastConsElements100way,tfbsConsSites,wgRna,targetScanS  -operation g,r,r,r,f,f,f,f,f,f,r,r,r,r,r -nastring . -csvout</p><p>#cg69<br>#cg46<br>nci60<br>popfreq_all<br>gerp++elem<br>gerp++gt2<br>####<br>1.gene-based<br>    refGene;knownGene;ensGene;<br>2.region-based<br>    phastConsElements46way;phastConsElements100way;tfbsConsSites;cytoBand;wgRna;genomicSuperDups;</p>]]></content>
    
    
    <categories>
      
      <category>二代测序流程</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>4.VCF文件格式详解</title>
    <link href="/2024/01/22/VCF%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F/"/>
    <url>/2024/01/22/VCF%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<p><strong>VCF文件格式详解</strong></p><p>VCF介绍</p><p>VCF是用于描述SNP，INDEL和SV结果的文本文件。在GATK软件中得到最好的支持，当然samtools得到的结果也是VCF格式。</p><h1 id="1-VCF的主体结构"><a href="#1-VCF的主体结构" class="headerlink" title="1. VCF的主体结构"></a>1. VCF的主体结构</h1><p>VCF文件分为两部分内容:</p><ul><li><ol><li>以“#”开头的注释部分</li></ol></li><li><ol start="2"><li>没有“#”开头的主体部分</li></ol></li></ul><p>去掉了头部的注释行，只留下了代表每一行意义的注释行。<br>主体部分中每一行代表一个Variant的信息。</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-comment">##fileformat=VCFv4.2</span><br><span class="hljs-comment">##fileDate=20090805</span><br><span class="hljs-comment">##source=myImputationProgramV3.1</span><br><span class="hljs-comment">##reference=file:///seq/references/1000GenomesPilot-NCBI36.fasta</span><br><span class="hljs-comment">##contig=&lt;ID=20,length=62435964,assembly=B36,md5=f126cdf8a6e0c7f379d618ff66beb2da,species=&quot;Homo sapiens&quot;,taxonomy=x&gt;</span><br><span class="hljs-comment">##phasing=partial</span><br><span class="hljs-comment">##INFO=&lt;ID=NS,Number=1,Type=Integer,Description=&quot;Number of Samples With Data&quot;&gt;</span><br><span class="hljs-comment">##INFO=&lt;ID=DP,Number=1,Type=Integer,Description=&quot;Total Depth&quot;&gt;</span><br><span class="hljs-comment">##INFO=&lt;ID=AF,Number=A,Type=Float,Description=&quot;Allele Frequency&quot;&gt;</span><br><span class="hljs-comment">##INFO=&lt;ID=AA,Number=1,Type=String,Description=&quot;Ancestral Allele&quot;&gt;</span><br><span class="hljs-comment">##INFO=&lt;ID=DB,Number=0,Type=Flag,Description=&quot;dbSNP membership, build 129&quot;&gt;</span><br><span class="hljs-comment">##INFO=&lt;ID=H2,Number=0,Type=Flag,Description=&quot;HapMap2 membership&quot;&gt;</span><br><span class="hljs-comment">##FILTER=&lt;ID=q10,Description=&quot;Quality below 10&quot;&gt;</span><br><span class="hljs-comment">##FILTER=&lt;ID=s50,Description=&quot;Less than 50% of samples have data&quot;&gt;</span><br><span class="hljs-comment">##FORMAT=&lt;ID=GT,Number=1,Type=String,Description=&quot;Genotype&quot;&gt;</span><br><span class="hljs-comment">##FORMAT=&lt;ID=GQ,Number=1,Type=Integer,Description=&quot;Genotype Quality&quot;&gt;</span><br><span class="hljs-comment">##FORMAT=&lt;ID=DP,Number=1,Type=Integer,Description=&quot;Read Depth&quot;&gt;</span><br><span class="hljs-comment">##FORMAT=&lt;ID=HQ,Number=2,Type=Integer,Description=&quot;Haplotype Quality&quot;&gt;</span><br><span class="hljs-comment">#CHROM POS ID REF ALT QUAL FILTER INFO  FORMAT  NA00001 NA00002</span><br><span class="hljs-number">1</span> <span class="hljs-number">899282</span> rs28548431 C T <span class="hljs-number">71.77</span> PASS AC=<span class="hljs-number">1</span>;AF=<span class="hljs-number">0</span>.<span class="hljs-number">50</span>;AN=<span class="hljs-number">2</span>;DB;DP=<span class="hljs-number">4</span>;Dels=<span class="hljs-number">0</span>.<span class="hljs-number">00</span>;HRun=<span class="hljs-number">0</span>;HaplotypeScore=<span class="hljs-number">0</span>.<span class="hljs-number">00</span>;MQ=<span class="hljs-number">99.00</span>;MQ<span class="hljs-number">0</span>=<span class="hljs-number">0</span>;QD=<span class="hljs-number">17.94</span>;SB=-<span class="hljs-number">46.55</span>;VQSLOD=-<span class="hljs-number">1.9148</span> GT:AD:DP:GQ:PL <span class="hljs-number">0</span>/<span class="hljs-number">1</span>:<span class="hljs-number">1</span>,<span class="hljs-number">3</span>:<span class="hljs-number">4</span>:<span class="hljs-number">25.92</span>:<span class="hljs-number">103</span>,<span class="hljs-number">0</span>,<span class="hljs-number">26</span><br><span class="hljs-number">20</span> <span class="hljs-number">14370</span> rs6054257 G A <span class="hljs-number">29</span> PASS NS=<span class="hljs-number">3</span>;DP=<span class="hljs-number">14</span>;AF=<span class="hljs-number">0</span>.<span class="hljs-number">5</span>;DB;H2 GT:GQ:DP:HQ <span class="hljs-number">0</span>|<span class="hljs-number">0</span>:<span class="hljs-number">48</span>:<span class="hljs-number">1</span>:<span class="hljs-number">51</span>,<span class="hljs-number">51</span> <span class="hljs-number">1</span>|<span class="hljs-number">0</span>:<span class="hljs-number">48</span>:<span class="hljs-number">8</span>:<span class="hljs-number">51</span>,<span class="hljs-number">51</span><br><span class="hljs-number">20</span> <span class="hljs-number">17330</span>  .        T A  <span class="hljs-number">3</span> q1<span class="hljs-number">0</span>  NS=<span class="hljs-number">3</span>;DP=<span class="hljs-number">11</span>;AF=<span class="hljs-number">0</span>.<span class="hljs-number">017</span> GT:GQ:DP:HQ <span class="hljs-number">0</span>|<span class="hljs-number">0</span>:<span class="hljs-number">49</span>:<span class="hljs-number">3</span>:<span class="hljs-number">58</span>,<span class="hljs-number">50</span> <span class="hljs-number">0</span>|<span class="hljs-number">1</span>:<span class="hljs-number">3</span>:<span class="hljs-number">5</span>:<span class="hljs-number">65</span>,<span class="hljs-number">3</span><br><span class="hljs-number">20</span> <span class="hljs-number">1110696</span> rs6040355 A G,T <span class="hljs-number">67</span> PASS NS=<span class="hljs-number">2</span>;DP=<span class="hljs-number">10</span>;AF=<span class="hljs-number">0</span>.<span class="hljs-number">333</span>,<span class="hljs-number">0</span>.<span class="hljs-number">667</span>;AA=T;DB GT:GQ:DP:HQ <span class="hljs-number">1</span>|<span class="hljs-number">2</span>:<span class="hljs-number">21</span>:<span class="hljs-number">6</span>:<span class="hljs-number">23</span>,<span class="hljs-number">27</span> <span class="hljs-number">2</span>|<span class="hljs-number">1</span>:<span class="hljs-number">2</span>:<span class="hljs-number">0</span>:<span class="hljs-number">18</span>,<span class="hljs-number">2</span><br><span class="hljs-number">20</span> <span class="hljs-number">1230237</span> . T  .  <span class="hljs-number">47</span> PASS NS=<span class="hljs-number">3</span>;DP=<span class="hljs-number">13</span>;AA=T GT:GQ:DP:HQ <span class="hljs-number">0</span>|<span class="hljs-number">0</span>:<span class="hljs-number">54</span>:<span class="hljs-number">7</span>:<span class="hljs-number">56</span>,<span class="hljs-number">60</span> <span class="hljs-number">0</span>|<span class="hljs-number">0</span>:<span class="hljs-number">48</span>:<span class="hljs-number">4</span>:<span class="hljs-number">51</span>,<span class="hljs-number">51</span><br></code></pre></td></tr></table></figure><ul><li>header: 1.基因组的版本(<strong>hg19,hg38</strong>) 2. info,filter,format注释描述</li><li>CHROM：表示变异位点是在哪个contig 里call出来的，如果是人类全基因组的话那就是chr1…chr22，chrX,Y,M。</li><li>POS：变异位点相对于参考基因组所在的位置，如果是indel，就是第一个碱基所在的位置。</li><li>ID：如果call出来的SNP存在于dbSNP数据库里，就会显示相应的dbSNP里的rs编号。</li><li>REF和REF：在这个变异位点处，参考基因组中所对应的碱基和研究对象基因组中所对应的碱基。</li><li>QUAL：可以理解为所call出来的变异位点的质量值。Q&#x3D;-10lgP，Q表示质量值；P表示这个位点发生错误的概率。因此，如果想把错误率从控制在90%以上，P的阈值就是1&#x2F;10，那lg（1&#x2F;10）&#x3D;-1，Q&#x3D;（-10）*（-1）&#x3D;10。同理，当Q&#x3D;20时，错误率就控制在了0.01。</li><li>FILTER：理想情况下，QUAL这个值应该是用所有的错误模型算出来的，这个值就可以代表正确的变异位点了，但是事实是做不到的。因此，还需要对原始变异位点做进一步的过滤。无论你用什么方法对变异位点进行过滤，过滤完了之后，在FILTER一栏都会留下过滤记录，如果是通过了过滤标准，那么这些通过标准的好的变异位点的FILTER一栏就会注释一个PASS，如果没有通过过滤，就会在FILTER这一栏提示除了PASS的其他信息。如果这一栏是一个“.”的话，就说明没有进行过任何过滤。GATK的<strong>VQSR</strong>可以注释。</li><li><strong>INFO</strong> 这一行是variant的详细信息，内容很多，以下再具体详述。一般可以含有annovar注释，GATK注释等信息。</li><li><strong>FORMAT</strong>: 在<strong>header</strong>里面都有其注解。<ul><li><p><strong>GT</strong>：表示这个样本的基因型，对于一个二倍体生物，GT值表示的是这个样本在这个位点所携带的两个等位基因。0表示跟REF一样；1表示表示跟ALT一样；2表示第二个ALT。当只有一个ALT等位基因的时候，0&#x2F;0表示纯和且跟REF一致；0&#x2F;1表示杂合，两个allele一个是ALT一个是REF；1&#x2F;1表示纯和且都为ALT；</p><ul><li>0 - reference call</li><li>1 - alternative call 1</li><li>2 - alternative call 2</li><li>The allele separator is ‘&#x2F;‘ for unphased genotypes and ‘|’ for phased genotypes.</li></ul></li><li><p><strong>AD</strong>：对应两个以逗号隔开的值，这两个值分别表示覆盖到REF和ALT碱基的reads数，相当于支持REF和支持ALT的测序深度。</p></li><li><p><strong>DP</strong>：覆盖到这个位点的总的reads数量，相当于这个位点的深度。</p></li><li><p><strong>PL</strong>: 对应3个以逗号隔开的值，这三个值分别表示该位点基因型是0&#x2F;0，0&#x2F;1，1&#x2F;1的没经过先验的标准化Phred-scaled似然值（L）。如果转换成支持该基因型概率（P）的话，由于L&#x3D;-10lgP，那么P&#x3D;10^（-L&#x2F;10），因此，当L值为0时，P&#x3D;10^0&#x3D;1。因此，这个值越小，支持概率就越大，也就是说是这个基因型的可能性越大。</p></li><li><p><strong>GQ</strong>：表示最可能的基因型的质量值。表示的意义同QUAL。</p></li><li><p>其他：</p><ul><li>FS: FisherStrand的缩写，表示使用Fisher’s精确检验来检测strand bias而得到的Fhred格式的p值，该值越小越好；如果该值较大，表示strand bias（正负链偏移）越严重，即所检测到的variants位点上，reads比对到正负义链上的比例不均衡。一般进行filter的时候，推荐保留FS&lt;10-20的variants位点。GATK可设定FS参数。</li><li>ReadPosRandSum: Z-score from Wilcoxon rank sum test of Alt vs. Ref read position bias.当variants出现在reads尾部的时候，其结果可能不准确。该值用于衡量alternative allele（变异的等位基因）相比于reference allele（参考基因组等位基因），其variant位点是否匹配到reads更靠中部的位置。因此只有基因型是杂合且有一个allele和参考基因组一致的时候，才能计算该值。若该值为正值，表明和alternative allele相当于reference allele，落来reads更靠中部的位置；若该值是负值，则表示alternative allele相比于reference allele落在reads更靠尾部的位置。 进行filter的之后，推荐保留ReadPosRankSum&gt;-1.65 - -3.0的variant位点</li><li>MQRankSum: 该值用于衡量alternative allele上reads的mapping quality与reference allele上reads的mapping quality的差异。若该值是负数值，则表明alternative allele比reference allele的reads mapping quality差。进行filter的时候，推荐保留MQRankSum&gt;-1.65 - -3.0的variant位点。</li><li>HaplotypeScore： Consistency of the site with at most two segregating haplotypes</li><li>InbreedingCoeff： Inbreeding coefficient as estimated from the genotype likelihoods per-sample when compared against the Hard-Weinberg expectation</li><li>MLEAC：Maximum likelihood expectation (MLE) for the allele counts (not necessarily the same as the AC), for each ALT allele, in the same order as listed</li><li>MLEAF：Maximum likelihood expectation (MLE) for the allele frequency (not necessarily the same as the AF), for each ALT alle in the same order as listed</li><li>MQ：RMS Mapping Quality</li><li>MQ0：Total Mapping Quality Zero Reads</li><li>MQRankSum： Z-score From Wilcoxon rank sum test of Alt vs. Ref read mapping qualities</li><li>QD：Variant Confidence&#x2F;Quality by Depth</li><li>RPA：Number of times tandem repeat unit is repeated, for each allele (including reference)</li><li>RU：Tandem repeat unit (bases)</li><li>ReadPosRankSum：Z-score from Wilcoxon rank sum test of Alt vs. Ref read position bias</li><li>STR： Variant is a short tandem repeat</li></ul></li></ul></li></ul><h1 id="2-重要软件-tabix-bgzip"><a href="#2-重要软件-tabix-bgzip" class="headerlink" title="2. 重要软件 tabix bgzip"></a>2. 重要软件 tabix bgzip</h1><ul><li><strong>tabix</strong> 可以对NGS分析中常见格式的文件建立索引，从而加快访问速度，不仅支持VCF文件，还支持BED, GFF，SAM等格式。</li></ul><p>由于SNP位点数量巨大，对应VCF文件也非常的大，为例节省存储空间，最常见的做法就是压缩。<strong>bgzip</strong>可以压缩VCF文件，用法如下</p><blockquote><p>bgzip  view.vcf</p></blockquote><p>压缩之后，原本的<strong>view.vcf</strong>文件就变成了<strong>view.vcf.gz</strong>文件。压缩后缀为.gz, 如果想要解压缩，有以下两种用法</p>  <figure class="highlight cos"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cos">bgzip -<span class="hljs-keyword">d</span> <span class="hljs-keyword">view</span>.vcf.gz<br>gunzip <span class="hljs-keyword">view</span>.vcf.gz<br>gunzip -c <span class="hljs-keyword">view</span>.vcf.gz | less<br>tabix <span class="hljs-keyword">view</span>.vcf.gz <span class="hljs-number">1</span> |less<br></code></pre></td></tr></table></figure><p><strong>bgzip</strong>的压缩算法和<strong>gzip</strong>压缩算法有着相似之处，所以对于bgzip压缩的文件，解压缩时除了可以使用bgzip软件本身，还可以使用gunzip进行解压缩。</p><p>需要注意的是，两种算法虽然有相似之处，但是还是有本质区别的，在对VCF文件压缩时，不可以使用gzip来代替bgzip。</p><p>对于大型的VCF文件而言，如何快速访问其中的记录也是个难点。<strong>tabix</strong>可以对VCF文件构建索引，索引构建好之后，访问速度会快很多。<strong>tabix</strong>对VCF文件建立索引的用法如下</p><blockquote><p>tabix -p vcf view.vcf.gz</p></blockquote><blockquote><p>tabix -s 1 -b 2 -e 2 vcf view.vcf.gz</p></blockquote><p>注意输入的VCF文件必须是使用bgzip压缩之后的VCF文件，生成的索引文件为view.vcf.gz.tbi, 后缀为.tbi。</p><p>构建好索引之后，可以快速的获取指定区域的记录，示例如下</p><ol><li><p>获取位于11号染色体的SNP位点</p><blockquote><p>tabix view.vcf.gz 11</p></blockquote></li><li><p>获取位于11号染色体上突变位置大于或者等于2343545的SNP位点</p><blockquote><p>tabix view.vcf.gz 11:2343545</p></blockquote></li><li><p>获取位于11号染色体上突变位置介于2343540到2343596的SNP位点</p><blockquote><p>tabix view.vcf.gz 11:2343540-2343596</p></blockquote></li><li><p>获取位多个SNP位点</p><blockquote><p>tabix view.vcf.gz 11:2343540-2343596 12:2343540-2343596</p></blockquote></li></ol><p>很多操作VCF的软件都会识别tabix建立的索引，从而加快处理速度。很多大型项目VCF文件，也都会用bgzip压缩，然后建立tabix的索引。</p>]]></content>
    
    
    <categories>
      
      <category>生物信息学</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>3.Sam/Bam文件格式详解</title>
    <link href="/2024/01/22/bam%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F/"/>
    <url>/2024/01/22/bam%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<p><strong>Sam&#x2F;Bam文件格式详解</strong></p><p>bam文件是sam文件的二进制格式。(<a href="https://samtools.github.io/hts-specs/SAMv1.pdf">https://samtools.github.io/hts-specs/SAMv1.pdf</a>)</p><h1 id="1-Header-section"><a href="#1-Header-section" class="headerlink" title="1. Header section"></a>1. Header section</h1><ul><li>该部分全部以“@”开头，提供基本的软件版本，参考序列信息，排序信息等</li><li>@HD行：这一行中有各种不同的标识</li><li>标识“VN”用以说明格式版本</li><li>标识“SO”用以说明比对排序的情况，有unknown (default)、unsorted、queryname和coordinate,对于coordinate，排序的主键是Alignments section的第三列“RNAME”，其顺序由@SQ行的“SN”标识的顺序定义，次要排序键是Alignments section的第四列“POS”字段。对于RNAME和POS相等的比对，排列顺序则是任意的</li><li>@SQ行的“SN”标签是参考序列说明，它的值主要是用于Alignments section的第三列“RNAME”和第七列“MRNM”比对的记录</li><li>@PG行是使用的程序说明；该行“ID”为程序记录标识符，“PN”为程序名字，“CL”为命令行</li><li>@CO行是任意的说明信息</li></ul><p><strong>注意事项</strong></p><ol><li><strong>mapping(bwa,GATK,bismark,…)</strong></li><li><strong>duplication(picard,samblaster,sambamba,…)</strong></li><li><strong>reference genome(hg19,hg38)</strong></li></ol><h1 id="2-Alignments-section"><a href="#2-Alignments-section" class="headerlink" title="2. Alignments section"></a>2. Alignments section</h1><p>该部分包含了11列必需字段，无效或者没有的字段一般用“0”或者“*”表示</p><table><thead><tr><th align="left">Col</th><th align="left">Field</th><th align="center">Type</th><th align="center">Regexp&#x2F;Range</th><th align="left">Brief description</th></tr></thead><tbody><tr><td align="left">1</td><td align="left">QNAME</td><td align="center">String</td><td align="center">[!-?A-~]{1,254}</td><td align="left">Query template NAME</td></tr><tr><td align="left">2</td><td align="left">FLAG</td><td align="center">Int</td><td align="center">[0,$2^{16}$−1]</td><td align="left">bitwise FLAG</td></tr><tr><td align="left">3</td><td align="left">RNAME</td><td align="center">String</td><td align="center">&#96;&#96;&#96;*</td><td align="left">[:rname: <em>&#x3D;][:rname:]</em>&#96;&#96;&#96;</td></tr><tr><td align="left">4</td><td align="left">POS</td><td align="center">Int</td><td align="center">[0,$2^{31}$−1]</td><td align="left">POSition</td></tr><tr><td align="left">5</td><td align="left">MAPQ</td><td align="center">Int</td><td align="center">[0,$2^8$−1]</td><td align="left">MAPping Quality</td></tr><tr><td align="left">6</td><td align="left">CIGAR</td><td align="center">String</td><td align="center">\*|([0-9]+[MIDNSHPX&#x3D;])+</td><td align="left">CIGAR string</td></tr><tr><td align="left">7</td><td align="left">RNEXT</td><td align="center">String</td><td align="center">\*|&#x3D;|[:rname:*&#x3D;][:rname:]*</td><td align="left">Reference name of the mate&#x2F;next read</td></tr><tr><td align="left">8</td><td align="left">PNEXT</td><td align="center">Int</td><td align="center">[0,$2^{31}$−1]</td><td align="left">Position of the mate&#x2F;next read</td></tr><tr><td align="left">9</td><td align="left">TLEN</td><td align="center">Int</td><td align="center">[−$2^{31}$+1,$2^{31}$−1]</td><td align="left">observed Template LENgth</td></tr><tr><td align="left">10</td><td align="left">SEQ</td><td align="center">String</td><td align="center">\*|[A-Za-z&#x3D;.]+</td><td align="left">segment SEQuence</td></tr><tr><td align="left">11</td><td align="left">QUAL</td><td align="center">String</td><td align="center">[!-~]+ (U+2227)</td><td align="left">ASCII of Phred-scaled base QUALity+33</td></tr></tbody></table><ul><li>1.QNAME 序列的名字，也就是reads的名称 </li><li>2.<strong>FLAG</strong> 是一个标记的数字，是有需要转换成二进制才能知道代表的意思，各个数字分别代表</li><li>3.RNAME 参考序列的名字 </li><li>4.POS 在参考序列上的位置 </li><li>5.MAPQ mapping qulity 越高则位点越独特，比对的质量值</li><li>6.<strong>CIGAR</strong> 代表比对结果的CIGAR字符串，如37M1D2M1I，这段字符的意思是37个匹配，1个参考序列上的删除，2个匹配，1个参考序列上的插入。M代表的是alignment match(可以是错配)，可以理解为表示比对的具体情况 </li><li>7.RNEXT mate 序列所在参考序列的名称，mate一般指大的片段序列 </li><li>8.PNEXT mate 序列在参考序列上的位置 </li><li>9.<strong>TLEN</strong> 估计出的片段的长度，当mate 序列位于本序列上游时该值为负值。 </li><li>10.SEQ read的序列 </li><li>11.<strong>QUAL</strong> read序列对应的ASCII码格式的碱基质量值 </li><li>12.可选的区域 header section</li></ul><h2 id="2-1-第1列：Qname"><a href="#2-1-第1列：Qname" class="headerlink" title="2.1 第1列：Qname"></a>2.1 第1列：Qname</h2><ul><li>Read的名字</li></ul><h2 id="2-2-第2列：FLAG"><a href="#2-2-第2列：FLAG" class="headerlink" title="2.2 第2列：FLAG"></a>2.2 第2列：FLAG</h2><ul><li><p>每一个read的比对情况可以用十进制数字（或者十六进制数字）表示，如果比对情况 有多个，将多个比对情况所代表的十进制数字加和就是这一行的FLAG。</p><ul><li>比如，图1中r001的FLAG是99（1+2+32+64），则表示了“该read是pair read中的一个”，“pair read中每个都能够正确比对上”，“该read的mate read的反向互补可以比对上”，“该read是pari read中的read1”；</li><li>r001的另一个FLAG是147（1+2+16+128），则表示“该read是pair read中的一个”，“pair read中每个都能够正确比对上”，“该read是原read的反向互补”，“该read是pari read中的read2”（也就是说，该read是read2的反向互补序列）。</li></ul></li><li><p>值得注意的是，r001是pair read，而且都能比对上，所以r001出现了两次，如果r001的read1比对到参考序列的2个地方，r001的名字则会出现三次；如果read1比对上一次，read2没有比对上，r001仍会出现2次，不过，其中一个r001的第三列为“*”；所以pair-end测序，read1文件和read2文件同时mapping，相同reads的id最少出现2次。</p></li><li><p>以下网站可以通过输入FLAG值，直接找出该FLAG是那些FLAG的加和：Decoding SAM flags（<a href="https://broadinstitute.github.io/picard/explain-flags.html%EF%BC%89">https://broadinstitute.github.io/picard/explain-flags.html）</a></p></li></ul><table><thead><tr><th align="left">Value 10</th><th align="left">Value 16</th><th align="left">Description</th><th align="center">99</th><th align="center">83</th><th align="center">147</th><th align="center">163</th></tr></thead><tbody><tr><td align="left">1</td><td align="left">0x1</td><td align="left">read paired</td><td align="center">+</td><td align="center">+</td><td align="center">+</td><td align="center">+</td></tr><tr><td align="left">2</td><td align="left">0x2</td><td align="left">read mapped in proper pair</td><td align="center">+</td><td align="center">+</td><td align="center">+</td><td align="center">+</td></tr><tr><td align="left">4</td><td align="left">0x4</td><td align="left">read unmapped</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="left">8</td><td align="left">0x8</td><td align="left">mate unmapped</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="left">16</td><td align="left">0x10</td><td align="left">read reverse strand</td><td align="center"></td><td align="center">+</td><td align="center">+</td><td align="center"></td></tr><tr><td align="left">32</td><td align="left">0x20</td><td align="left">mate reverse strand</td><td align="center">+</td><td align="center"></td><td align="center"></td><td align="center">+</td></tr><tr><td align="left">64</td><td align="left">0x40</td><td align="left">first in pair</td><td align="center">+</td><td align="center">+</td><td align="center"></td><td align="center"></td></tr><tr><td align="left">128</td><td align="left">0x80</td><td align="left">second in pair</td><td align="center"></td><td align="center"></td><td align="center">+</td><td align="center">+</td></tr><tr><td align="left">256</td><td align="left">0x100</td><td align="left">not primary alignment</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="left">512</td><td align="left">0x200</td><td align="left">read fails platform&#x2F;vendor quality checks</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="left">1024</td><td align="left">0x400</td><td align="left">read is PCR or optical duplicate</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="left">2048</td><td align="left">0x800</td><td align="left">supplementary alignment</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr></tbody></table><figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs brainfuck"><span class="hljs-literal">-------------------------------------------------------------</span><br><span class="hljs-literal">---</span><span class="hljs-comment">R1</span><span class="hljs-literal">---</span>&gt; <span class="hljs-comment">99</span>                  <span class="hljs-literal">--------</span><span class="hljs-comment">R2</span><span class="hljs-literal">------</span>&gt;  <span class="hljs-comment">163</span><br><br>          &lt;<span class="hljs-literal">----</span><span class="hljs-comment">R2</span><span class="hljs-literal">----</span>  <span class="hljs-comment">147</span>            &lt;<span class="hljs-literal">--------</span><span class="hljs-comment">R1</span><span class="hljs-literal">------</span>  <span class="hljs-comment">83</span><br><span class="hljs-literal">-------------------------------------------------------------</span> <span class="hljs-comment">reverse strand</span><br></code></pre></td></tr></table></figure><h2 id="2-3-第3列：RNAME"><a href="#2-3-第3列：RNAME" class="headerlink" title="2.3 第3列：RNAME"></a>2.3 第3列：RNAME</h2><ul><li>比对上的参考序列的名字，该名字出现在Header section的@SQ行的SN标识中，如果该read没有比对上，也就是说该read在参考序列上没有坐标，那么这一列则用“”表示，那么这一行的POS和CIGAR列也会是“”。</li></ul><h2 id="2-4-第4列：POS"><a href="#2-4-第4列：POS" class="headerlink" title="2.4 第4列：POS"></a>2.4 第4列：POS</h2><ul><li>read比对到的参考序列“RNAME”最左侧的位置坐标，也是CIGAR中第一个比对标识“M”对应的最左侧碱基在参考序列的位置，未比对上的read在参考序列中没有坐标，此列标识为“0”。</li></ul><h2 id="2-5-第5列：MAPQ"><a href="#2-5-第5列：MAPQ" class="headerlink" title="2.5 第5列：MAPQ"></a>2.5 第5列：MAPQ</h2><ul><li>比对的质量值，计算方法为比对错误率的-10*log10的值，一般是四舍五入的整数值，如果是255，说明该比对值无效。</li></ul><h2 id="2-6-第6列：CIGAR"><a href="#2-6-第6列：CIGAR" class="headerlink" title="2.6 第6列：CIGAR"></a>2.6 第6列：CIGAR</h2><p>CIGAR标识符表示read中每个碱基的比对情况，主要有以下标识符：</p><ul><li><p>M: alignment match (can be a sequence match or mismatch)<br>read上的碱基与参考序列“RNAME”完全匹配，碱基一一对应，包括了正确匹配与错误匹配</p></li><li><p>I: insertion to the reference<br>read上的碱基相对于参考序列“RNAME”有插入现象（如下）：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs objectivec">REF:  <span class="hljs-built_in">CACGATCA</span>**GACCGATACGTCCGA <br>READ1:  <span class="hljs-built_in">CGATCAGAGACCGATA</span> <br><span class="hljs-built_in">CIGAR</span>：<span class="hljs-number">6</span>M2I8M<br></code></pre></td></tr></table></figure></li><li><p>D: deletion from the reference<br>read上的碱基相对于参考序列“RNAME”有删除现象（如下）：</p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs avrasm"><span class="hljs-symbol">REF:</span> AGCTAGCATCGTGTCGCCCGTCTAGCATACGC<br><span class="hljs-symbol">READ:</span>             TCGCCCGT-TAGCAT<br>CIGAR：<span class="hljs-number">8</span>M1D6M<br></code></pre></td></tr></table></figure></li><li><p>N: skipped region from the reference<br>read上的碱基相对于参考序列“RNAME”存在连续没有比对上的空缺，这些空缺用N来表示，跟“D”相似但远比“D”缺失的更多，这种比对类型也叫“Spliced alignment”，常见cDNA与参考序列比对（如下）:”…”表示intron</p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs lasso">REF:AGCATCGTGTCGCCCGTCTAGCATACGCATGATCGACTGTCAGCTAGTCAGACTA<br>READ:     GTGTAACCC<span class="hljs-params">...</span><span class="hljs-params">...</span><span class="hljs-params">...</span><span class="hljs-params">...</span><span class="hljs-params">...</span><span class="hljs-params">...</span><span class="hljs-params">...</span><span class="hljs-params">...</span><span class="hljs-params">...</span><span class="hljs-params">...</span>..TCAGAATA<br>CIGAR：<span class="hljs-number">9</span>M32N8M<br></code></pre></td></tr></table></figure></li><li><p>S: soft clipping (clipped sequences present in SEQ)</p></li><li><p>H: hard clipping (clipped sequences NOT present in SEQ)<br>read的开头或者结尾部分没有比对到参考序列”RNAME”上，但这部分未比对上的连续序列仍保留在sam文件的该read序列中，用“S”来表示；如果未保留，则用“H”表示，也即“hard cliping”（如下所示，也可同图2中r003的比对CIGAR中看出）</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs gcode">REF: AGCTAGCATCGTGTCGCCCGTCTAGCATACGCAT<br>READ:          gggTCGCCCGT-TAGCATgggg<br>CIGAR：<span class="hljs-number">3</span>S<span class="hljs-number">8</span><span class="hljs-name">M1</span>D<span class="hljs-number">6</span><span class="hljs-name">M4</span>S （在sam中存储为GGGGTGTAACCGACTAGGGGG）<br>CIGAR：<span class="hljs-number">3</span>H<span class="hljs-number">8</span><span class="hljs-name">M1</span>D<span class="hljs-number">6</span><span class="hljs-name">M4</span>H （在sam中存储为GTGTAACCGACTAG）<br></code></pre></td></tr></table></figure></li><li><p>P: padding (silent deletion from padded reference)<br>多条read比对到参考序列的同一位置时，如果不同read单独同该参考序列比对时，参考序列的情况也不同，比如下方READ1同参考序列比对时，“GA”属于插入（6M2I8M），READ2同参考序列比对时，“A”属于插入（4M1I9M ），READ3同参考序列完全匹配（10M），没有插入，但是三条read之前却没有可比性。因此，当参考序列“比对情况包含完整”且序列唯一时，所有read同时进行比对，read3这种原本没有插入却默认插入的比对称之为Padded alignment，这种情况用“P”表示。</p><figure class="highlight nestedtext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs nestedtext"><span class="hljs-attribute">REF</span><span class="hljs-punctuation">:</span> <span class="hljs-string"> CACGATCA**GACCGATACGTCCGA</span><br><span class="hljs-attribute">READ1</span><span class="hljs-punctuation">:</span> <span class="hljs-string"> CGATCAGAGACCGATA </span><br><span class="hljs-attribute">READ2</span><span class="hljs-punctuation">:</span> <span class="hljs-string">   ATCA*AGACCGATAC </span><br><span class="hljs-attribute">READ3</span><span class="hljs-punctuation">:</span> <span class="hljs-string">  GATCA**GACCG  </span><br><span class="hljs-attribute">The padded CIGAR are different</span><span class="hljs-punctuation">: </span><br><span class="hljs-attribute">READ1</span><span class="hljs-punctuation">:</span> <span class="hljs-string">6M2I8M </span><br><span class="hljs-attribute">READ2</span><span class="hljs-punctuation">:</span> <span class="hljs-string">4M1P1I9M  </span><br><span class="hljs-attribute">READ3</span><span class="hljs-punctuation">:</span> <span class="hljs-string">5M2P5M</span><br></code></pre></td></tr></table></figure></li><li><p>&#x3D;：sequence match 正确匹配</p></li><li><p>X：sequence mismatch 错误匹配</p></li></ul><blockquote><p>perl CIGAR代码 为了检测每个read的甲基化情况</p></blockquote>  <figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">my</span> @f=<span class="hljs-keyword">split</span>(<span class="hljs-regexp">/\s+/</span>,$line);<br><br><span class="hljs-keyword">my</span> $flag = $f[<span class="hljs-number">1</span>];<br><span class="hljs-keyword">my</span> $chr = $f[<span class="hljs-number">2</span>];<br><span class="hljs-keyword">my</span> $pos = $f[<span class="hljs-number">3</span>];<br><span class="hljs-keyword">my</span> $cigar_2 = $f[<span class="hljs-number">5</span>];<br><br><span class="hljs-comment"># parsing CIGAR string</span><br><span class="hljs-keyword">my</span> @len = <span class="hljs-keyword">split</span> (<span class="hljs-regexp">/\D+/</span>,$cigar_2); <span class="hljs-comment"># storing the length per operation</span><br><span class="hljs-keyword">my</span> @ops = <span class="hljs-keyword">split</span> (<span class="hljs-regexp">/\d+/</span>,$cigar_2); <span class="hljs-comment"># storing the operation</span><br><span class="hljs-keyword">shift</span> @ops; <span class="hljs-comment"># remove the empty first element</span><br><span class="hljs-keyword">die</span> <span class="hljs-string">&quot;CIGAR string contained a non-matching number of lengths and operations ($cigar_2)\n&quot;</span> <span class="hljs-keyword">unless</span> (<span class="hljs-keyword">scalar</span> @len == <span class="hljs-keyword">scalar</span> @ops);<br><br><span class="hljs-comment">### determining end position of the read</span><br><span class="hljs-keyword">my</span> $readPos = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">my</span> $genomePos = $pos;<br><br><span class="hljs-keyword">foreach</span> <span class="hljs-keyword">my</span> $index(<span class="hljs-number">0</span>..$#len)&#123;<br><br><span class="hljs-keyword">my</span> $lengthSeg = $len[$index];<br><br><span class="hljs-keyword">if</span> ($ops[$index] eq <span class="hljs-string">&#x27;M&#x27;</span>)&#123;  <span class="hljs-comment"># standard matching bases</span><br><br>$readPos += $lengthSeg;<br>$genomePos += $lengthSeg;<br>  <br>&#125;<br><span class="hljs-keyword">elsif</span>($ops[$index] eq <span class="hljs-string">&#x27;I&#x27;</span>)&#123; <span class="hljs-comment"># insertions do not affect the end position</span><br>  <br>$readPos += $lengthSeg;<br><br>&#125;<br><span class="hljs-keyword">elsif</span>($ops[$index] eq <span class="hljs-string">&#x27;D&#x27;</span>)&#123; <span class="hljs-comment"># deletions do affect the end position</span><br>  $genomePos += $lengthSeg;<br><br>&#125;<span class="hljs-keyword">elsif</span>($ops[$index] eq <span class="hljs-string">&#x27;S&#x27;</span>)&#123; <span class="hljs-comment"># deletions do affect the end position</span><br>    $readPos += $lengthSeg;<br>&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="2-7-第7列：RNEXT"><a href="#2-7-第7列：RNEXT" class="headerlink" title="2.7 第7列：RNEXT"></a>2.7 第7列：RNEXT</h2><ul><li><p>该read的mate read比对上的参考序列的名字，该名字出现在Header section的@SQ行的SN标识中，</p></li><li><p>如果和该read所在行的第三列“RNAME”一样，则用“&#x3D;”表示，说明这对read比对到了同一条参考序列上；</p></li><li><p>如果mate read没有比对上，第七列则用“*”表示；</p></li><li><p>如果这对read没有比对到同一条参考序列，那么这一列则是mate read所在行第三列的“RNAME”。</p></li></ul><h2 id="2-8-第8列：PNEXT"><a href="#2-8-第8列：PNEXT" class="headerlink" title="2.8 第8列：PNEXT"></a>2.8 第8列：PNEXT</h2><ul><li>该read的mate read比对到的参考序列“RNAME”<strong>最左侧</strong>的位置坐标，也是mate read CIGAR中第一个比对标识“M”对应的最左侧碱基在参考序列的位置，未比对上的read在参考序列中没有坐标，此列标识为“0”。</li></ul><h2 id="2-9-第9列：ISIZE"><a href="#2-9-第9列：ISIZE" class="headerlink" title="2.9 第9列：ISIZE"></a>2.9 第9列：ISIZE</h2><ul><li><p>表示pair read完全匹配到同一条参考序列时，两个read之间的长度，可简单理解为测序文库的长度。这个定义有两种情况（虚线表示未比对上的序列，即soft-clipped bases）：</p></li><li><p>第一种情况如图左所示，Read1和Read2比对到同一条参考序列，此时ISIZE即为Read2的最右侧比对坐标减去Read1最左侧比对坐标；</p></li><li><p>第二种情况如图右所示，由于至今没有明确的定义和共识，因此ISIZE可以是TLEN#1，也可以是TLEN#2，视情况而定。</p></li></ul><figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs brainfuck">                                            <span class="hljs-comment">|</span>&lt;<span class="hljs-literal">--</span><span class="hljs-comment">TLEN#1</span><span class="hljs-literal">----</span>&gt;<span class="hljs-comment">|</span><br><span class="hljs-literal">-------------------------------</span>   <span class="hljs-literal">-----------------------------------</span><br><span class="hljs-comment">|</span><span class="hljs-literal">---</span><span class="hljs-comment">R1</span><span class="hljs-literal">---</span>&gt; <span class="hljs-comment">99                               |</span><span class="hljs-literal">---</span><span class="hljs-comment">R1</span><span class="hljs-literal">-----------------</span>&gt; <span class="hljs-comment">99</span> <br><br>                &lt;<span class="hljs-literal">----</span><span class="hljs-comment">R2</span><span class="hljs-literal">----</span><span class="hljs-comment">| 147</span>     &lt;<span class="hljs-literal">----------</span><span class="hljs-comment">R2</span><span class="hljs-literal">---------</span><span class="hljs-comment">|  147</span><br><span class="hljs-literal">-------------------------------</span>   <span class="hljs-literal">------------------------------------</span><br><span class="hljs-comment">|</span>&lt;<span class="hljs-literal">-------</span><span class="hljs-comment">TLEN #1/#2</span><span class="hljs-literal">-------</span>&gt;<span class="hljs-comment">|         |</span>&lt;<span class="hljs-literal">-------</span><span class="hljs-comment">TLEN #2</span><span class="hljs-literal">--------------</span>&gt;<span class="hljs-comment">|</span><br></code></pre></td></tr></table></figure><h2 id="2-10-第10列：SEQ"><a href="#2-10-第10列：SEQ" class="headerlink" title="2.10 第10列：SEQ"></a>2.10 第10列：SEQ</h2><ul><li>存储的序列，没有存储，此列则用“*”标识。该序列的长度<strong>一定等于</strong>CIGAR标识中“M”，“I”，“S”，“&#x3D;”，“X”标识的碱基长度之和。</li></ul><h2 id="2-11-第11列：QUAL-Base-quality-score"><a href="#2-11-第11列：QUAL-Base-quality-score" class="headerlink" title="2.11 第11列：QUAL:Base quality score"></a>2.11 第11列：QUAL:Base quality score</h2><ul><li><p>序列的每个碱基对应一个碱基质量字符，每个碱基质量字符对应的ASCII码值减去33（Sanger Phred-33 质量值体系），即为该碱基的测序质量得分（Phred Quality Score）。不同Phred Quality Score代表不同的碱基测序错误率，如Phred Quality Score值为20和30分别表示碱基测序错误率为1%和0.1%。（ASCII码从0-127，为什么很多Phred评分从33开始呢？因为33是第一个肉眼可见的字符!，在此之前的都是控制符，比如空格、制表等，不方便用这些控制符来表示一个碱基的质量。）</p></li><li><p>假设一个碱基测序错误的概率是P，那么此时对应的Phred quality score（常用Q表示）</p><blockquote><p>$Q &#x3D; -10log_{10}(P)$</p></blockquote></li><li><p>假设100个碱基中有1个出现错误，即P&#x3D;0.01，根据上式可以计算，此时Q&#x3D;20；同理，当测序错误率为0.001时，此时Q&#x3D;30。<br>测序结果中的每一个碱基都有这么一个Phred评分。为了便于描述，人们习惯上将Phred评分对应一个ASCII码，这样每一个碱基的质量都可以用一个字符来表述了。</p></li></ul><table><thead><tr><th align="left">P</th><th align="center">Q (Phred quality score)</th><th align="center">Sanger Phred</th><th align="left">ASCII</th></tr></thead><tbody><tr><td align="left">0.01</td><td align="center">20</td><td align="center">53</td><td align="left"><strong>5</strong></td></tr><tr><td align="left">0.001</td><td align="center">30</td><td align="center">63</td><td align="left"><strong>?</strong></td></tr><tr><td align="left">0.0001</td><td align="center">40</td><td align="center">73</td><td align="left"><strong>I</strong></td></tr><tr><td align="left">0.00001</td><td align="center">50</td><td align="center">83</td><td align="left"><strong>S</strong></td></tr></tbody></table><h1 id="3-samtools-软件使用"><a href="#3-samtools-软件使用" class="headerlink" title="3. samtools 软件使用"></a>3. samtools 软件使用</h1><h2 id="3-1-sort：-sort-alignment-file"><a href="#3-1-sort：-sort-alignment-file" class="headerlink" title="3.1 sort： sort alignment file"></a>3.1 sort： sort alignment file</h2><ul><li>本命令对bam文件中的序列进行排序，默认下是按序列在fasta文件中的顺序（即header）和序列从左往右的位点排序。</li></ul><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs perl">samtools <span class="hljs-keyword">sort</span> [-T out.prefix][-@ threads][-m maxMem][-o out.sorted.bam][in.bam]<br>samtools <span class="hljs-keyword">sort</span> -@ <span class="hljs-number">10</span> -o abc.sorted.bam abc.bam<br>samtools <span class="hljs-keyword">sort</span> -m <span class="hljs-number">500000000</span> -o abc.sorted.bam abc.bam <span class="hljs-comment"># 500M dang abc.bam文件比较大，split的文件比较多，比如200多个。</span><br></code></pre></td></tr></table></figure><h2 id="3-2-merge：-merge-sorted-alignments"><a href="#3-2-merge：-merge-sorted-alignments" class="headerlink" title="3.2 merge： merge sorted alignments"></a>3.2 merge： merge sorted alignments</h2><ul><li><p>本命令将多个排好序的bam比对文件进行合并，产生一个排好序的bam输出文件(合并后的文件不需要再进行sort)，这个文件含有所有的输入记录，并且保留了他们原来的顺序。</p><blockquote><p>samtools merge [out.bam][in1.bam][in2.bam][in3.bam]</p></blockquote></li></ul><h2 id="3-3-index：index-alignment"><a href="#3-3-index：index-alignment" class="headerlink" title="3.3 index：index alignment"></a>3.3 index：index alignment</h2><ul><li><p>本命令对bam文件建立索引并产生后缀为.bai的文件，用于快速的随机处理。很多后续分析的过程需要有bai文件的存在，特别是显示序列比对情况下，比如samtool的tview命令等。#必须对bam文件进行默认情况下的排序后，才能进行index。否则会报错</p><blockquote><p>samtools index aln.sorted.bam</p></blockquote></li></ul><h2 id="3-4-view：SAMBAMCRAM-conversion"><a href="#3-4-view：SAMBAMCRAM-conversion" class="headerlink" title="3.4 view：SAM&lt;-&gt;BAM&lt;-&gt;CRAM conversion"></a>3.4 view：SAM&lt;-&gt;BAM&lt;-&gt;CRAM conversion</h2><ul><li>本命令将sam文件转换成bam文件；然后对bam文件进行各种操作，比如数据的排序和提取(这些操作是对bam文件进行的，不能对sam文件进行该操作)；最后将排序或提取得到的数据输出为bam或sam格式。bam文件优点：bam文件为二进制文件，占用的磁盘空间比sam文本文件小；利用bam二进制文件的运算速度快。</li></ul><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs perl">samtools view -b abc.sam &gt; abc.bam<br>samtools view -b abc.sam -o abc.bam<br></code></pre></td></tr></table></figure><h2 id="3-5-tview"><a href="#3-5-tview" class="headerlink" title="3.5 tview"></a>3.5 tview</h2><ul><li>直观显示reads比对到基因组的情况，与IGV类似需要先sort和index</li></ul><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs perl">samtools tview abc.sorted.bam hg19.fasta<br></code></pre></td></tr></table></figure><ul><li>press <strong>g</strong> to check the alignment start from a region in the format like chr10:10,000,000 or &#x3D;10,000,000 when viewing the same reference sequence.</li><li>c, C, n …</li></ul><h2 id="3-6-depth"><a href="#3-6-depth" class="headerlink" title="3.6 depth"></a>3.6 depth</h2><ul><li>统计每个碱基位点的测序深度;需要使用重定向定义输出文件；要使用构建过索引的bam Usage: bam2depth [-r reg] [-q baseQthres] [-Q mapQthres] [-b in.bed] […] -r：（region）加染色体号； -q：要求测序碱基质量最低值； -Q：要求比对的质量最低值<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs perl">samtools depth abc.sorted.bam &gt;abc.depth<br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <categories>
      
      <category>生物信息学</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>2.常见生信软件安装</title>
    <link href="/2024/01/22/2.%E5%B8%B8%E8%A7%81%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85%E6%95%B4%E7%90%86/"/>
    <url>/2024/01/22/2.%E5%B8%B8%E8%A7%81%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85%E6%95%B4%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="常见生信软件安装"><a href="#常见生信软件安装" class="headerlink" title="常见生信软件安装"></a>常见生信软件安装</h1><h2 id="1-手动安装"><a href="#1-手动安装" class="headerlink" title="1. 手动安装"></a>1. 手动安装</h2><p>bwa, samtools, bcftools, bgzip, tabix</p><h3 id="1-bwa"><a href="#1-bwa" class="headerlink" title="1.bwa"></a>1.bwa</h3><h3 id="2-samtools-bcftools-版本要一致-1-17"><a href="#2-samtools-bcftools-版本要一致-1-17" class="headerlink" title="2.samtools, bcftools 版本要一致 #1.17"></a>2.samtools, bcftools 版本要一致 #1.17</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#Building each desired package from source is very simple:</span><br>    <span class="hljs-built_in">cd</span> samtools-1.x    <span class="hljs-comment"># and similarly for bcftools and htslib</span><br>    ./configure --prefix=/where/to/install<br>    make<br>    make install<br><br>    <span class="hljs-comment">### install bgzip, tabix</span><br>    <span class="hljs-built_in">cd</span> .../samtools-1.17 <span class="hljs-comment"># Within the unpacked release directory</span><br>    ./configure --prefix=/path/to/location<br>    make all all-htslib<br>    make install install-htslib<br></code></pre></td></tr></table></figure><h2 id="2-conda安装包安装"><a href="#2-conda安装包安装" class="headerlink" title="2. conda安装包安装"></a>2. conda安装包安装</h2><h3 id="1-conda-install-c-bioconda-pysam-会安装一下3个包"><a href="#1-conda-install-c-bioconda-pysam-会安装一下3个包" class="headerlink" title="1.conda install -c bioconda pysam #会安装一下3个包"></a>1.conda install -c bioconda pysam #会安装一下3个包</h3><pre><code class="hljs">samtools=1.3.1bcftools=1.3.1htslib=1.3.1</code></pre><h3 id="2-snakemake"><a href="#2-snakemake" class="headerlink" title="2.snakemake"></a>2.snakemake</h3><pre><code class="hljs">安装 mambaconda install -n base -c conda-forge mamba将 snakemake 安装到虚拟环境mamba create -c conda-forge -c bioconda -n snakemake snakemakeconda activate snakemakesnakemake --helpgit clone https://bitbucket.org/snakemake/snakemake-tutorial.gitcd snakemake-tutorialtree安装pipeline所需要的包，比如bwa，samtools等conda install -c conda-forge graphviz #dot画图 2.42.3 装在 snakemake 的环境下面。snakemake --dag  | dot -Tsvg &gt; dag.svg #生成有向无环图 (DAG)snakemake --cores 1 snakemake --cores 1snakemake -s Snakefile</code></pre><h3 id="3"><a href="#3" class="headerlink" title="3"></a>3</h3><h2 id="3-R-安装包"><a href="#3-R-安装包" class="headerlink" title="3.R 安装包"></a>3.R 安装包</h2><p>conda active r-base<br>conda install R </p>]]></content>
    
    
    <categories>
      
      <category>生物信息学</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>1.Linux 常见命令</title>
    <link href="/2024/01/22/1.linuxCommandLine/"/>
    <url>/2024/01/22/1.linuxCommandLine/</url>
    
    <content type="html"><![CDATA[<h1 id="Unix-Linux-操作系统介绍"><a href="#Unix-Linux-操作系统介绍" class="headerlink" title="Unix&#x2F;Linux 操作系统介绍"></a>Unix&#x2F;Linux 操作系统介绍</h1><h2 id="1-文件的cp、rm和mv命令"><a href="#1-文件的cp、rm和mv命令" class="headerlink" title="1. 文件的cp、rm和mv命令"></a>1. 文件的cp、rm和mv命令</h2><h3 id="cp-复制"><a href="#cp-复制" class="headerlink" title="cp 复制"></a>cp 复制</h3><ul><li><p>说明:该命令的功能是将指定的文件或目录拷贝到另一文件或目录中。可以使用通配符拷贝具有同一特征的所有文件。</p></li><li><p>语法: cp [参数] 源文件或目录 目标文件或目录</p></li><li><p>参数:</p><ul><li>-a  该选项通常在拷贝目录时使用。它保留链接、文件属性，并递归地拷贝目录，其作用等于dpR 选项的组合。</li><li>-d  拷贝时保留链接。</li><li>-f  删除已经存在的目标文件而不提示。</li><li>-i  和 f 选项相反，在覆盖目标文件之前将给出提示要求用户确认。回答 y 时目标文件将被覆盖，是交互式拷贝。为防止用户在不经意的情况下用 cp 命令破坏另一个文件，如用户指定 的目标文件名已存在，用 cp 命令拷贝文件后，这个文件就会被新源文件覆盖，因此，建议 用户在使用 cp 命令拷贝文件时，最好使用 i 选项。</li><li>-p  此时 cp 除复制源文件的内容外，还将把其修改时间和访问权限也复制到新文件中。</li><li>-r  若给出的源文件是一目录文件，此时 cp 将递归复制该目录下所有的子目录和文件。此时目标文件必须为一个目录名。 </li><li>-l  不作拷贝，只是链接文件。</li></ul></li><li><p>例子:</p><ul><li>cp file1 file2     将 file1 拷贝成 file2</li><li>cp &#x2F;usr&#x2F;file2 .&#x2F;   将&#x2F;usr 目录下的文件 file2 拷到当前目录下</li><li>cp –i        覆盖相同名称文件前先询问用户</li><li>cp –R        递归拷贝，即拷贝时将所有目录一并拷贝</li><li>cp -p        可以保持源文件的时间属性。否则新文件为当前时间</li><li>cp -rfp      所有目录，强制，时间</li><li>cp –help    查阅命令详细使用信息</li></ul></li></ul><h3 id="mv-删除"><a href="#mv-删除" class="headerlink" title="mv 删除"></a>mv 删除</h3><ul><li><p>说明:用户可以使用mv命令来为文件或目录改名或将文件由一个目录移入另一个目录中。mv命令中第二个参数类型的不同(是目标文件还是目标目录)，mv命令将文件重命名或将其移至一个新的目录中。当第二个参数类型是文件时，mv命令完成文件重命名，此时，源文件只能有一个(也可以是源目录名)，它将所给的源文件或目录重命名为给定的目标文件名。当第二个参数是已存在的目录名称时，源文件或目录参数可以有多个，mv命令将各参数指定的源文件均移至目标目录中。在跨文件系统移动文件时，mv先拷贝，再将原有文件删除，而链至该文件的链接也将丢失。</p></li><li><p>语法:mv [参数] 源文件或目录 目标文件或目录</p></li><li><p>参数:</p><ul><li>-i  交互方式操作。如果 mv 操作将导致对已存在的目标文件的覆盖，此时系统询问是否重写，要求用户回答 y 或 n，这样可以避免误覆盖文件。</li><li>-f  强制执行，在mv操作要覆盖某已有的目标文件时不给任何指示，指定此选项后，i选项将不再起作用。如果所给目标文件(不是目录)已存在，此时该文件的内容将被新文件覆盖。为防止用户用mv命令破坏另一个文件，使用mv命令移动文件时，最好使用i选项。</li></ul></li><li><p>例子:</p><ul><li>mv file1 file2         将 file1改名为file2</li><li>mv.&#x2F;test &#x2F;sdb&#x2F;cgg&#x2F;     将文件test移至&#x2F;sdb&#x2F;cgg目录下</li><li>mv -help     查阅命令详细使用信息</li></ul></li></ul><h3 id="rm-移动"><a href="#rm-移动" class="headerlink" title="rm 移动"></a>rm 移动</h3><ul><li><p>说明:用户可以用 rm 命令删除不需要的文件。该命令可删除一个目录中的一个或多个文件或目录，它也可以将某个目录及其下的所有文件及子目录均删除。对于链接文件，只是断开链接，原文件保持不变。如果没有使用-r 选项，则 rm 不会删除目录。</p></li><li><p>语法:rm [参数] 文件…</p></li><li><p>参数:</p><ul><li>-f  忽略不存在的文件，不给任何提示。</li><li>-r  将列出的全部目录和子目录逐级递归地删除。</li><li>-i  进行交互式删除。文件被删除后是不能被恢复的。为防止误删有用文件，可以使用 i 选项来逐个确认要删除的文件。如果用户输入 y，文件将被删除。否则文件不会删除。</li></ul></li><li><p>例子:</p><ul><li>rm file1 file2 file3    删除三个文件</li><li>rm *                    删除当前目录下所有文件(目录不删除)</li><li>rm –f       强制删除文件，删除时，不提出任何警告讯息</li><li>rm -i       删除文件之前均会询问是否真要删除，y&#x2F;n 指示下一步</li></ul><p><strong>强烈建议将这个参数输入到环境变量中 alias rm&#x3D;&#39;rm -i&#39;</strong></p><ul><li>rm -r       递回式的删除，即逐级删除目录下的子目录。</li><li>rm -help    查阅命令详细使用信息</li></ul></li></ul><h2 id="2-目录的mkdir、rmdir、cd、pwd及ls命令"><a href="#2-目录的mkdir、rmdir、cd、pwd及ls命令" class="headerlink" title="2.目录的mkdir、rmdir、cd、pwd及ls命令"></a>2.目录的mkdir、rmdir、cd、pwd及ls命令</h2><h3 id="mkdir-创建"><a href="#mkdir-创建" class="headerlink" title="mkdir 创建"></a>mkdir 创建</h3><ul><li><p>说明:创建一个目录(类似 MSDOS 下的 md 命令)。要求创建目录的用户在当前目录中(dir- name 的父目录中)具有写权限，并且 dirname 不能是当前目录中已有的目录或文件名称。</p></li><li><p>语法:mkdir [参数] 目录名</p></li><li><p>参数:</p><ul><li>-m  对新建目录设置存取权限。也可以用 chmod 命令设置。</li><li>-p  可以是一个路径名称。此时若路径中的某些目录尚不存在，加上此选项后，系统将自动建立好那些尚不存在的目录，即一次可以建立多个目录。</li></ul></li><li><p>例子:</p><ul><li>mkdir data            在当前目录下建立子目录 data</li><li>mkdir&#x2F;usr&#x2F;data        在&#x2F;usr&#x2F;目录下建立子目录data，此时&#x2F;usr目录必须已经存在。</li></ul></li></ul><h3 id="rmdir-删除"><a href="#rmdir-删除" class="headerlink" title="rmdir 删除"></a>rmdir 删除</h3><ul><li>说明:该命令从一个目录中删除一个或多个子目录项。一个目录被删除之前必须是空的。rm -r dir 命令可代替 rmdir。</li><li>语法:rmdir [参数] 目录名</li><li>参数:<ul><li>-p  递归删除目录，当子目录删除后其父目录为空时，也一同被删除。如果整个路径被删除或者由于某种原因保留部分路径，则系统在标准输出上显示相应的信息。</li></ul></li></ul><h3 id="cd-更改目录"><a href="#cd-更改目录" class="headerlink" title="cd 更改目录"></a>cd 更改目录</h3><ul><li><p>说明:该命令将当前目录改变至指定的目录。若没有指定目录，则回到用户的主目录。</p></li><li><p>语法:cd [目录名]</p></li><li><p>例子:</p><ul><li>cd &#x2F;usr&#x2F;bin 切换至&#x2F;usr&#x2F;bin目录</li><li>cd .. 切换至上一层目录</li><li>cd &#x2F; 切换至根目录</li><li>cd ~ 切换至宿主目录(用户登录时所在的目录)，效果等同于不加指定目录</li></ul></li></ul><h3 id="pwd-命令"><a href="#pwd-命令" class="headerlink" title="pwd 命令"></a>pwd 命令</h3><ul><li>说明:该命令显示用户当前所在的路径，为全路径。 </li><li>语法:pwd</li></ul><h3 id="ls-命令"><a href="#ls-命令" class="headerlink" title="ls 命令"></a>ls 命令</h3><ul><li><p>说明:ls 是英文单词list的简写，其功能为列出目录的内容。对于每个目录，该命令将列出其中的所有子目录与文件。对于每个文件，ls 将输出其文件名以及所要求的其他信息。默认情况下，输出条目按字母顺序排序。当未给出目录名或是文件名时，就显示当前目录的信息。 </p></li><li><p>语法:ls [参数] [目录或是文件]</p></li><li><p>参数:</p><ul><li>-a  显示指定目录下所有子目录与文件，包括隐藏文件。</li><li>-c  按文件的修改时间排序。</li><li>-F  在文件后面加上类型标识:如果是目录，则在后面加“&#x2F;”，如果是可执行文件，则在后面加“*”，如果是个链接，则在后面加“@”，管道(或 FIFO)后面标记“|”，socket 文件后面标记“&#x3D;”</li><li>-L  若指定的名称为一个符号链接文件，则显示链接所指向的文件。</li><li>-r  按字母逆序或最早优先的顺序显示输出结果。</li><li>-R  递归式地显示指定目录的各个子目录中的文件。</li><li>-s  给出每个目录项所用的块数，包括间接块。</li><li>-t  显示时按修改时间(最近优先)而不是按名字排序。若文件修改时间相同，则按字典顺序。</li><li>-l  以长格式来显示文件的详细信息。最常用的参数之一。每行列出的信息依次是:文件类型与权限、链接数、文件属主、文件属组、文件大小、建立或最近修改的时间、文件名。用此参数命令显示的信息中，开头是由 10 个字符构成的字符串，其中第一个字符表示文件类型，它可以是下述类型之一:- 普通文件;d 目录;l 符号链接;b 块设备文件;c 字符设备文件。后面的 9 个字符表示文件的访问权限，分为3组，每组3位。对于目录，表示进入权限。第一组表示文件属主的权限，第二组表示同组用户的权限，第三组表示其他用户的权限。每一组的三个字符分别表示对文件的读(r)、写(w)和执行权限(x)。</li></ul></li><li><p>例子:</p><ul><li>ls                 显示目前目录中所有文件。</li><li>ls &#x2F;usr&#x2F;bin        显示&#x2F;usr&#x2F;bin目录下的文件</li><li>ls -a &#x2F;home&#x2F;cgg    显示&#x2F;home&#x2F;cgg 目录下所有的文件和目录，若无此参数，“.” 开始的隐藏文件和目录不会显示。此命令显示结果为:<figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">. <span class="hljs-string">..</span> <span class="hljs-string">.bash_history</span> <span class="hljs-string">.bash_profile</span> <span class="hljs-string">.bashrc</span> <span class="hljs-string">.tsshrc</span><br></code></pre></td></tr></table></figure></li><li>ls -l file1<figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs tap">-rwxr-xr--<span class="hljs-number"> 1 </span>weiq1 cgg Aug<span class="hljs-number"> 8 </span>05:08 file1<br></code></pre></td></tr></table></figure><ul><li>第一列是文件的属性: <ul><li>第一个字符(-)表示是单纯的文件</li><li>第2-4字符“rwx” 表示此文件属主 weiq1 对文件 file1 的权利为“可读、可写、可执行”;</li><li>第5-7字符“r-x” 表示此用户组 cgg 内的用户对文件 file1 的权利为:“可读、不可写、可执行”;</li><li>第8-10字符“r–” 表示其他用户对文件 file1 的权利为“可读、不可写、不可执行”。</li></ul></li><li>第二列表示文件的链接数为1。</li><li>第三列别是此文件或目录的拥有者是 weiq1 用户。</li><li>第四列表示文件所有者 weiq1 用户所属的组是cgg。</li><li>第五列表示文件大小为 8byte。</li><li>第六列表示文件的修改日期是 8月8日。</li><li>第七列表示文件名为 file1。</li></ul></li></ul></li></ul><h2 id="3-文本查看命令"><a href="#3-文本查看命令" class="headerlink" title="3.文本查看命令"></a>3.文本查看命令</h2><h3 id="less-命令"><a href="#less-命令" class="headerlink" title="less 命令"></a>less 命令</h3><ul><li>说明:less 命令的功能几乎和 more 命令一样，也是用来按页显示文件。此命令可以使用方向键滚动文件。用 less 命令显示文件时，若需要在文件中往前移动，按 b 键;要移动到用文件的百分比表示的某位置，则指定一个 0 到 100 之间的数，并按 p 即可。</li><li>语法:less [参数] 文件 参数:<ul><li>less -S        分列显示</li><li>less -help     显示详细说明文档</li><li>gunzip -c tmp.gz | less    在不解压缩文件的情况下查看其内容，尤其是对于大型压缩文件</li></ul></li></ul><h3 id="more-命令"><a href="#more-命令" class="headerlink" title="more 命令"></a>more 命令</h3><ul><li><p>说明:在终端屏幕按屏显示文本文件，该命令一次显示一屏文本，显示满之后，停下来，并在终端底部打印出 “– More –”，系统还将同时显示出已显示文本占全部文本的百分比，若要继续显示，按回车或空格键即可。若要退出，按 q 或 Q。</p></li><li><p>语法:more [参数] 文件</p></li><li><p>参数:</p><ul><li>-p  显示下一屏之前先清屏。</li><li>-c  作用同- p 基本一样</li><li>-l  不处理 ctrl+l (换页符)。如果没有给出这个选项，则more命令在显示了一个包含有ctrl+l字符的行后将暂停显示，并等待接收命令。</li><li>-s  文件中连续的空白行压缩成一个空白行显示。</li></ul></li><li><p>例子:</p><ul><li>more -c -5 example.txt       执行该命令后，先清屏，然后将以每五行的方式显示文件example.txt的内容。</li></ul></li></ul><h3 id="cat-命令"><a href="#cat-命令" class="headerlink" title="cat 命令"></a>cat 命令</h3><ul><li><p>说明:该命令功能之一是用来显示文件，它依次读取其后所指文件的内容并将其输出到标准输 出。该命令功能之二是用来将两个或多个文件连接起来。</p></li><li><p>语法:cat [参数] 文件</p></li><li><p>参数:</p><ul><li>-v  用一种特殊形式显示控制字符，LFD 与 TAB 除外。加了-v 选项后，-T 和 -E 选项将起作用。</li><li>-T  将 TAB 显示为 “ù I”。该选项需要与 -v 选项一起使用。即如果没有使用 -v 选项，则这个选项将被忽略。</li><li>-E  在每行的末尾显示一个$符。该选项需要与 -v 选项一起使用。 -A 等于 -vET。</li><li>-t  等于 -vT。</li><li>-e  等于 -vE。</li><li>-n  在文件的每行前面显示行号。</li><li>-b  和-n 相似，只不过对于空白行不编号。</li><li>-s  当遇到有连续两行以上的空白行时，就代换为一行的空白行。</li></ul></li><li><p>例子:</p><ul><li>cat -A example.txt          在屏幕上显示出 example.txt 文件的内容，而且如果文件中含有特殊字符的话，一并显示。</li><li>cat file1 file2 &gt; file3     这样就把文件 file1 和文件 file2 的内容合并起来，放入文件file3 中(此时在屏幕上并不能直接看到该命令执行后的结果)。</li></ul></li></ul><h3 id="head-命令"><a href="#head-命令" class="headerlink" title="head 命令"></a>head 命令</h3><ul><li>说明:显示指定文件的前若干行。该命令显示每个指定文件的前面 n 行。如果没有给出 n 值，缺省设置为10。如果没有指定文件，head 就从标准输入读取。</li><li>语法:head [参数] 文件</li><li>参数:<ul><li>-line</li><li>-n line</li></ul></li><li>例子:<ul><li>head -5 example.txt      查看example.txt的前 5 行。</li></ul></li></ul><h3 id="tail-命令"><a href="#tail-命令" class="headerlink" title="tail 命令"></a>tail 命令</h3><ul><li>说明:输出文件内容后面的部分，默认为最后十行。</li><li>语法:tail [参数] 文件</li><li>参数:<ul><li>-n  只显示后面的n行。</li><li>-c  显示最后几个字节。</li><li>-f  动态显示，常用于跟踪消息文件。</li></ul></li><li>例子:<ul><li>tail -5 &#x2F;etc&#x2F;passwd         查看文件&#x2F;etc&#x2F;passwd 的最后 5 行</li><li>tail -n 5 test.txt          查看text.txt文件的后5行</li><li>tail -f &#x2F;var&#x2F;log&#x2F;messages   动态显示文件&#x2F;var&#x2F;log&#x2F;messages 的最后 10 行</li><li>tail -c 10 test.txt         查看 text.txt 文件的后 10 个字节</li></ul></li></ul><h3 id="sed-命令"><a href="#sed-命令" class="headerlink" title="sed 命令"></a>sed 命令</h3><ul><li>说明:此命令功能强大，用法也较复杂，我们这里只给出查看文件中间几行的用法。</li><li>例子:<ul><li>sed -n ‘5,10p’ &#x2F;etc&#x2F;passwd   只查看文件的第 5 行到第 10 行。</li></ul></li></ul><h3 id="grep-命令"><a href="#grep-命令" class="headerlink" title="grep 命令"></a>grep 命令</h3><ul><li>说明:是一过滤器，它可搜索文件并过滤出有某个特征的行。</li><li>语法:grep [参数] 匹配模式 文件</li><li>参数:<ul><li>-n  把所找到的行在行前加上行号列出</li><li>-v  把不包含匹配模式的行列出</li></ul></li><li>例子:<ul><li>grep -n mrna UCSC.list   找出文件 UCSC.list 中含有 mrna 字段的行，并标注行号输出</li></ul></li></ul><h2 id="4-文本处理命令"><a href="#4-文本处理命令" class="headerlink" title="4.文本处理命令"></a>4.文本处理命令</h2><h3 id="sort-命令"><a href="#sort-命令" class="headerlink" title="sort 命令"></a>sort 命令</h3><ul><li>说明:sort 命令的功能是对文件中的各行进行排序，并将结果显示在标准输出上。如不指定输入文件或使用“-”，则表示排序内容来自标准输入。sort排序是根据从输入行抽取的一个或多个关键字进行比较来完成的。排序关键字定义了用来排序的最小的字符序列。默认以整行为 关键字按 ASCII 字符顺序进行排序。</li><li>语法:sort [参数] 文件</li><li>参数:<ul><li>-u  对排序后认为相同的行只留其中一行。</li><li>-o  输出文件，将排序输出写到输出文件中而不是标准输出，如果输出文件是输入文件之一，sort 先将该文件的内容写入一个临时文件，然后再排序和写输出结果。</li><li>-d  按字典顺序排序，比较时仅字母、数字、空格和制表符有意义。</li><li>-f  将小写字母与大写字母同等对待。</li><li>-I  忽略非打印字符。</li><li>-M  作为月份比较:“JAN”&lt;“FEB”。</li><li>-r  按逆序输出排序结果。</li><li>+posl -pos2  指定一个或几个字段作为排序关键字，字段位置从 posl 开始，到 pos2 为止(包括posl，不包括pos2)。如不指定 pos2，则关键字为从posl到行尾。字段和字符的位置从0开始。</li><li>-b  在每行中寻找排序关键字时忽略前导的空白(空格和制表符)。</li><li>-t separator  指定字符 separator 作为字段分隔符。</li></ul></li></ul><h3 id="uniq-命令"><a href="#uniq-命令" class="headerlink" title="uniq 命令"></a>uniq 命令</h3><ul><li>说明:uniq 命令将文件中的重复行中删除，只留下每条记录的唯一样本。如果输入文件用“-” 表示，则从标准输入读取。</li><li>语法:uniq [参数] 文件</li><li>参数:<ul><li>-c  显示输出中，在每行行首加上本行在文件中出现的次数。它可取代-u 和-d 选项。</li><li>-d  只显示重复行。</li><li>-u  只显示文件中不重复的各行。</li><li>-n  前 n 个字段与每个字段前的空白一起被忽略。一个字段是一个非空格、非制表符的字符串，彼此由制表符和空格隔开(字段从 0 开始编号)。</li><li>+n  前 n 个字符被忽略，之前的字符被跳过(字符从 0 开始编号)。 -f n 与-n 相同，这里 n 是字段数。</li><li>-s n  与+n 相同，这里 n 是字符数。</li></ul></li></ul><h3 id="wc-命令"><a href="#wc-命令" class="headerlink" title="wc 命令"></a>wc 命令</h3><ul><li>说明:用来统计给定文件中的字节数、字数、行数。如果没有给出文件名，则从标准输入读 取。wc 同时也给出所有指定文件的总统计数。字是由空格字符区分开的最大字符串。 </li><li>语法:wc [参数] 文件</li><li>参数:<ul><li>-c  统计字节数。</li><li>-l  统计行数。</li><li>-w  统计字数。</li></ul></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">这些选项可以组合使用。输出列的顺序和数目不受选项的顺序和数目的影响。总是按下述顺序显示并且每项最多一列:行数、字数、字节数、文件名<br>如果命令行中没有文件名，则输出中不出现文件名。<br></code></pre></td></tr></table></figure><ul><li>例子:<ul><li>wc test.txt      统计test.txt文件，显示结果如下: 35 103 957 test.txt</li><li>wc -l test.txt   统计 test.txt 文件中的行数，显示结果如下: 35 test.txt</li><li>wc -c test.txt   统计 test.txt 文件中的字符数，显示结果如下: 957 test.txt</li><li>wc -w test.txt   统计 test.txt 文件中的单词数，显示结果如下: 103 test.txt</li></ul></li></ul><h3 id="split-命令"><a href="#split-命令" class="headerlink" title="split 命令"></a>split 命令</h3><ul><li><p>说明:将一个文件分割成数个，生成文件依次为前缀 aa、前缀 ab……默认前缀为x。</p></li><li><p>语法:split [参数] 文件 [前缀]</p></li><li><p>参数:</p><ul><li>-b SIZE      SIZE值为每一输出文件的大小，单位为byte。SIZE可加入单位:b、k、m。</li><li>-l NUMBER    NUMBER值为每一输出文件的行数。</li></ul></li><li><p>例子:</p><ul><li>split -b 30k UCSC.list TEST    将文件 UCSC.list 按每份 30k 大小进行拆分，并生成前缀为 TEST 的各拆分文件。</li></ul></li></ul><h3 id="cut-命令"><a href="#cut-命令" class="headerlink" title="cut 命令"></a>cut 命令</h3><ul><li>说明:截取文件中的某字段。</li><li>语法:cut [参数] 文件</li><li>参数:<ul><li>-c m-n     表示显示每一行的第 m 个字元到第 n 个字元。</li><li>-f m-n     表示显示第 m 栏到第 n 栏(使用 tab 分隔)。</li><li>-d ‘分隔符’ 用来定义分隔符(单个字符)，默认为 tab 键，和-f 配合使用。</li></ul></li><li>例子:<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">- <span class="hljs-built_in">cut</span> -f 1-2 -d <span class="hljs-string">&#x27;,&#x27;</span> UCSC.list   以“，”为分隔符，取文件 UCSC.list 的第一列和第二列。<br></code></pre></td></tr></table></figure></li></ul><h3 id="awk-命令"><a href="#awk-命令" class="headerlink" title="awk 命令"></a>awk 命令</h3><ul><li>说明:对文件进行信息提取等处理。</li><li>语法:awk ‘{操作代码}’ 文件</li><li>例子:<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">- awk <span class="hljs-string">&#x27;&#123; print &#125;&#x27;</span> /etc/passwd            此命令输出/etc/passwd 文件的内容。<br>- awk -F:<span class="hljs-string">&quot;:&quot;</span> <span class="hljs-string">&#x27;&#123; print $1 &#125;&#x27;</span> /etc/passwd  使用-F选项来指定<span class="hljs-string">&quot;:&quot;</span>作为字段分隔符，打印出在输入文件中每一行中出现的第一个字段。<br></code></pre></td></tr></table></figure></li></ul><h2 id="5-改变文件或目录的权限命令"><a href="#5-改变文件或目录的权限命令" class="headerlink" title="5.改变文件或目录的权限命令"></a>5.改变文件或目录的权限命令</h2><ul><li><p>Linux&#x2F;Unix 系统中的每个文件和目录都有访问许可权限，用它来确定谁可以通过何种方式对文件和目录进行访问和操作。文件或目录的访问权限分为只读(r)，只写(w)和可执行(x)三种，可用-表示没有权限。有三种不同类型的用户可对文件或目录进行访问:文件所有者(u)、同组用户(g)和其他用户(o)。所有者一般是文件的创建者,所有者可以将文件的访问权限赋予同组用户或系统中的其他用户。</p></li><li><p>每一文件或目录的访问权限都有三组，每组用三位表示，分别为文件属主的读、写和执行权限;与属主同组的用户的读、写和执行权限;系统中其他用户的读、写和执行权限。当用ls -l命令显示文件或目录的详细信息时，最左边的一列为文件的访问权限。例如:</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">ls</span> -l GC_content.pl<br>-rwxx--x-- 1 weiq1 cgg 1437 Feb 25 17:3l GC_content.pl<br></code></pre></td></tr></table></figure><p>  GC_content.pl 的属主 weiq1 有读写及执行权限;与 GC_content.pl 属主同组cgg的用户只有可执行权限;其他用户也只有可执行权限。<br>  文件的权限及所有者及其属于的用户组都可以用一些命令来改变，下面分别对这些命令加以介绍。</p><h3 id="chmod-命令"><a href="#chmod-命令" class="headerlink" title="chmod 命令"></a>chmod 命令</h3><ul><li><p>说明:chmod 命令用于改变文件或目录的访问权限。用户用它控制文件或目录的访问权限。</p></li><li><p>语法:该命令有两种用法。一种是包含字母和操作符表达式的文字设定法;另一种是包含数字的数字设定法。</p><ul><li><ol><li>文字设定法:chmod [用户] [操作] [权限类型] 文件名 用户可是下述字母中的任一个或者它们的组合:</li></ol><ul><li>u  表示“用户(user)”，即文件或目录的所有者。</li><li>g  表示“同组(group)用户”，即与文件属主有相同组ID的所有用户。o表示“其他(others)用户”。</li><li>a  表示“所有(all)用户”，系统默认值。</li></ul></li><li>操作可以是:<ul><li>‘+’ 添加某个权限。</li><li>‘-‘ 取消某个权限。</li><li>&#x3D;   赋予给定权限并取消其他所有权限(如果有的话)。</li></ul></li><li>权限类型可用下述字母的任意组合，在一个命令行中可给出多个权限方式，其间用逗号隔开:<ul><li>r  可读。</li><li>w  可写。</li><li>x  可执行。</li><li>u  与文件属主拥有一样的权限。</li><li>g  与和文件属主同组的用户拥有一样的权限。</li><li>o  与其他用户拥有一样的权限。</li></ul></li><li>文件名:以空格分开的要改变权限的文件列表，支持通配符。</li></ul></li><li><p>例子:</p><ul><li><p>chmod g+r，o+r GC_content.pl  使同组和其他用户对文件 GC_content.pl 增加可读权限。</p></li><li><p>chmod g+rw  file              增加文件组内可读写的权限</p></li><li><p>chmod o&#x3D;rx  file              更改文件的权限，使其他用户可读可执行</p></li><li><ol start="2"><li>数字设定法:chmod [ddd] 文件名</li></ol></li></ul><p>数字属性的格式为3个从 0 到 7 的八进制数，其代表的用户顺序为(u)(g)(o)。0 表示没有权限，1 表示可执行权限，2 表示可写权限，4 表示可读权限，数字可以相加表示权限的累加。</p><ul><li>例子:<ul><li>chmod 755 GC_content.pl 将文件 GC_content.pl 的权限改为属主可读可写可执行，组内用户及其他用户为可读及可执行。7&#x3D;4(可执行)+2(可写)+1(可读),5&#x3D;4(可执行) +1(可读)。</li></ul></li><li>参数:<ul><li>-r  更改所有的权限，包括子目录及其内文件。</li></ul></li></ul></li></ul><h3 id="chgrp-命令"><a href="#chgrp-命令" class="headerlink" title="chgrp 命令"></a>chgrp 命令</h3><ul><li>说明:改变文件或目录所属的用户组。可以是组ID，也可以是组名(见文件&#x2F;etc&#x2F;group)。如果用户不是该文件的属主或超级用户，则不能改变该文件的组。</li><li>语法:chgrp [参数] group filename</li><li>参数:<ul><li>-R  递归式地改变指定目录及其下的所有子目录和文件的属组。</li></ul></li></ul><h3 id="chown-命令"><a href="#chown-命令" class="headerlink" title="chown 命令"></a>chown 命令</h3><ul><li>说明:更改某个文件或目录的属主和属组。用户及组名可以是名称或ID。注意:普通用户只能将自己的文件或目录改成他人的，而不能进行逆操作。</li><li>语法:chown [参数] 用户或组 文件<ul><li>-R  递归式地改变指定目录及其下的所有子目录和文件的拥有者。</li><li>-v  显示 chown 命令所做的工作。</li></ul></li><li>例子:<ul><li>chown -R soft:bgi genome&#x2F;   将genome目录下所有文件及文件的所有者及变成bgi组的soft用户。</li></ul></li></ul><h2 id="6-备份与压缩命令"><a href="#6-备份与压缩命令" class="headerlink" title="6.备份与压缩命令"></a>6.备份与压缩命令</h2><h3 id="tar-命令"><a href="#tar-命令" class="headerlink" title="tar 命令"></a>tar 命令</h3><ul><li><p>说明:tar 可以为文件和目录创建档案。利用 tar，用户可以为某一特定文件创建档案(备份文件)，也可以在档案中改变文件，或者向档案中加入新的文件。tar 命令可以把一大堆的文件和目录全部打包成一个文件，以便于网络传输。</p></li><li><p>语法:tar [参数] 文件或者目录</p></li><li><p>参数:</p><ul><li>-c  创建新的档案文件。如果用户想备份一个目录或是一些文件，就要选择这个选项。</li><li>-r  把要存档的文件追加到档案文件的末尾。</li><li>-t  列出档案文件的内容，查看已经备份了哪些文件。</li><li>-u  更新文件。就是说，用新增的文件取代原备份文件，如果在备份文件中找不到要更新的文件，则把它追加到备份文件的最后。</li><li>-x  从档案文件中释放文件。</li><li>-z  用 gzip 来压缩&#x2F;解压缩文件，加上该选项后可以将档案文件进行压缩，但还原时也一定要使用该选项进行解压缩。</li></ul></li><li><p>例子:</p><ul><li>tar -cf bin.tar  &#x2F;usr&#x2F;bin  将&#x2F;usr&#x2F;bin目录下所有文件打包成bin.tar</li><li>tar -xf bin.tar            提出bin.tar包里所有文件</li><li>tar -tvf bin.tar           给出 bin 包里的文件列表，并不解压缩</li><li>tar -zxvf bin.tar.gz       解压bin.tar.gz文件</li><li>tar -jxvf bin.tar.bz2       解压bin.tar.bz2文件</li><li>tar -help                  显示此命令的帮助信息</li></ul></li></ul><h3 id="gzip-gunzip-命令"><a href="#gzip-gunzip-命令" class="headerlink" title="gzip(gunzip)命令"></a>gzip(gunzip)命令</h3><ul><li><p>说明:对文件进行压缩和解压缩的命令。压缩文件可以减少文件大小，这有两个明显的好处:一是可以减少存储空间，二是通过网络传输文件时，可以减少传输的时间。压缩后默认产生后缀为.gz 的压缩文件。</p></li><li><p>语法:gzip [参数] 文件名</p></li><li><p>参数:</p><ul><li>-c  将输出写到标准输出上，并保留原有文件。</li><li>-d  将压缩文件解压。</li><li>-l  对每个压缩文件，显示压缩文件的大小、未压缩时大小、压缩比及文件压缩前名字。</li><li>-r  递归式地查找指定目录并压缩其中的所有文件或者是解压缩。</li><li>-t  测试，检查压缩文件是否完整。</li><li>-v  对每一个压缩和解压的文件，显示文件名和压缩比。</li><li>-f  如果压缩的文件重名，则强制覆盖</li><li>-num   用指定的数字 num 调整压缩的速度，-1 或–fast 表示最快压缩方法(低压缩比)，-9 或-</li><li>-best  表示最慢压缩方法(高压缩比)。系统缺省值为 6。</li></ul></li><li><p>例子:</p><ul><li>gzip -l sprot40.dat.gz</li><li>执行结果:<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">compressed</span> uncompr. ratio uncompressed_name<br><span class="hljs-attribute">66088434</span> <span class="hljs-number">320673785</span> <span class="hljs-number">79</span>.<span class="hljs-number">3</span>% sprot40.dat<br></code></pre></td></tr></table></figure></li><li>gzip -d sprot40.dat.gz  解压缩文件 sprot40.dat.gz</li><li>gzip -h                 显示此命令的帮助信息</li></ul></li></ul><h3 id="unzip-命令"><a href="#unzip-命令" class="headerlink" title="unzip 命令"></a>unzip 命令</h3><ul><li>说明:用 MS Windows 下的压缩软件 winzip 压缩的文件一般后缀为.zip，可以用 unzip 命令解压缩。</li><li>语法:unzip [参数] 压缩文件名.zip</li><li>参数:<ul><li>-x  文件列表 解压缩文件，但不包括指定的 file 文件。</li><li>-v  查看压缩文件目录，但不解压。</li><li>-t  测试文件有无损坏，但不解压。</li><li>-d  [目录]，把压缩文件解到指定目录下。</li><li>-z  只显示压缩文件的注解。</li><li>-n  不覆盖已经存在的文件。</li><li>-o  覆盖已存在的文件且不要求用户确认。</li><li>-j  不重建文档的目录结构，把所有文件解压到同一目录下。</li></ul></li></ul><h3 id="compress-命令"><a href="#compress-命令" class="headerlink" title="compress 命令"></a>compress 命令</h3><ul><li>说明:compress 压缩文件，压缩后的文件会加上一个 .Z 后缀以区别未压缩的文件，可以用 uncompress 解压缩或使用参数-d 解压缩。</li><li>语法:compress [参数] 压缩文件名</li><li>参数:<ul><li>-f  如果压缩的文件重名，则强制覆盖。</li><li>-d  解压缩文件。</li><li>-c  将输出写到标准输出上，并保留原有文件。</li></ul></li></ul><h2 id="7-磁盘及系统管理"><a href="#7-磁盘及系统管理" class="headerlink" title="7.磁盘及系统管理"></a>7.磁盘及系统管理</h2><h3 id="df-命令"><a href="#df-命令" class="headerlink" title="df 命令"></a>df 命令</h3><ul><li>说明:检查文件系统的磁盘空间占用情况。可以利用该命令来获取硬盘被占用了多少空间，目前还剩下多少空间等信息。</li><li>语法:df [参数] [文件系统]<ul><li>-a  显示所有文件系统的磁盘使用情况，包括 0 块(block)的文件系统，如&#x2F;proc 文件系统。</li><li>-k  以 k 字节为单位显示。</li><li>-i  显示 i 节点信息，而不是磁盘块。</li><li>-t  显示各指定类型的文件系统的磁盘空间使用情况。</li><li>-x  列出不是某一指定类型文件系统的磁盘空间使用情况(与 t 选项相反)。</li><li>-T  显示文件系统类型。</li></ul></li></ul><h3 id="du-命令"><a href="#du-命令" class="headerlink" title="du 命令"></a>du 命令</h3><ul><li>说明:进入指定目录的每一个子目录并显示该目录占用文件系统数据块(1024 字节)的情况。若没有指定目录，则对当前目录进行统计。</li><li>语法:du [参数] [文件或目录]</li><li>参数:<ul><li>-s  对每个文件或目录只给出占用的数据块总数。</li><li>-a  递归地显示指定目录中各文件及子目录中各文件占用的数据块数。若既不指定-s，也不指定-a，则只显示中的每一个目录及其中的各子目录所占的磁盘块数。</li><li>-b  以字节为单位列出磁盘空间使用情况(系统缺省以 k 字节为单位)。 -k 以 1024 字节为单位列出磁盘空间使用情况。</li><li>-c  最后再加上一个总计(系统缺省设置)。</li><li>-l  计算所有的文件大小，对硬链接文件，则计算多次。</li><li>-x  跳过在不同文件系统上的目录不予统计。</li></ul></li></ul><h3 id="free-命令"><a href="#free-命令" class="headerlink" title="free 命令"></a>free 命令</h3><ul><li>说明:查看当前系统内存的使用情况，显示系统中剩余及已用的物理内存和交换内存，以及共享内存和被核心使用的缓冲区。</li><li>语法:free [参数]</li><li>参数:<ul><li>-b  以字节为单位显示。</li><li>-k  以 K 字节为单位显示。</li><li>-m  以兆字节为单位显示。</li></ul></li></ul><h3 id="top-命令"><a href="#top-命令" class="headerlink" title="top 命令"></a>top 命令</h3><ul><li>说明:即时显示进程动态，进入 top 命令后可以使用如下几个命令进行操作<ul><li>h:  显示帮助信息</li><li>q:  离开此命令 s:更新速度，每几秒更新一次，也可使用空格键手动更新。n:只显示最上面运行的几个进程</li><li>i:  不显示任何闲置 (idle) 或无用 (zombie) 的行程 u:单独显示某一用户的进程，“+”为显示所有用户的进程，</li></ul></li></ul><h3 id="history-命令"><a href="#history-命令" class="headerlink" title="history 命令"></a>history 命令</h3><ul><li>说明:查询历史命令记录</li><li>语法:history [参数]</li><li>参数:<ul><li>number  只显示前面最近使用的几个命令 -c 从下一个命令开始记录</li><li>-h  只显示命令历史记录，不显示命令编号、时间等信息</li><li>-r  反向显示命令的历史纪录，即从最近的一个命令开始显示</li></ul></li></ul><h3 id="ps-命令"><a href="#ps-命令" class="headerlink" title="ps 命令"></a>ps 命令</h3><ul><li>说明:显示用户的运行程序或系统程序。</li><li>语法:ps [参数]</li><li>参数:<ul><li>-e  列出所有用户的进程</li><li>-u  [user]列出用户 user 的进程</li><li>-f  给出详细列表</li></ul></li></ul><h3 id="kill-命令"><a href="#kill-命令" class="headerlink" title="kill 命令"></a>kill 命令</h3><ul><li>说明:杀掉某一进程</li><li>语法:kill [参数]</li><li>参数:<ul><li>[-signal] pid signal 为 0 到 31 的数字，也可以是特定字符串。如数字 9 代表KILL，可以杀掉一般无法终止的程序。</li><li>-l  查看 signal 代表的意思。常用的 signal 有 HUP、STOP、CONT 等。</li></ul></li></ul><h2 id="8-软件安装简介"><a href="#8-软件安装简介" class="headerlink" title="8.软件安装简介"></a>8.软件安装简介</h2><p>后缀为.tar.gz、tar.Z、tar.bz2或.tgz是使用linux&#x2F;Unix系统打包工具tar打包的解压数据包。首先要解压缩，不同扩展名解压缩命令也不相同，如:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">类型 命令<br>.gz   gunzip<br>.Z    uncompress<br>.zip  unzip<br>.bz2  bunzip2<br></code></pre></td></tr></table></figure><p>进入解压缩目录，查看README&#x2F;INSTALL，如果有此类文件，安装前阅读，里面会有安装过程。不同的软件安装不尽相同。一般大致过程如下:</p><ul><li>.&#x2F;configure      配置<ul><li>make           调用make命令进行编译</li><li>make -f file   指定file文件为描述文件。如果没有”-f”参数，则系统将默认当前目录下名为makefile或者名为Makefile的文件为描述文件。</li><li>make install   安装可执行程序</li><li>make clean     删除安装时产生的临时文件</li><li>make uninstall 卸载软件</li></ul></li></ul><p>有些软件包的源代码编译安装后可以用make uninstall命令卸载。如果不提供此功能，则软件的卸载必须手动删除。</p><h2 id="9-其他"><a href="#9-其他" class="headerlink" title="9.其他"></a>9.其他</h2><h3 id="ln-命令"><a href="#ln-命令" class="headerlink" title="ln 命令"></a>ln 命令</h3><ul><li><p>说明:此命令用于链接文件或目录。连结又可分为两种:硬连结(hard link)与软连结 (symbolic link)，硬连结的意思是一个文件可以有多个名称，而软连结的方式则是产生一个特殊的文件，该文件的内容是指向另一个文件的位置。硬连结是存在同一个文件系统中，而软连结却可以跨越不同的文件系统。</p></li><li><p>语法:ln [参数] 源文件或目录 目标文件或目录</p></li><li><p>参数:</p><ul><li>-b  删除，覆盖目标文件之前的备份。</li><li>-d  或-F 建立目录的硬连接。</li><li>-s  对源文件建立符号连接，而非硬连接。</li><li>-f  强行建立文件或目录的连接，不论文件或目录是否存在。</li><li>-i  覆盖既有文件之前先询问用户。</li></ul></li></ul><h3 id="find-命令"><a href="#find-命令" class="headerlink" title="find 命令"></a>find 命令</h3><ul><li><p>说明:在目录结构中搜索文件，并执行指定的操作。该命令提供的寻找条件可以是一个用逻辑运算符 not、and、or 组成的复合条件。</p></li><li><p>语法:find [路径] [参数] [操作]</p></li><li><p>参数:</p><ul><li>-empty  查找系统中空白的文件，或空白的文件目录。</li><li>-name   要查找的文件名，字串内可用通配符 *、?、[ ]。</li><li>-user uname  查找属于某个用户的文件。</li><li>-group gname 查找属于某组的文件。</li><li>-links n     查找有 n 个链接的文件。</li><li>-exec        执行操作</li></ul></li><li><p>例子:</p><ul><li>find bin&#x2F; -name run.sh   查找 bin 目录下名字为 run.sh 的文件。</li><li>find ! -name tmp         该命令查找文件名不是 tmp 的所有文件。</li></ul></li></ul><h3 id="man-命令"><a href="#man-命令" class="headerlink" title="man 命令"></a>man 命令</h3><p>man 是手册 ( manual) 的意思。用来让使用者查询某一命令的具体使用帮助。</p><ul><li>Ctrl+f  或空格键 后翻一页</li><li>Ctrl+b  或 b 前翻一页</li><li>Ctrl+c  或 q 离开</li></ul><h3 id="info-命令"><a href="#info-命令" class="headerlink" title="info 命令"></a>info 命令</h3><p>获取相关命令的详细使用方法</p><ul><li>例如:<ul><li>info ls  可以获取如何使用 info 的详细信息。</li></ul></li></ul><h3 id="重定向"><a href="#重定向" class="headerlink" title="&gt; 重定向"></a>&gt; 重定向</h3><p>可将某命令的结果输出到文件中</p><ul><li>&gt;file    将结果输出到文件file中，如果该文件原本就存在，则该文件原有的内容会被<strong>删除</strong>。</li><li>&gt;&gt;file  将结果输出到文件file中，如果原文件存在，则附加在原文件后面，原文件的内容<strong>不会被清除</strong>。</li></ul><h3 id="管道符"><a href="#管道符" class="headerlink" title="| 管道符"></a>| 管道符</h3><ul><li>可将某命令的结果输出给另一命令。</li></ul><h3 id="screen-用于多重视窗管理程序"><a href="#screen-用于多重视窗管理程序" class="headerlink" title="screen 用于多重视窗管理程序"></a>screen 用于多重视窗管理程序</h3><p>screen为多重视窗管理程序。此处所谓的视窗，是指一个全屏幕的文字模式画面。通常只有在使用telnet登入主机或是使用老式的终端机时，才有可能用到screen程序。</p><ul><li><p>语法:screen [-AmRvx -ls -wipe][-d &lt;作业名称&gt;][-h &lt;行数&gt;][-r &lt;作业名称&gt;][-s <shell>][-S &lt;作业名称&gt;]</p></li><li><p>参数:</p><ul><li>-A 　        将所有的视窗都调整为目前终端机的大小。</li><li>-d&lt;作业名称&gt;  将指定的screen作业离线。</li><li>-h&lt;行数&gt;     指定视窗的缓冲区行数。</li><li>-m 　        即使目前已在作业中的screen作业，仍强制建立新的screen作业。</li><li>-r&lt;作业名称&gt;  恢复离线的screen作业。</li><li>-s&lt;shell&gt;  指定建立新视窗时，所要执行的shell。</li><li>-S&lt;作业名称&gt;  指定screen作业的名称。</li><li>-R      先试图恢复离线的作业。若找不到离线的作业，即建立新的screen作业。</li><li>-v      显示版本信息。</li><li>-x      恢复之前离线的screen作业。</li><li>-ls或–list  显示目前所有的screen作业。</li><li>-wipe        检查目前所有的screen作业，并删除已经无法使用的screen作业。</li></ul></li><li><p>例子:</p><ul><li>screen      &#x2F;&#x2F;创建screen终端</li><li>screen -ls  &#x2F;&#x2F;显示已创建的screen终端</li><li>screen -r   恢复离线的screen作业</li></ul></li><li><p>设置环境变量 ~&#x2F;.screenrc</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs bash">startup_message off<br>vbell off<br>defscrollback 512<br><br>caption always <span class="hljs-string">&quot;%&#123;=u kC&#125; %= %-w%L&gt;%&#123;=b G&#125;[:%n %t:]%&#123;-&#125;%52&lt;%+w %L=&quot;</span><br><span class="hljs-comment">#caption always &quot;%?%F%&#123;-b 4w&#125;%:%&#123;-b bb&#125;%? %H | %l | %m-%d %c |%?%F%&#123;-b 4w&#125;%?%L=%-Lw%45&gt;%&#123;-b w4&#125;%n%f* %t%&#123;-&#125;%+Lw%-0&lt;&quot;</span><br><br>escape ^L^L<br><br>deflogin off<br><span class="hljs-comment"># default shell is zsh</span><br><span class="hljs-comment"># defshell /usr/bin/zsh</span><br><span class="hljs-comment"># default starting dir is ~</span><br><span class="hljs-built_in">chdir</span><br><br><span class="hljs-built_in">bindkey</span> -k F1 prev<br><span class="hljs-built_in">bindkey</span> -k F2 next<br><br></code></pre></td></tr></table></figure><h2 id="10-练习作业"><a href="#10-练习作业" class="headerlink" title="10.练习作业"></a>10.练习作业</h2><ul><li><ol><li>添加或修改下面环境变量。提示:~&#x2F;.bashrc</li></ol><ul><li>alias rm&#x3D;&#39;rm -i&#39;</li><li>alias cp&#x3D;&#39;cp -rfp&#39;</li><li>export PATH&#x3D;&quot;~&#x2F;software&#x2F;bin:$PATH&quot;</li></ul></li><li><ol start="2"><li>安装bwa，samtools</li></ol></li><li><ol start="3"><li>安装miniconda，并通过conda安装R</li></ol></li></ul>]]></content>
    
    
    <categories>
      
      <category>生物信息学</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
