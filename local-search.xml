<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>slurm集群安装</title>
    <link href="/2024/02/01/slurmInstall/"/>
    <url>/2024/02/01/slurmInstall/</url>
    
    <content type="html"><![CDATA[<h1 id="slurm集群安装"><a href="#slurm集群安装" class="headerlink" title="slurm集群安装"></a>slurm集群安装</h1><p>管理员可以部署 SLURM 单机版或集群版。SLURM 是一个资源调度和排队系统，用户可以在控制节点提交作业，由SLURM控制器根据申请的资源将任务分配到计算节点。如果资源不满足，作业将进入队列等待，直到前面的任务完成或资源释放，再开始运行。</p><ul><li><strong>操作系统</strong>: CentOS Linux release 7.9.2009 (Core)</li><li><strong>SLURM</strong>: 23.02.7</li><li><strong>PMIx</strong>: 4.2.9</li></ul><h2 id="slurm-初步了解"><a href="#slurm-初步了解" class="headerlink" title="slurm 初步了解"></a>slurm 初步了解</h2><p>在典型情况下，一台服务器（主节点&#x2F;master）用于登录和提交作业，多个计算节点（node1, node2, node3, …）用于执行计算。这些服务器需要满足以下条件：</p><ul><li><strong>统一的 Linux 账户管理系统</strong>: 方便快速创建 Linux 用户（可以使用 NIS 协议：ypbind，yp-tools）。</li><li><strong>时间同步</strong>: 保证所有节点的时间一致（可以使用网络时间协议：ntp）。</li><li><strong>共享存储</strong>: 需要在每个服务器上都能访问相同的数据（可以使用网络文件系统 NFS）。</li></ul><p>因为下面都是以单机（就只有一台电脑，既可以提交程序，也可以计算程序）为例，其他先不管</p><h2 id="SLURM-组件"><a href="#SLURM-组件" class="headerlink" title="SLURM 组件"></a>SLURM 组件</h2><p>SLURM 包含三个主要组件：</p><ul><li><strong>slurmdbd</strong>: 数据库守护进程，将多个SLURM管理的集群的记账信息记录在同一个数据库中。这个进程只在主节点（master）上运行，用于同步各个节点之间的数据，通常依赖于 MariaDB&#x2F;MySQL。</li><li><strong>slurmctld</strong>: 中央管理守护进程，监控资源和作业。该进程只在主节点上运行，用于控制其他计算节点。</li><li><strong>slurmd</strong>: 各计算节点的守护进程，使其能够被作为远程 shell 使用。此进程只在计算节点上运行，并将一些数据传递到主节点。</li></ul><p>对于单机部署，上述三个程序都需要在同一台电脑上运行。以下是 SLURM 组件的示意图：</p><img src="/2024/02/01/slurmInstall/SlurmComponents.gif" class=""><p>对于单节点部署来说，必须配置 slurmctld 和 slurmd，slurmdbd 可选。然而，为了实现限制每个用户的作业数量、资源使用、作业最长运行时间等约束，还是<strong>需要配置 slurmdbd</strong>。如果是多节点使用 SLURM，还需要挂载网络文件系统（NFS），这些不在本次单节点部署中涉及，有需要的可以自行搜索学习。</p><h2 id="安装依赖软件包"><a href="#安装依赖软件包" class="headerlink" title="安装依赖软件包"></a>安装依赖软件包</h2><p>在安装 Slurm 之前，需要安装一些必要的软件包和工具。在终端中执行以下命令来安装这些软件包：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 安装 EPEL 存储库, 添加了一个第三方源</span><br>sudo yum install epel-release<br><span class="hljs-comment">#安装一些后续运行所依赖的环境 </span><br>sudo yum install -y rpm-build bzip2-devel openssl openssl-devel zlib-devel perl-DBI perl-ExtUtils-MakeMaker pam-devel readline-devel mariadb-devel python3 python3-devel gtk2 gtk2-devel gcc make <br><br><span class="hljs-comment">#sudo yum install -y numactl numactl-devel lua lua-devel rrdtool-devel ncurses-devel man2html libibmad libibumad gcc rng-tools</span><br><span class="hljs-comment"># json jwt http-parser libyaml ofed hdf5 lz4 nvmlInit RSMI/ROCm OneAPI freeipmi librdkafka dbus-1 gtk+ datawarp HPE netloc</span><br><span class="hljs-comment">#这些软件后面会陆续安装</span><br>sudo yum install -y munge munge-libs munge-devel<br>sudo yum install -y hwloc-devel libevent-devel<br>sudo yum install -y mariadb mariadb-server mariadb-devel<br></code></pre></td></tr></table></figure><h2 id="Munge"><a href="#Munge" class="headerlink" title="Munge"></a>Munge</h2><p>Munge 是一个认证服务，用于生成和验证证书，广泛应用于大规模的 HPC 集群中。它允许进程在具有公共用户和组的主机组中，对其他本地或远程进程的 UID 和 GID 进行身份验证。这些主机由共享密钥定义的安全领域构成。Munge 是 Slurm 用于身份验证的工具，确保用户和守护进程的身份得到验证。</p><h3 id="Munge-安装"><a href="#Munge-安装" class="headerlink" title="Munge 安装"></a>Munge 安装</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo yum install munge munge-libs munge-devel -y<br></code></pre></td></tr></table></figure><p>首先，生成 Munge 密钥并确保文件权限正确设置：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo /usr/sbin/create-munge-key <span class="hljs-comment">#Generating a pseudo-random key using /dev/urandom completed</span><br></code></pre></td></tr></table></figure><p>然后，启动 Munge 服务并设置开机自启：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo systemctl <span class="hljs-built_in">enable</span> munge --now <span class="hljs-comment">##Created symlink from /etc/systemd/system/multi-user.target.wants/munge.service to /usr/lib/systemd/system/munge.service</span><br></code></pre></td></tr></table></figure><h3 id="Munge-启动"><a href="#Munge-启动" class="headerlink" title="Munge 启动"></a>Munge 启动</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 开启munge</span><br>sudo systemctl start munge<br><br><span class="hljs-comment"># 启用munge，使其在系统启动时自动启动</span><br>sudo systemctl <span class="hljs-built_in">enable</span> munge<br><br><span class="hljs-comment"># 查看 Munge 服务状态</span><br>systemctl status munge<br><br><span class="hljs-comment"># 查看所有正在运行的服务</span><br>systemctl list-units --<span class="hljs-built_in">type</span>=service<br><br><span class="hljs-comment"># 停止munge</span><br>sudo systemctl stop munge<br><br><span class="hljs-comment"># 重启munge</span><br>sudo systemctl restart munge<br></code></pre></td></tr></table></figure><p>此外，您可以使用以下命令查看所有用户组：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cat</span> /etc/group | less<br></code></pre></td></tr></table></figure><p>通过这些步骤，您可以配置和启动 Munge 以支持 Slurm 的身份验证需求。</p><h2 id="MariaDB"><a href="#MariaDB" class="headerlink" title="MariaDB"></a>MariaDB</h2><p>MariaDB 数据库管理系统是 MySQL 的一个分支，主要由开源社区维护，采用 GPL 授权许可。MariaDB 旨在完全兼容 MySQL，包括 API 和命令行，使其能轻松替代 MySQL。在存储引擎方面，MariaDB 使用 XtraDB 代替 MySQL 的 InnoDB。</p><p>在搭建 SLURM 集群时，推荐使用数据库来存储 SLURM 的作业记账信息及作业完成信息等数据，数据库存储稳定且高效。此次集群搭建过程中，使用 MariaDB 数据库来存储作业信息。</p><p><strong>slurmdbd</strong> 服务用于控制作业统计，一般只需要在主节点配置，因此数据库服务也同样在主节点配置即可。</p><h3 id="MariaDB-安装"><a href="#MariaDB-安装" class="headerlink" title="MariaDB 安装"></a>MariaDB 安装</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 安装 MariaDB 数据库</span><br>sudo yum install mariadb mariadb-server mariadb-devel -y<br><br><span class="hljs-comment"># 启动 MariaDB 服务并设置开机自启</span><br>sudo systemctl start mariadb<br>sudo systemctl <span class="hljs-built_in">enable</span> mariadb<br><br><span class="hljs-comment">#查看 MariaDB 状态</span><br>systemctl status mariadb<br></code></pre></td></tr></table></figure><h3 id="MariaDB-设置"><a href="#MariaDB-设置" class="headerlink" title="MariaDB 设置"></a>MariaDB 设置</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 首次启动 MariaDB 服务，root 用户密码默认为空，设置 root 密码</span><br>sudo mysql_secure_installation<br><br><span class="hljs-comment"># 步骤如下：</span><br><span class="hljs-comment"># 1. 初次运行直接回车，因为 root 用户没有密码，密码为空</span><br>Enter current password <span class="hljs-keyword">for</span> root (enter <span class="hljs-keyword">for</span> none): <br><br><span class="hljs-comment"># 2. 是否设置 root 用户密码，输入 Y</span><br>Set root password? [Y/n] Y<br><br><span class="hljs-comment"># 3. 新密码 12345678</span><br>New password: 12345678<br><br><span class="hljs-comment"># 4. 重新输入新密码 12345678</span><br>Re-enter new password: 12345678<br><br><span class="hljs-comment"># 5. 是否删除匿名用户，输入 Y</span><br>Remove anonymous <span class="hljs-built_in">users</span>? [Y/n] Y <br><br><span class="hljs-comment"># 6. 是否禁止 root 远程登录，输入 Y</span><br>Disallow root login remotely? [Y/n] Y <br><br><span class="hljs-comment"># 7. 是否删除 test 数据库，输入 Y</span><br>Remove <span class="hljs-built_in">test</span> database and access to it? [Y/n] Y <br><br><span class="hljs-comment"># 8. 是否重新加载权限表，输入 Y</span><br>Reload privilege tables now? [Y/n] Y <br></code></pre></td></tr></table></figure><h3 id="MariaDB-配置"><a href="#MariaDB-配置" class="headerlink" title="MariaDB 配置"></a>MariaDB 配置</h3><ul><li><ol><li>修改数据库配置文件，与 Slurm 推荐的值匹配。</li></ol></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#更新 /etc/my.cnf</span><br><br>[mysqld]<br>innodb_buffer_pool_size=4G<br>innodb_log_file_size=64M<br>innodb_lock_wait_timeout=900<br>max_allowed_packet=64M<br><br><span class="hljs-comment"># 删除旧的日志文件并重启 MariaDB</span><br>sudo <span class="hljs-built_in">rm</span> /var/lib/mysql/ib_logfile0 <br>sudo <span class="hljs-built_in">rm</span> /var/lib/mysql/ib_logfile1<br><br>sudo systemctl restart mariadb<br></code></pre></td></tr></table></figure><ul><li><ol start="2"><li>创建 SLURM 用户和数据库</li></ol></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 登录 MariaDB 设置</span><br>mysql -u root -p12345678<br><br><span class="hljs-comment"># 创建 slurm 用户及相关数据库和表</span><br>create user <span class="hljs-string">&#x27;slurm&#x27;</span>@<span class="hljs-string">&#x27;localhost&#x27;</span> identified by <span class="hljs-string">&#x27;SomePassWD1&#x27;</span>;<br><br><span class="hljs-comment">#创建基础数据库</span><br>create database slurm_acct_db;<br>grant all on slurm_acct_db.* TO <span class="hljs-string">&#x27;slurm&#x27;</span>@<span class="hljs-string">&#x27;localhost&#x27;</span> identified by <span class="hljs-string">&#x27;SomePassWD1&#x27;</span> with grant option;<br>grant all on slurm_acct_db.* TO <span class="hljs-string">&#x27;slurm&#x27;</span>@<span class="hljs-string">&#x27;cn0&#x27;</span> identified by <span class="hljs-string">&#x27;SomePassWD1&#x27;</span> with grant option;<br><br><span class="hljs-comment">#创建另一个，这个不强制，但是建议，如果不创建，后面slurm配置需要改，所以还是创建吧</span><br>create database slurm_jobcomp_db;<br>grant all on slurm_jobcomp_db.* TO <span class="hljs-string">&#x27;slurm&#x27;</span>@<span class="hljs-string">&#x27;localhost&#x27;</span> identified by <span class="hljs-string">&#x27;SomePassWD1&#x27;</span> with grant option;<br>grant all on slurm_jobcomp_db.* TO <span class="hljs-string">&#x27;slurm&#x27;</span>@<span class="hljs-string">&#x27;cn0&#x27;</span> identified by <span class="hljs-string">&#x27;SomePassWD1&#x27;</span> with grant option;<br><br><span class="hljs-comment"># 查看数据库和表</span><br>show databases;<br>show tables from slurm_acct_db;<br><br><span class="hljs-comment"># 查看 slurm_acct_db 数据内容</span><br>use slurm_acct_db;<br>SHOW tables;<br>SELECT * FROM acct_table;<br>SELECT * FROM user_table;<br><br>SHOW VARIABLES LIKE <span class="hljs-string">&#x27;innodb_buffer_pool_size&#x27;</span>;<br>SHOW VARIABLES LIKE <span class="hljs-string">&#x27;innodb_log_file_size&#x27;</span>;<br>SHOW VARIABLES LIKE <span class="hljs-string">&#x27;innodb_lock_wait_timeout&#x27;</span>;<br><br><span class="hljs-built_in">exit</span><br></code></pre></td></tr></table></figure><p>通过以上步骤，您将成功安装和配置 MariaDB，以支持 SLURM 的作业记账和统计功能。</p><h2 id="PMIx"><a href="#PMIx" class="headerlink" title="PMIx"></a>PMIx</h2><p>PMIx (Process Management Interface for Exascale) 是一个为大规模并行应用设计的高效进程管理接口。以下是安装 PMIx 的步骤：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#安装必要的依赖项</span><br>sudo yum install -y hwloc-devel libevent-devel<br><br><span class="hljs-comment">#下载并解压 PMIx 源代码：</span><br>wget https://github.com/openpmix/openpmix/releases/download/v4.2.9/pmix-4.2.9.tar.gz<br>tar -zxvf pmix-4.2.9.tar.gz<br><span class="hljs-built_in">cd</span> pmix-4.2.9<br><br><span class="hljs-comment">#配置并安装 PMIx：</span><br>sudo ./configure &amp;&amp; sudo make install -j $(<span class="hljs-built_in">nproc</span>)<br><span class="hljs-comment">#也可以使用如下命令指定安装目录及依赖项路径：</span><br>./configure --prefix=/usr/local/pmix-4.2.9 --with-libevent=/usr/local/libevent --with-hwloc=/usr/local/hwloc<br><br><span class="hljs-comment">#检查安装是否成功：</span><br>pmix_info<br><br><span class="hljs-comment">#PMIx 库文件位置：</span><br>/usr/local/lib/pmix/<br><br><span class="hljs-comment">#PMIx 配置文件位置：</span><br>/usr/local/etc/pmix-mca-params.conf<br><br><span class="hljs-comment">#查看匹配情况</span><br>srun --mpi=list<br></code></pre></td></tr></table></figure><p>通过上述步骤，您将成功安装并配置 PMIx，为您的大规模并行应用提供高效的进程管理支持。</p><h2 id="Slurm"><a href="#Slurm" class="headerlink" title="Slurm"></a>Slurm</h2><h3 id="Slurm-安装"><a href="#Slurm-安装" class="headerlink" title="Slurm 安装"></a>Slurm 安装</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#下载安装 Slurm</span><br>wget https://download.schedmd.com/slurm/slurm-23.02.7.tar.bz2<br><br>tar --bzip -x -f slurm-23.02.7.tar.bz2<br><span class="hljs-built_in">cd</span> slurm-23.02.7<br><br><span class="hljs-comment">#安装 Slurm：</span><br>sudo ./configure &amp;&amp; sudo make install -j $(<span class="hljs-built_in">nproc</span>)<br></code></pre></td></tr></table></figure><h3 id="Slurm-配置"><a href="#Slurm-配置" class="headerlink" title="Slurm 配置"></a>Slurm 配置</h3><p>创建和编辑 <code>slurm.conf</code> 文件。您可以使用 Slurm 官方提供的配置生成器在线生成基本的 <code>slurm.conf</code> 配置文件：</p><p><a href="http://slurm.schedmd.com/configurator.easy.html">Slurm 配置生成器</a></p><p>以下是一些重要的配置项及其说明：</p><ul><li><code>ClusterName</code>: 集群名称，随便写一个，但要与后面的配置对应。</li><li><code>SlurmctldHost</code>: Slurm 控制守护进程的主机名，使用 <code>hostname -s</code> 命令获取主机名。</li><li><code>NodeName</code>: 节点名称，单机单节点时填写本机名字，与 <code>hostname -s</code> 命令结果一致。</li><li><code>NodeAddr</code>: 节点 IP 地址，使用 <code>ip addr</code> 命令获取本机 IP 地址。</li><li><code>SlurmUser</code>: 建议填写 <code>root</code>。</li><li><code>Default MPI Type</code>: 可选，建议选择 <code>PMIX</code>。</li><li><code>Process Tracking</code>: 选择 <code>LinuxProc</code>。</li><li><code>Resource Selection</code>: 选择 <code>Cons_res</code>。</li><li><code>Job Accounting Gather</code>: 选择 <code>Linux</code>。</li><li><code>CPUs</code>, <code>Sockets</code>, <code>CoresPerSocket</code>: 根据 <code>lscpu</code> 命令结果填写。</li><li><code>RealMemory</code>: 根据 <code>free -m</code> 命令结果填写。</li></ul><p>额外配置项：</p><ul><li><code>MpiDefault=pmix</code></li><li><code>AccountingStorageType=accounting_storage/slurmdbd</code></li></ul><p>将生成的 <code>slurm.conf</code> 文件复制到 <code>/usr/local/etc</code> 目录：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo <span class="hljs-built_in">cp</span> slurm.conf /usr/local/etc<br><br>less slurm.conf<br><span class="hljs-comment">#这是我的配置</span><br>ClusterName=cluster<br><br><span class="hljs-comment">#单机就是localhost即可</span><br>SlurmctldHost=localhost<br><br><span class="hljs-comment">#这个是mpi的默认值，用户输入 --mpi=mpix_v3 这时候会覆盖这个</span><br>MpiDefault=pmix<br><br><span class="hljs-comment">#这个优先用cgroup，如果报错，换这个</span><br>ProctrackType=proctrack/linuxproc<br>ReturnToService=1<br>SlurmctldPidFile=/var/run/slurmctld.pid<br>SlurmctldPort=6817<br>SlurmdPidFile=/var/run/slurmd.pid<br>SlurmdPort=6818<br>SlurmdSpoolDir=/var/spool/slurmd<br>SlurmUser=root<br>StateSaveLocation=/var/spool/slurmctld<br>TaskPlugin=task/affinity,task/cgroup<br>InactiveLimit=0<br>KillWait=30<br>MinJobAge=300<br>SlurmctldTimeout=120<br>SlurmdTimeout=300<br>Waittime=0<br>SchedulerType=<span class="hljs-built_in">sched</span>/backfill<br>SelectType=<span class="hljs-keyword">select</span>/cons_tres<br><br><span class="hljs-comment">##连接mariadb数据库，使用账号slurm和密码SomePassWD1登录mysql的slurm_acct_db、slurm_jobcomp_db等</span><br>AccountingStorageEnforce=1<br>AccountingStorageHost=localhost<br>AccountingStoragePass=/var/run/munge/munge.socket.2<br>AccountingStorageType=accounting_storage/slurmdbd<br>AccountingStorageUser=slurm<br><br>JobCompHost=localhost<br>JobCompLoc=slurm_jobcomp_db<br>JobCompPass=SomePassWD1<br>JobCompType=jobcomp/mysql<br>JobCompUser=slurm<br>JobAcctGatherFrequency=30<br>JobAcctGatherType=jobacct_gather/linux<br>SlurmctldDebug=info<br>SlurmctldLogFile=/var/log/slurmctld.log<br>SlurmdDebug=info<br>SlurmdLogFile=/var/log/slurmd.log<br><br><span class="hljs-comment">#注意的是NodeName=storage01，PartitionName=debug这个信息在sinfo都会体现</span><br><span class="hljs-comment">#这个是各个计算节点，单机的话直接 localhost就行，至于CPUs就是你的cpu核心数，错了也没事，一会开启时会有提示应该是多少，Sockets，cpu插槽数；CoresPerSocket每个插槽多少核心，ThreadsPerCore每个核心多少线程， RealMemory内存（不设置的话，用户申请--mem会报错）</span><br>NodeName=storage01 CPUs=104 RealMemory=1031480 Sockets=2 CoresPerSocket=26 ThreadsPerCore=2 State=UNKNOWN<br>PartitionName=debug Nodes=ALL Default=YES MaxTime=INFINITE State=UP<br></code></pre></td></tr></table></figure><h3 id="Slurm-数据库配置"><a href="#Slurm-数据库配置" class="headerlink" title="Slurm 数据库配置"></a>Slurm 数据库配置</h3><p>复制并修改 <code>slurmdbd.conf</code> 配置文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#将修改后的配置文件复制到 `/usr/local/etc` 并设置权限</span><br><span class="hljs-built_in">pwd</span> <span class="hljs-comment"># /data/software/slurm-23.02.7/etc</span><br><span class="hljs-built_in">cp</span> slurmdbd.conf.example slurmdbd.conf<br>sudo <span class="hljs-built_in">cp</span> slurmdbd.conf /usr/local/etc<br>sudo <span class="hljs-built_in">chmod</span> 600 /usr/local/etc/slurmdbd.conf<br><br>less slurmdbd.conf<br><span class="hljs-comment">#这是我的配置</span><br>ArchiveJobs=<span class="hljs-built_in">yes</span><br>ArchiveSteps=no<br>AuthType=auth/munge<br>AuthInfo=/var/run/munge/munge.socket.2<br><br>DbdHost=localhost<br>SlurmUser=root<br>DebugLevel=verbose<br>LogFile=/var/log/slurmdbd.log<br>PidFile=/var/run/slurmdbd.pid<br><br><span class="hljs-comment">###连接mariadb数据库，使用账号slurm和密码SomePassWD1登录mysql的slurm_acct_db等</span><br>StorageType=accounting_storage/mysql<br>StorageHost=localhost<br>StoragePort=3306<br>StoragePass=SomePassWD1<br>StorageUser=slurm<br>StorageLoc=slurm_acct_db<br></code></pre></td></tr></table></figure><p>###关键有几个点注意</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#使用munge</span><br>AuthType=auth/munge<br><br><span class="hljs-comment">#munge安装未知</span><br>AuthInfo=/var/run/munge/munge.socket.2<br><br><span class="hljs-comment">#数据库位置，这个就行，因为slurmdbdb只在master上</span><br>DbdHost=localhost<br><br><span class="hljs-comment">#我们就不要新建用户了，直接root更方便</span><br>SlurmUser=root<br><br><span class="hljs-comment">#开启数据插件</span><br>StorageType=accounting_storage/mysql<br><span class="hljs-comment">#数据库的新建用户</span><br>StorageUser=slurm<br><span class="hljs-comment">#数据库这个slurm用户的密码</span><br>StoragePass=SomePassWD1<br><span class="hljs-comment">#数据库位置在master，也就是本地</span><br>StorageHost=localhost<br><span class="hljs-comment">#数据库默认端口</span><br>StoragePort=3306<br></code></pre></td></tr></table></figure><h3 id="Slurm-启动和检查"><a href="#Slurm-启动和检查" class="headerlink" title="Slurm 启动和检查"></a>Slurm 启动和检查</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#复制并设置 Slurm 服务文件：</span><br><span class="hljs-built_in">cd</span> /data/software/slurm-23.02.7/etc/<br>sudo <span class="hljs-built_in">chmod</span> 755 *.service<br>sudo <span class="hljs-built_in">cp</span> *.service /etc/systemd/system<br><br><span class="hljs-comment">#启动 Slurm 控制守护进程和节点守护进程，并设置开机自启：</span><br>sudo systemctl <span class="hljs-built_in">enable</span> slurmctld --now<br>sudo systemctl <span class="hljs-built_in">enable</span> slurmd --now<br>sudo systemctl <span class="hljs-built_in">enable</span> slurmdbd --now<br><br><span class="hljs-comment">#检查 Slurm 数据库守护进程状态：</span><br>systemctl status slurmctld<br>systemctl status slurmd<br>systemctl status slurmdbd<br><br><span class="hljs-comment">#使用 `sinfo` 命令查看 Slurm 信息，确保配置成功：</span><br>sinfo<br>scontrol show nodes<br></code></pre></td></tr></table></figure><p>通过以上步骤，您将成功安装并配置 Slurm 集群管理系统，支持 PMIx 和 MariaDB 数据库。</p><h1 id="管理员测试"><a href="#管理员测试" class="headerlink" title="管理员测试"></a>管理员测试</h1><h2 id="开启"><a href="#开启" class="headerlink" title="开启"></a>开启</h2><h3 id="开启-Munge"><a href="#开启-Munge" class="headerlink" title="开启 Munge"></a>开启 Munge</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#切换到 root 用户：</span><br>sudo su<br><br><span class="hljs-comment">#启动 Munge：</span><br>munged<br><br><span class="hljs-comment">#查看日志是否有报错，没有错误信息即可：</span><br>less /usr/local/munge/var/log/munge/munged.log<br><br><span class="hljs-comment">#过几秒后，检查进程是否正常运行：</span><br>ps aux | grep munge<br><br><span class="hljs-comment">#如果输出包含类似以下内容，则表示正常：</span><br>root  1096  0.0  0.0 204152  3676 ?  Sl   12月25   0:01 /usr/local/munge/sbin/munged<br></code></pre></td></tr></table></figure><h3 id="开启-SlurmDBD"><a href="#开启-SlurmDBD" class="headerlink" title="开启 SlurmDBD"></a>开启 SlurmDBD</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#启动 SlurmDBD：</span><br>slurmdbd<br><br><span class="hljs-comment">#查看日志是否有报错，确保启动后的时间里没有错误信息：</span><br><span class="hljs-built_in">cat</span> /var/log/slurmdbd.log<br><br><span class="hljs-comment">#过几秒后，检查进程是否正常运行：</span><br>ps aux | grep slurmdbd<br><br><span class="hljs-comment">#如果输出包含类似以下内容，则表示正常：</span><br>root  2631  0.0  0.0 288368 10012 ?  Ssl  12月25   0:00 /usr/local/slurm/sbin/slurmdbd -D<br></code></pre></td></tr></table></figure><h3 id="开启-SlurmCTLD"><a href="#开启-SlurmCTLD" class="headerlink" title="开启 SlurmCTLD"></a>开启 SlurmCTLD</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#启动 SlurmCTLD：</span><br>slurmctld<br><br><span class="hljs-comment">#查看日志是否有报错，确保启动后的时间里没有错误信息：</span><br><span class="hljs-built_in">cat</span> /var/log/slurmctld.log<br><br><span class="hljs-comment">#过几秒后，检查进程是否正常运行：</span><br>ps aux | grep slurmctld<br><br><span class="hljs-comment">#如果输出包含类似以下内容，则表示正常：</span><br>root  2631  0.0  0.0 288368 10012 ?  Ssl  12月25   0:00 /usr/local/slurm/sbin/slurmctld -D<br></code></pre></td></tr></table></figure><h3 id="开启-Slurmd"><a href="#开启-Slurmd" class="headerlink" title="开启 Slurmd"></a>开启 Slurmd</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#启动 Slurmd：</span><br>slurmd<br><br><span class="hljs-comment">#查看日志是否有报错，确保启动后的时间里没有错误信息：</span><br><span class="hljs-built_in">cat</span> /var/log/slurmd.log<br><br><span class="hljs-comment">#报错1：可能因为 `slurm.conf` 配置文件中的服务器 CPU 等信息填写不正确，根据提示修改。</span><br><span class="hljs-comment">#报错2：可能有 cgroup 相关的报错，将 `slurm.conf` 中 `ProctrackType=proctrack/cgroup` 改为 `ProctrackType=proctrack/linuxproc`。</span><br><br><span class="hljs-comment">#过几秒后，检查进程是否正常运行：</span><br>ps aux | grep slurmd<br><br><span class="hljs-comment">#如果输出包含类似以下内容，则表示正常：</span><br>root  2631  0.0  0.0 288368 10012 ?  Ssl  12月25   0:00 /usr/local/slurm/sbin/slurmd -D<br></code></pre></td></tr></table></figure><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>重新打开 bash 以使配置生效。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash">srun --mpi=list<br><br><span class="hljs-comment">#正常输出应包含：</span><br>srun: MPI types are...<br>srun: pmix<br>srun: pmix_v3<br>srun: cray_shasta<br>srun: none<br>srun: pmi2<br></code></pre></td></tr></table></figure><h2 id="测试-systemd"><a href="#测试-systemd" class="headerlink" title="测试 systemd"></a>测试 systemd</h2><p>其实直接重启就行，如果不想重启，先把刚才测试的进程关闭</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#关闭 slurm 相关进程：</span><br>ps aux | grep slurm<br><br><span class="hljs-comment"># 看到类似这些</span><br>root   2631  0.0  0.0 288368 10012 ?        Ssl  12月25   0:00 /usr/local/slurm/sbin/slurmdbd -D<br>root   2632  0.0  0.0 766548 14736 ?        Ssl  12月25   0:36 /usr/local/slurm/sbin/slurmctld -D<br>root   2633  0.0  0.0  73672  5860 ?        Ss   12月25   0:00 /usr/local/slurm/sbin/slurmd -D<br><br><span class="hljs-comment"># 关闭，那些数字是从刚才里面找的</span><br><span class="hljs-built_in">kill</span> 2631 2632 2633<br><br><span class="hljs-comment">#关闭 munge 进程：</span><br>ps aux | grep munged<br><br><span class="hljs-comment"># 类似</span><br>root        1096  0.0  0.0 204152  3676 ?        Sl   12月25   0:01 /usr/local/munge/sbin/munged<br><span class="hljs-built_in">kill</span> 1096<br><br>ps aux | grep mariadb<br>mysql    130278  0.1  0.0 5558456 424648 ?      Sl   May26   6:54 /usr/libexec/mysqld<br><span class="hljs-built_in">kill</span> 130278<br></code></pre></td></tr></table></figure><p>开机自启</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">systemctl <span class="hljs-built_in">enable</span> --now mariadb<br>systemctl <span class="hljs-built_in">enable</span> --now munge<br><br>systemctl <span class="hljs-built_in">enable</span> --now slurmdbd<br>systemctl <span class="hljs-built_in">enable</span> --now slurmctld<br>systemctl <span class="hljs-built_in">enable</span> --now slurmd<br></code></pre></td></tr></table></figure><p>查看开启状态</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">systemctl status mariadb<br>systemctl status munge<br><br>systemctl status slurmdbd<br>systemctl status slurmctld<br>systemctl status slurmd<br></code></pre></td></tr></table></figure><p>关闭</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">systemctl stop mariadb<br>systemctl stop munge<br><br>systemctl stop slurmdbd<br>systemctl stop slurmctld<br>systemctl stop slurmd<br></code></pre></td></tr></table></figure><p>开启</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">systemctl start mariadb<br>systemctl start munge<br><br>systemctl start slurmdbd<br>systemctl start slurmctld<br>systemctl start slurmd<br></code></pre></td></tr></table></figure><h2 id="查看集群"><a href="#查看集群" class="headerlink" title="查看集群"></a>查看集群</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#查看集群信息：</span><br>sinfo<br><br><span class="hljs-comment">#通常输出如下：</span><br><br>PARTITION AVAIL  TIMELIMIT  NODES  STATE NODELIST<br>ptt1*        up   infinite      1   idle localhost<br><br><span class="hljs-comment">#更详细的</span><br>sinfo -N  -O <span class="hljs-string">&quot;nodelist:.6,partition:.10,available:.6,statelong:.12,memory:.12,allocmem:.10,freemem:.10,cpusstate:.16&quot;</span><br><br><span class="hljs-comment"># 查看当前计算任务</span><br>squeue<br></code></pre></td></tr></table></figure><h2 id="log文件位置"><a href="#log文件位置" class="headerlink" title="log文件位置"></a>log文件位置</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash">/etc/my.cnf <span class="hljs-comment">#mariadb/mysql</span><br>/var/log/mariadb/mariadb.log<br>/var/log/munge/munged.log<br>/var/log/slurmdbd.log  <span class="hljs-comment">#sudo journalctl -u slurmdbd</span><br>/var/log/slurmctld.log<br>/var/log/slurmd.log<br><br>/usr/local/etc/slurmdbd.conf  <span class="hljs-comment">#slurmctld,slurmdbd,</span><br>/usr/local/etc/slurm.conf <span class="hljs-comment">#slurmd,slurmrestd</span><br><span class="hljs-comment"># NodeName=storage01 PartitionName=debug ClusterName=cluster</span><br><br></code></pre></td></tr></table></figure><h2 id="添加用户"><a href="#添加用户" class="headerlink" title="添加用户"></a>添加用户</h2><p>分为3级：Cluster、Account、User</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#添加 Cluster：</span><br>sacctmgr add cluster cluster<br><br><span class="hljs-comment">#添加用户组（账户）</span><br>sacctmgr add account cgg Cluster=cluster<br><br><span class="hljs-comment">#添加用户到用户组</span><br>sacctmgr add user weiq1 Account=cgg<br><br><span class="hljs-comment">#查看信息：</span><br>sacctmgr list Cluster<br>sacctmgr list Account<br>sacctmgr list User<br>sacctmgr show assoc<br><br><span class="hljs-comment">#资源限制</span><br>sudo sacctmgr modify user name=weiq1 <span class="hljs-built_in">set</span> GrpTRESMins=cpu=1000 <span class="hljs-comment">#设置用户的总 CPU 时间限制为 1000 分钟。</span><br>sudo sacctmgr modify user name=weiq1 <span class="hljs-built_in">set</span> MaxJobs=10 <span class="hljs-comment">#设置用户同时运行的最大作业数为 10</span><br>sudo sacctmgr modify user name=weiq1 <span class="hljs-built_in">set</span> MaxSubmitJobs=20 <span class="hljs-comment">#设置用户可以提交的最大作业数为 20</span><br><br><span class="hljs-comment">#为账户设置类似的限制：</span><br>sudo sacctmgr modify account name=cgg <span class="hljs-built_in">set</span> GrpTRESMins=cpu=10000<br>sudo sacctmgr modify account name=cgg <span class="hljs-built_in">set</span> MaxJobs=100<br>sudo sacctmgr modify account name=cgg <span class="hljs-built_in">set</span> MaxSubmitJobs=200<br><br><span class="hljs-comment">#查看用户资源使用情况</span><br>sacct -u weiq1 --format=JobID,JobName,Partition,Account,AllocCPUS,State,ExitCode,Elapsed,MaxRSS<br></code></pre></td></tr></table></figure><h2 id="管理员常用命令"><a href="#管理员常用命令" class="headerlink" title="管理员常用命令"></a>管理员常用命令</h2><h3 id="节点管理"><a href="#节点管理" class="headerlink" title="节点管理"></a>节点管理</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#节点排空，不再接受程序提交：</span><br>scontrol update nodename=node1 state=drain reason=<span class="hljs-string">&#x27;停电节能&#x27;</span><br><br><span class="hljs-comment">#查看节点信息：</span><br>scontrol show node node5<br><br><span class="hljs-comment">#节点恢复：</span><br>scontrol update nodename=node8 state=resume<br><br><span class="hljs-comment">#查看分区状态：</span><br>sinfo -p ptt3<br><br><span class="hljs-comment">#输出如下：</span><br><span class="hljs-comment"># PARTITION AVAIL  TIMELIMIT  NODES  STATE NODELIST</span><br><span class="hljs-comment"># ptt3         up 14-00:00:0      4  drain node[5-8]</span><br><br><span class="hljs-comment">#修改分区程序最大运行时间：</span><br>scontrol update partition=ptt3 MaxTime=20160<br><br><span class="hljs-comment">#彻底修改分区运行时间：</span><br>vim /usr/local/slurm/etc/slurm.conf<br><br><span class="hljs-comment">#在最后几行添加：</span><br>PartitionName=ptt3 Nodes=node[5-8] MaxTime=20160 State=UP<br><br><span class="hljs-comment">#查看任务</span><br>sacct -j 264781<br><br><span class="hljs-comment">#查看用户账户信息以及 CPU 限制：</span><br>sacctmgr list assoc format=Clusters,Account,User,qos,partition,GrpTRES,Priority<br></code></pre></td></tr></table></figure><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><a href="https://yuhldr.github.io/posts/bfa79f01.html">https://yuhldr.github.io/posts/bfa79f01.html</a></li><li><a href="https://zhuanlan.zhihu.com/p/573822867">https://zhuanlan.zhihu.com/p/573822867</a></li><li><a href="https://blog.csdn.net/qq_49014169/article/details/131810125">https://blog.csdn.net/qq_49014169/article/details/131810125</a></li><li><a href="https://juejin.cn/post/7109079132226453540">https://juejin.cn/post/7109079132226453540</a></li><li><a href="https://blog.csdn.net/xueshenlaila/article/details/119270219">https://blog.csdn.net/xueshenlaila/article/details/119270219</a></li><li><a href="https://blog.csdn.net/xhk12345678/article/details/124723242">https://blog.csdn.net/xhk12345678/article/details/124723242</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>slurm</tag>
      
      <tag>mariadb</tag>
      
      <tag>munge</tag>
      
      <tag>pmix</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>5.VCF文件格式详解</title>
    <link href="/2024/01/26/5.VCFFormat/"/>
    <url>/2024/01/26/5.VCFFormat/</url>
    
    <content type="html"><![CDATA[<h1 id="VCF文件格式详解"><a href="#VCF文件格式详解" class="headerlink" title="VCF文件格式详解"></a>VCF文件格式详解</h1><p>VCF介绍</p><p>VCF是用于描述SNP，INDEL和SV结果的文本文件。格式详见说明手册（<a href="https://samtools.github.io/hts-specs/VCFv4.4.pdf%EF%BC%89">https://samtools.github.io/hts-specs/VCFv4.4.pdf）</a></p><p>在GATK、samtools(tabix, bgzip)软件中得到很好的支持。vcf文件做记录个体或群体突变的文件格式，在生物信息学应用中举足轻重。主流的生物信息分析软件，在处理变异信息时，也基本上需要考虑支持解析或输出vcf格式的文件。</p><p>文件一般包含两部分：</p><ul><li>注释信息（header）：位于文件开始，每行以’#’开始</li><li>变异信息（body）：没有’#’即为记录的变异信息<img src="/2024/01/26/5.VCFFormat/vcf_format_v4.4.png" class=""></li></ul><h2 id="1-注释部分"><a href="#1-注释部分" class="headerlink" title="1.注释部分"></a>1.注释部分</h2><p>vcf文件头部主要记录文件原信息（meta information），每行以’##’开始.</p><ul><li>主要记录内容包括下列内容:<table><thead><tr><th>记录内容</th><th>说明</th></tr></thead><tbody><tr><td>文件格式(fileformat)</td><td>记录文件格式；主要记录本文件所采用的vcf格式版本</td></tr><tr><td>信息区域(INFO)描述</td><td>该部分记录的是作为INFO区的基本描述，由于在vcf记录中，对INFO内容采用的是缩写，因此在此部分进行会对其含义以及数据类型进行说明。</td></tr><tr><td>过滤方式(FILTER)</td><td>该部分主要记录vcf文件经过生成过程中经过哪些过滤程序处理。记录包括命令行及对应参数</td></tr><tr><td>个体区域格式信息(FORMAT)</td><td>对于每个样本，vcf正文部分会记录多种信息，例如变异对应深度，该部分记录个体信息中每个字段含义及类型</td></tr><tr><td>突变类型(ALT)</td><td>标识出现在正文信息中突变类型，例如，Insertion、Deletion、Duplication等</td></tr><tr><td>基因组信息(assembly)</td><td>标识对应的基因组版本,<strong>hg19,hg38</strong></td></tr><tr><td>Contig信息</td><td>由于同一物种肯定存在多个基因组版本（如人类目前常用的有hg19和hg38两个版本），因此可能存在染色体名称相同，但内容不同的情况。因此该部分记录主要用于记录每个染色体的相信信息</td></tr><tr><td>样本基因组信息</td><td>vcf理论上支持不同样本比对于不同基因组的，该部分记录样本和基因组的对应关系（通常较少使用）</td></tr><tr><td>遗传谱系信息(Pedigree)</td><td>记录样本间的亲缘关系</td></tr></tbody></table></li></ul><h2 id="2-变异信息"><a href="#2-变异信息" class="headerlink" title="2.变异信息"></a>2.变异信息</h2><p>vcf文件meta信息记录结束之后，下一行就是列名称，列名称以#作为起始，主要包括以下几列：</p><ul><li>CHROM：表示变异位点是在哪个contig里call出来的，如果是人类全基因组的话那就是chr1…chr22，chrX,Y,M。</li><li>POS：变异位点相对于参考基因组所在的位置，如果是indel，就是第一个碱基所在的位置。</li><li>ID：如果call出来的SNP存在于dbSNP数据库里，就会显示相应的dbSNP里的rs编号，空缺时记为“.”</li><li>REF和REF：在这个变异位点处，参考基因组中所对应的碱基和研究对象基因组中所对应的碱基。</li><li>QUAL：可以理解为所call出来的变异位点的质量值。Q&#x3D;-10lgP，Q表示质量值；P表示这个位点发生错误的概率。因此，如果想把错误率从控制在90%以上，P的阈值就是1&#x2F;10，那lg（1&#x2F;10）&#x3D;-1，Q&#x3D;（-10）*（-1）&#x3D;10。同理，当Q&#x3D;20时，错误率就控制在了0.01。</li><li>FILTER：理想情况下，QUAL这个值应该是用所有的错误模型算出来的，这个值就可以代表正确的变异位点了，但是事实是做不到的。因此，还需要对原始变异位点做进一步的过滤。无论你用什么方法对变异位点进行过滤，过滤完了之后，在FILTER一栏都会留下过滤记录，如果是通过了过滤标准，那么这些通过标准的好的变异位点的FILTER一栏就会注释一个PASS，如果没有通过过滤，就会在FILTER这一栏提示除了PASS的其他信息。如果这一栏是一个“.”的话，就说明没有进行过任何过滤。GATK的<strong>VQSR</strong>可以注释。</li><li><strong>INFO</strong> 这一行是variant的详细信息，记录的变异的评价性指标以及注释信息，例如AC表示的等因突变的数量。该部分在不同的变异检测软件给出的结果也是不同的，大多数基础统计可以通过bcftools、GATK、annovar软件来进行追加。</li><li><strong>FORMAT</strong>: 在<strong>header</strong>里面都有其注解。<ul><li><p><strong>GT</strong>：表示这个样本的基因型，对于一个二倍体生物，GT值表示的是这个样本在这个位点所携带的两个等位基因。0表示跟REF一样；1表示表示跟ALT一样；2表示第二个ALT。当只有一个ALT等位基因的时候，0&#x2F;0表示纯和且跟REF一致；0&#x2F;1表示杂合，两个allele一个是ALT一个是REF；1&#x2F;1表示纯和且都为ALT；</p><ul><li>0 - reference call</li><li>1 - alternative call 1</li><li>2 - alternative call 2</li><li>The allele separator is ‘&#x2F;‘ for unphased genotypes and ‘|’ for phased genotypes.</li></ul></li><li><p><strong>AD</strong>：对应两个以逗号隔开的值，这两个值分别表示覆盖到REF和ALT碱基的reads数，相当于支持REF和支持ALT的测序深度。</p></li><li><p><strong>DP</strong>：覆盖到这个位点的总的reads数量，相当于这个位点的深度。</p></li><li><p><strong>PL</strong>: 对应3个以逗号隔开的值，这三个值分别表示该位点基因型是0&#x2F;0，0&#x2F;1，1&#x2F;1的没经过先验的标准化Phred-scaled似然值（L）。如果转换成支持该基因型概率（P）的话，由于L&#x3D;-10lgP，那么P&#x3D;10^（-L&#x2F;10），因此，当L值为0时，P&#x3D;10^0&#x3D;1。因此，这个值越小，支持概率就越大，也就是说是这个基因型的可能性越大。</p></li><li><p><strong>GQ</strong>：表示最可能的基因型的质量值。表示的意义同QUAL。</p></li><li><p>其他：</p><ul><li>FS: FisherStrand的缩写，表示使用Fisher’s精确检验来检测strand bias而得到的Fhred格式的p值，该值越小越好；如果该值较大，表示strand bias（正负链偏移）越严重，即所检测到的variants位点上，reads比对到正负义链上的比例不均衡。一般进行filter的时候，推荐保留FS&lt;10-20的variants位点。GATK可设定FS参数。</li><li>ReadPosRandSum: Z-score from Wilcoxon rank sum test of Alt vs. Ref read position bias.当variants出现在reads尾部的时候，其结果可能不准确。该值用于衡量alternative allele（变异的等位基因）相比于reference allele（参考基因组等位基因），其variant位点是否匹配到reads更靠中部的位置。因此只有基因型是杂合且有一个allele和参考基因组一致的时候，才能计算该值。若该值为正值，表明和alternative allele相当于reference allele，落来reads更靠中部的位置；若该值是负值，则表示alternative allele相比于reference allele落在reads更靠尾部的位置。 进行filter的之后，推荐保留ReadPosRankSum&gt;-1.65 - -3.0的variant位点</li><li>MQRankSum: 该值用于衡量alternative allele上reads的mapping quality与reference allele上reads的mapping quality的差异。若该值是负数值，则表明alternative allele比reference allele的reads mapping quality差。进行filter的时候，推荐保留MQRankSum&gt;-1.65 - -3.0的variant位点。</li><li>HaplotypeScore： Consistency of the site with at most two segregating haplotypes</li><li>InbreedingCoeff： Inbreeding coefficient as estimated from the genotype likelihoods per-sample when compared against the Hard-Weinberg expectation</li><li>MLEAC：Maximum likelihood expectation (MLE) for the allele counts (not necessarily the same as the AC), for each ALT allele, in the same order as listed</li><li>MLEAF：Maximum likelihood expectation (MLE) for the allele frequency (not necessarily the same as the AF), for each ALT alle in the same order as listed</li><li>MQ：RMS Mapping Quality</li><li>MQ0：Total Mapping Quality Zero Reads</li><li>MQRankSum： Z-score From Wilcoxon rank sum test of Alt vs. Ref read mapping qualities</li><li>QD：Variant Confidence&#x2F;Quality by Depth</li><li>RPA：Number of times tandem repeat unit is repeated, for each allele (including reference)</li><li>RU：Tandem repeat unit (bases)</li><li>ReadPosRankSum：Z-score from Wilcoxon rank sum test of Alt vs. Ref read position bias</li><li>STR： Variant is a short tandem repeat</li></ul></li></ul></li></ul><h2 id="3-vcf-的记录模式"><a href="#3-vcf-的记录模式" class="headerlink" title="3.vcf 的记录模式"></a>3.vcf 的记录模式</h2><p>VCF 文件可以记录不同级别的变异信息，从单一变异到个体、组织、群体或家系的变异。</p><ul><li>3.1 只记录变异本身的信息<br>通常用于描述特定变异的特征，不涉及特定个体或群体的信息。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#CHROM POS   ID        REF    ALT    QUAL FILTER INFO</span><br>1  69511  rs75062661  G  A  99    PASS   AC=1;AF=0.0002;AN=5008;NS=2504;DP=2184;EAS_AF=0;AMR_AF=0.0008;AFR_AF=0;EUR_AF=0.001;SAS_AF=0.0007;VT=SNP<br></code></pre></td></tr></table></figure></li><li>3.2 记录个体或个体组织的变异信息<br>在VCF文件的末尾通常会有一个或多个样本列，其中每一列都代表一个个体或个体的某个组织。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#CHROM POS     ID        REF    ALT    QUAL FILTER INFO                             FORMAT          sample1</span><br>1      899282  rs123456  A      G,T    50    PASS   AC=2;AF=0.5;AN=4;NS=1;DP=100   GT:DP:GQ:PL     0/1:50:99:0,20,200<br></code></pre></td></tr></table></figure></li><li>3.3 记录群体或家系的变异信息<br>包括多个样本的数据，可以用于群体遗传学分析。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#CHROM POS     ID         REF    ALT    QUAL FILTER INFO                             FORMAT          Person1      Person2      Person3</span><br>1      945874  rs7891011  A      G      99    PASS   AC=3;AF=0.75;AN=4;NS=3;DP=300  GT:DP:GQ:PL     0/1:100:99:0,20,200  1/1:100:99:0,0,100  0/0:100:99:0,0,0<br></code></pre></td></tr></table></figure>1000 genomes 比较特殊，不同人群的等位基因频率在 INFO 中以不同的字段表示<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">1   10177   rs367896724 A   AC  100 PASS    AC=2130;AF=0.425319;AN=5008;NS=2504;DP=103152;EAS_AF=0.3363;AMR_AF=0.3602;AFR_AF=0.4909;EUR_AF=0.4056;SAS_AF=0.4949;AA=|||unknown(NO_COVERAGE);VT=INDEL<br></code></pre></td></tr></table></figure></li></ul><h2 id="4-tabix-bgzip"><a href="#4-tabix-bgzip" class="headerlink" title="4.tabix bgzip"></a>4.tabix bgzip</h2><ul><li><strong>tabix</strong> 可以对NGS分析中常见格式的文件建立索引，从而加快访问速度，不仅支持VCF文件，还支持BED, GFF，SAM等格式。</li></ul><p>由于SNP位点数量巨大，对应VCF文件也非常的大，为例节省存储空间，最常见的做法就是压缩。<strong>bgzip</strong>可以压缩VCF文件，用法如下</p><blockquote><p>bgzip  view.vcf</p></blockquote><p>压缩之后，原本的<strong>view.vcf</strong>文件就变成了<strong>view.vcf.gz</strong>文件。压缩后缀为.gz, 如果想要解压缩，有以下两种用法</p>  <figure class="highlight cos"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cos">bgzip -<span class="hljs-keyword">d</span> <span class="hljs-keyword">view</span>.vcf.gz<br>gunzip <span class="hljs-keyword">view</span>.vcf.gz<br>gunzip -c <span class="hljs-keyword">view</span>.vcf.gz | less<br>tabix <span class="hljs-keyword">view</span>.vcf.gz <span class="hljs-number">1</span> |less<br></code></pre></td></tr></table></figure><p><strong>bgzip</strong>的压缩算法和<strong>gzip</strong>压缩算法有着相似之处，所以对于bgzip压缩的文件，解压缩时除了可以使用bgzip软件本身，还可以使用gunzip进行解压缩。</p><ul><li>需要注意的是，两种算法虽然有相似之处，但是还是有本质区别的，在对VCF文件压缩时，不可以使用gzip来代替bgzip。</li></ul><p>对于大型的VCF文件而言，如何快速访问其中的记录也是个难点。<strong>tabix</strong>可以对VCF文件构建索引，索引构建好之后，访问速度会快很多。<strong>tabix</strong>对VCF文件建立索引的用法如下</p><blockquote><p>tabix -p vcf view.vcf.gz<br>tabix -s 1 -b 2 -e 2 vcf view.vcf.gz</p></blockquote><ul><li>注意输入的VCF文件必须是使用bgzip压缩之后的VCF文件，生成的索引文件为view.vcf.gz.tbi, 后缀为.tbi。</li></ul><p>构建好索引之后，可以快速的获取指定区域的记录，示例如下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#获取位于11号染色体的SNP位点</span><br>tabix view.vcf.gz 11<br><br><span class="hljs-comment">#获取位于11号染色体上突变位置大于或者等于2343545的SNP位点</span><br>tabix view.vcf.gz 11:2343545<br><br><span class="hljs-comment">#获取位于11号染色体上突变位置介于2343540到2343596的SNP位点</span><br>tabix view.vcf.gz 11:2343540-2343596<br><br><span class="hljs-comment">#获取位多个SNP位点</span><br>tabix view.vcf.gz 11:2343540-2343596 12:2343540-2343596<br></code></pre></td></tr></table></figure><p>很多操作VCF的软件都会识别tabix建立的索引，从而加快处理速度。很多大型项目VCF文件，也都会用bgzip压缩，然后建立tabix的索引。</p>]]></content>
    
    
    <categories>
      
      <category>生物信息学</category>
      
    </categories>
    
    
    <tags>
      
      <tag>bgzip</tag>
      
      <tag>tabix</tag>
      
      <tag>vcf</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>4.Sam/Bam文件格式详解</title>
    <link href="/2024/01/25/4.bamFormat/"/>
    <url>/2024/01/25/4.bamFormat/</url>
    
    <content type="html"><![CDATA[<h1 id="Sam-Bam文件格式详解"><a href="#Sam-Bam文件格式详解" class="headerlink" title="Sam&#x2F;Bam文件格式详解"></a>Sam&#x2F;Bam文件格式详解</h1><p>bam文件是sam文件的二进制格式，具有更小的存储空间。并且许多下游分析工具使用的是BAM格式。格式详见说明手册(<a href="https://samtools.github.io/hts-specs/SAMv1.pdf">https://samtools.github.io/hts-specs/SAMv1.pdf</a>)</p><p>bam文件格式是生物信息最常用的文件格式，是短序列比对默认的标准格式，以TAB为分割符的文本格式。一般测序下机数据的mapping结果，均以该格式进行存储。而用于序列比对的工具，如bwa、bowtie、bismark、blast都提供了bam格式的输出形式。因此可以说，对生物信息学工具的优化和开发，几乎不可避免地需要对bam处理，对于基础用户而言，可能经常用到samtools view .bam | less -SN可以查看二进制的bam文件。</p><p>bam格式包含标头部分（header section）和比对部分（alignment section）见下图</p><img src="/2024/01/25/4.bamFormat/sam_format_annotated_example.jpg" class=""><h2 id="1-Header-section"><a href="#1-Header-section" class="headerlink" title="1. Header section"></a>1. Header section</h2><ul><li>该部分全部以“@”开头，后紧跟的两个大写字母主要有HD，SQ，RG，PG和CO五类。涵盖了文件标准格式版本（VN）、比对中使用的参考序列信息（SQ）、测序数据分组信息（RG）、比对或后期处理使用的程序信息（PG）等。不仅如此，用户也可以根据后期分析需要自定义一系列自定义的信息，最为常用的就是UMI标签信息。</li><li>@HD 这一行中有各种不同的标识<ul><li>标识“VN”用以说明SAM格式版本</li><li>标识“SO”用以说明比对排序的情况，有unknown (default)、unsorted、queryname和coordinate,对于coordinate，排序的主键是Alignments section的第三列“RNAME”，其顺序由@SQ行的“SN”标识的顺序定义，次要排序键是Alignments section的第四列“POS”字段。对于RNAME和POS相等的比对，排列顺序则是任意的</li></ul></li><li>@SQ reference染色体信息，它的值主要是用于Alignments section的第三列“RNAME”和第七列“MRNM”比对的记录<ul><li>SN:Chr1则表示参考序列名称</li><li>LN:100参考序列长度</li></ul></li><li>@RG read序列信息</li><li>@PG 使用的程序说明；该行“ID”为程序记录标识符<ul><li>PN为程序名字</li><li>CL为命令行</li></ul></li><li>@CO行是任意的说明信息</li></ul><p><strong>注意事项</strong><br>header里面包含如下重要信息</p><ol><li><strong>mapping(bwa,GATK,bismark,bowtie2,…)</strong></li><li><strong>duplication(picard,samblaster,sambamba,…)</strong></li><li><strong>reference genome(hg19,hg38)</strong></li></ol><h2 id="2-Alignments-section"><a href="#2-Alignments-section" class="headerlink" title="2. Alignments section"></a>2. Alignments section</h2><p>该部分是SAM文件的核心部分，每一行代表一个序列的线性比对（linear alignment of a segment），每行包含前<strong>11</strong>个必需字段，和第12个字段后多个可选字段，使用TAB-separated分割，当某个字段信息缺省时，如果字段是字符串型以*替代，如果字段是整型以’0’来替代，下表为11个必需字段含义的概述。</p><table><thead><tr><th align="left">Col</th><th align="left">Field</th><th align="center">Type</th><th align="center">Regexp&#x2F;Range</th><th align="left">Brief description</th></tr></thead><tbody><tr><td align="left">1</td><td align="left">QNAME</td><td align="center">String</td><td align="center">[!-?A-~]{1,254}</td><td align="left">Query template NAME</td></tr><tr><td align="left">2</td><td align="left">FLAG</td><td align="center">Int</td><td align="center">[0,2^16−1]</td><td align="left">bitwise FLAG</td></tr><tr><td align="left">3</td><td align="left">RNAME</td><td align="center">String</td><td align="center">\*|[:rname:∧*&#x3D;][:rname:]*</td><td align="left">Reference sequence NAME 1-based leftmost mapping</td></tr><tr><td align="left">4</td><td align="left">POS</td><td align="center">Int</td><td align="center">[0,2^31−1]</td><td align="left">POSition</td></tr><tr><td align="left">5</td><td align="left">MAPQ</td><td align="center">Int</td><td align="center">[0,2^8−1]</td><td align="left">MAPping Quality</td></tr><tr><td align="left">6</td><td align="left">CIGAR</td><td align="center">String</td><td align="center">\*|([0-9]+[MIDNSHPX&#x3D;])+</td><td align="left">CIGAR string</td></tr><tr><td align="left">7</td><td align="left">RNEXT</td><td align="center">String</td><td align="center">\*|&#x3D;|[:rname:^*&#x3D;][:rname:]*</td><td align="left">Reference name of the mate&#x2F;next read</td></tr><tr><td align="left">8</td><td align="left">PNEXT</td><td align="center">Int</td><td align="center">[0,2^31−1]</td><td align="left">Position of the mate&#x2F;next read</td></tr><tr><td align="left">9</td><td align="left">TLEN</td><td align="center">Int</td><td align="center">[−2^31+1,2^31−1]</td><td align="left">observed Template Length</td></tr><tr><td align="left">10</td><td align="left">SEQ</td><td align="center">String</td><td align="center">\*|[A-Za-z&#x3D;.]+</td><td align="left">segment SEQuence</td></tr><tr><td align="left">11</td><td align="left">QUAL</td><td align="center">String</td><td align="center">[!-~]+</td><td align="left">ASCII of Phred-scaled base QUALity+33</td></tr></tbody></table><ul><li>1.QNAME序列的名字，也就是reads的名称</li><li>2.<strong>FLAG</strong>是一个标记的数字，描述该reads在参考基因的比对情况, 该FLAG是一串2进制代码</li><li>3.RNAME参考序列的名字</li><li>4.POS在参考序列上的位置</li><li>5.MAPQ mapping qulity越高则位点越独特，比对的质量值</li><li>6.<strong>CIGAR</strong>代表比对结果的CIGAR字符串，如37M1D2M1I，这段字符的意思是37个匹配，1个参考序列上的删除，2个匹配，1个参考序列上的插入。M代表的是alignment match(可以是错配)，可以理解为表示比对的具体情况</li><li>7.RNEXT mate序列所在参考序列的名称，mate一般指大的片段序列</li><li>8.PNEXT mate序列在参考序列上的位置</li><li>9.<strong>TLEN</strong>估计出的片段的长度，当mate序列位于本序列上游时该值为负值</li><li>10.SEQ read的序列</li><li>11.<strong>QUAL</strong>read序列对应的ASCII码格式的碱基质量值</li><li>12.可选的区域header section。值得注意的是，追加信息标签（TAG）的标准定义是一直在不断更新的，基本上每年都会有新增标签加入。</li></ul><h3 id="1-Qname"><a href="#1-Qname" class="headerlink" title="1.Qname"></a>1.Qname</h3><ul><li>比对read 的name（query template name），如果QNAME唯一，则序列被认为来源于同一模板；’*’表示该字段缺省；一般情况下，该字段为FASTQ文件的第一行信息；嵌合（Chimeric alignment）比对或者多次比对（Multiple mapping）的序列会导致一个QNAME在SAM中多次出现。</li></ul><h3 id="2-FLAG"><a href="#2-FLAG" class="headerlink" title="2.FLAG"></a>2.FLAG</h3><ul><li>每一个read的比对情况可以用十进制数字（或者十六进制数字）表示(见下表)。同时pair-end reads成对出现，如果一条read的flag是99，那边对应的另一个read就是147(见下图)。如果比对情况有多个，将多个比对情况所代表的十进制数字加和就是这一行的FLAG。</li></ul><table><thead><tr><th align="left">Value 10</th><th align="left">Value 16</th><th align="left">Description</th><th align="center">99</th><th align="center">83</th><th align="center">147</th><th align="center">163</th></tr></thead><tbody><tr><td align="left">1</td><td align="left">0x1</td><td align="left">read paired</td><td align="center">+</td><td align="center">+</td><td align="center">+</td><td align="center">+</td></tr><tr><td align="left">2</td><td align="left">0x2</td><td align="left">read mapped in proper pair</td><td align="center">+</td><td align="center">+</td><td align="center">+</td><td align="center">+</td></tr><tr><td align="left">4</td><td align="left">0x4</td><td align="left">read unmapped</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="left">8</td><td align="left">0x8</td><td align="left">mate unmapped</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="left">16</td><td align="left">0x10</td><td align="left">read reverse strand</td><td align="center"></td><td align="center">+</td><td align="center">+</td><td align="center"></td></tr><tr><td align="left">32</td><td align="left">0x20</td><td align="left">mate reverse strand</td><td align="center">+</td><td align="center"></td><td align="center"></td><td align="center">+</td></tr><tr><td align="left">64</td><td align="left">0x40</td><td align="left">first in pair</td><td align="center">+</td><td align="center">+</td><td align="center"></td><td align="center"></td></tr><tr><td align="left">128</td><td align="left">0x80</td><td align="left">second in pair</td><td align="center"></td><td align="center"></td><td align="center">+</td><td align="center">+</td></tr><tr><td align="left">256</td><td align="left">0x100</td><td align="left">not primary alignment</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="left">512</td><td align="left">0x200</td><td align="left">read fails platform&#x2F;vendor quality checks</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="left">1024</td><td align="left">0x400</td><td align="left">read is PCR or optical duplicate</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="left">2048</td><td align="left">0x800</td><td align="left">supplementary alignment</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr></tbody></table><img src="/2024/01/25/4.bamFormat/sam_flag.png" class=""><ul><li><p>图中first read的FLAG是99（1+2+32+64），则表明该read</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs applescript"><span class="hljs-number">1</span>：该<span class="hljs-built_in">read</span>是成对的paired reads中的一个<br><span class="hljs-number">2</span>：paired reads中每个都正确比对到参考序列上<br><span class="hljs-number">32</span>：与该<span class="hljs-built_in">read</span>成对的matepair <span class="hljs-built_in">read</span>其反向互补序列能够比对到参考序列<br><span class="hljs-number">64</span>：在paired reads中，该<span class="hljs-built_in">read</span>是与参考序列比对的第一条<br></code></pre></td></tr></table></figure></li><li><p>同时该reads对应的secnod read的FLAG必然是147（1+2+16+128），则表示</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs applescript"><span class="hljs-number">1</span>：该<span class="hljs-built_in">read</span>是成对的paired reads中的一个<br><span class="hljs-number">2</span>：paired reads中每个都正确比对到参考序列上<br><span class="hljs-number">16</span>：该<span class="hljs-built_in">read</span>其反向互补序列能够比对到参考序列<br><span class="hljs-number">128</span>：在paired reads中，该<span class="hljs-built_in">read</span>是与参考序列比对的第二条。（也就是说，该<span class="hljs-built_in">read</span>是read2的反向互补序列）<br></code></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql">只有一条<span class="hljs-keyword">reads</span>没有比对上：<span class="hljs-number">73</span>, <span class="hljs-number">133</span>, <span class="hljs-number">89</span>, <span class="hljs-number">121</span>, <span class="hljs-number">165</span>, <span class="hljs-number">181</span>, <span class="hljs-number">101</span>, <span class="hljs-number">117</span>, <span class="hljs-number">153</span>, <span class="hljs-number">185</span>, <span class="hljs-number">69</span>, <span class="hljs-number">137</span><br>两条<span class="hljs-keyword">reads</span>都没有比对上：<span class="hljs-number">77</span>、<span class="hljs-number">141</span><br>比对上了，方向也对，并且在插入片段大小范围内：<span class="hljs-number">99</span>, <span class="hljs-number">147</span>, <span class="hljs-number">83</span>, <span class="hljs-number">163</span><br>比对上了，也在插入片段大小范围内， 但是方向不对：<span class="hljs-number">67</span>, <span class="hljs-number">131</span>, <span class="hljs-number">115</span>, <span class="hljs-number">179</span><br>唯一配对，就是插入片段大小范围不对：<span class="hljs-number">81</span>, <span class="hljs-number">161</span>, <span class="hljs-number">97</span>, <span class="hljs-number">145</span>, <span class="hljs-number">65</span>, <span class="hljs-number">129</span>, <span class="hljs-number">113</span>, <span class="hljs-number">177</span><br></code></pre></td></tr></table></figure></li><li><p>值得注意的是，pair-end reads是指测序时生成的一对reads，分别来自同一个DNA片段的两端。假设read的名字是r001，如果read1和read2都能比对上参考序列，那么r001在SAM文件中会出现两次。如果r001的read1比对到参考序列的两个不同位置，那么r001的名字会出现三次。如果read1成功比对，而read2没有比对上，r001仍会出现两次，但其中一个r001的第三列会标记为”*”，表示未比对。因此，在pair-end测序中，read1和read2的文件同时mapping，相同reads的ID最少会出现2次。</p></li><li><p>以下网站可以通过输入FLAG值，直接找出该FLAG是那些FLAG的加和：Decoding SAM flags（<a href="https://broadinstitute.github.io/picard/explain-flags.html%EF%BC%89">https://broadinstitute.github.io/picard/explain-flags.html）</a></p></li></ul><figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs brainfuck"><span class="hljs-literal">-------------------------------------------------------------</span><br><span class="hljs-literal">---</span><span class="hljs-comment">R1</span><span class="hljs-literal">---</span>&gt; <span class="hljs-comment">99</span>                  <span class="hljs-literal">--------</span><span class="hljs-comment">R2</span><span class="hljs-literal">------</span>&gt;  <span class="hljs-comment">163</span><br><br>          &lt;<span class="hljs-literal">----</span><span class="hljs-comment">R2</span><span class="hljs-literal">----</span>  <span class="hljs-comment">147</span>            &lt;<span class="hljs-literal">--------</span><span class="hljs-comment">R1</span><span class="hljs-literal">------</span>  <span class="hljs-comment">83</span><br><span class="hljs-literal">-------------------------------------------------------------</span> <span class="hljs-comment">reverse strand</span><br></code></pre></td></tr></table></figure><h3 id="3-RNAME"><a href="#3-RNAME" class="headerlink" title="3.RNAME"></a>3.RNAME</h3><ul><li>比对上的参考序列的名字，该名字出现在Header section的@SQ行的SN标识中，如果该read没有比对上，也就是说该read在参考序列上没有坐标，那么这一列则用””表示，那么这一行的POS和CIGAR列也会是””。</li></ul><h3 id="4-POS"><a href="#4-POS" class="headerlink" title="4.POS"></a>4.POS</h3><ul><li>该read比对到参考序列RNAME的最左侧的位置坐标，最小为1（1-based leftmost）。也是CIGAR中第一个比对标识“M”对应的最左侧碱基在参考序列的位置，未比对上的read在参考序列中没有坐标，此列标识为“0”。</li></ul><h3 id="5-MAPQ"><a href="#5-MAPQ" class="headerlink" title="5.MAPQ"></a>5.MAPQ</h3><ul><li>对应参考序列的质量（MAPing Quality），比对的质量分数，越高说明该read比对到参考基因组上的位置越准确。其值等于-10log10Probility{错配概率}，得出值后四舍五入的整数就是MAPQ值。例如，MAPQ为20，即Q20，错误率为0.01，20&#x3D;-10log10(0.01) &#x3D; -10*(-2)。如果该值是255，则说明对应质量无效。</li></ul><h3 id="6-CIGAR"><a href="#6-CIGAR" class="headerlink" title="6.CIGAR"></a>6.CIGAR</h3><p>CIGAR标识符描述read与参考序列的比对具体情况信息。read中每个碱基的比对情况，主要有标识符: M表示匹配、I表示插入、D表示删除、N表示内含子和D类似、S表示替换、H表示剪切。</p><ul><li><p>M: alignment match (can be a sequence match or mismatch)<br>read上的碱基与参考序列“RNAME”完全匹配，碱基一一对应，包括了正确匹配与错误匹配</p></li><li><p>I: insertion to the reference<br>read上的碱基相对于参考序列“RNAME”有插入现象（如下）：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs objectivec">REF:  <span class="hljs-built_in">CACGATCA</span>**GACCGATACGTCCGA <br>READ1:  <span class="hljs-built_in">CGATCAGAGACCGATA</span> <br><span class="hljs-built_in">CIGAR</span>：<span class="hljs-number">6</span>M2I8M<br></code></pre></td></tr></table></figure></li><li><p>D: deletion from the reference<br>read上的碱基相对于参考序列“RNAME”有删除现象（如下）：</p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs avrasm"><span class="hljs-symbol">REF:</span> AGCTAGCATCGTGTCGCCCGTCTAGCATACGC<br><span class="hljs-symbol">READ:</span>             TCGCCCGT-TAGCAT<br>CIGAR：<span class="hljs-number">8</span>M1D6M<br></code></pre></td></tr></table></figure></li><li><p>N: skipped region from the reference<br>read上的碱基相对于参考序列“RNAME”存在连续没有比对上的空缺，这些空缺用N来表示，跟“D”相似但远比“D”缺失的更多，这种比对类型也叫“Spliced alignment”，常见cDNA与参考序列比对（如下）:”…”表示intron</p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs lasso">REF:AGCATCGTGTCGCCCGTCTAGCATACGCATGATCGACTGTCAGCTAGTCAGACTA<br>READ:     GTGTAACCC<span class="hljs-params">...</span><span class="hljs-params">...</span><span class="hljs-params">...</span><span class="hljs-params">...</span><span class="hljs-params">...</span><span class="hljs-params">...</span><span class="hljs-params">...</span><span class="hljs-params">...</span><span class="hljs-params">...</span><span class="hljs-params">...</span>..TCAGAATA<br>CIGAR：<span class="hljs-number">9</span>M32N8M<br></code></pre></td></tr></table></figure></li><li><p>S: soft clipping (clipped sequences present in SEQ)</p></li><li><p>H: hard clipping (clipped sequences NOT present in SEQ)<br>read的开头或者结尾部分没有比对到参考序列”RNAME”上，但这部分未比对上的连续序列仍保留在sam文件的该read序列中，用“S”来表示；如果未保留，则用“H”表示，也即“hard cliping”（如下所示，也可同图2中r003的比对CIGAR中看出）</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs gcode">REF: AGCTAGCATCGTGTCGCCCGTCTAGCATACGCAT<br>READ:          gggTCGCCCGT-TAGCATgggg<br>CIGAR：<span class="hljs-number">3</span>S<span class="hljs-number">8</span><span class="hljs-name">M1</span>D<span class="hljs-number">6</span><span class="hljs-name">M4</span>S （在sam中存储为GGGGTGTAACCGACTAGGGGG）<br>CIGAR：<span class="hljs-number">3</span>H<span class="hljs-number">8</span><span class="hljs-name">M1</span>D<span class="hljs-number">6</span><span class="hljs-name">M4</span>H （在sam中存储为GTGTAACCGACTAG）<br></code></pre></td></tr></table></figure></li><li><p>P: padding (silent deletion from padded reference)<br>多条read比对到参考序列的同一位置时，如果不同read单独同该参考序列比对时，参考序列的情况也不同，比如下方READ1同参考序列比对时，“GA”属于插入（6M2I8M），READ2同参考序列比对时，“A”属于插入（4M1I9M ），READ3同参考序列完全匹配（10M），没有插入，但是三条read之前却没有可比性。因此，当参考序列“比对情况包含完整”且序列唯一时，所有read同时进行比对，read3这种原本没有插入却默认插入的比对称之为Padded alignment，这种情况用“P”表示。</p><figure class="highlight nestedtext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs nestedtext"><span class="hljs-attribute">REF</span><span class="hljs-punctuation">:</span> <span class="hljs-string"> CACGATCA**GACCGATACGTCCGA</span><br><span class="hljs-attribute">READ1</span><span class="hljs-punctuation">:</span> <span class="hljs-string"> CGATCAGAGACCGATA </span><br><span class="hljs-attribute">READ2</span><span class="hljs-punctuation">:</span> <span class="hljs-string">   ATCA*AGACCGATAC </span><br><span class="hljs-attribute">READ3</span><span class="hljs-punctuation">:</span> <span class="hljs-string">  GATCA**GACCG  </span><br><span class="hljs-attribute">The padded CIGAR are different</span><span class="hljs-punctuation">: </span><br><span class="hljs-attribute">READ1</span><span class="hljs-punctuation">:</span> <span class="hljs-string">6M2I8M </span><br><span class="hljs-attribute">READ2</span><span class="hljs-punctuation">:</span> <span class="hljs-string">4M1P1I9M  </span><br><span class="hljs-attribute">READ3</span><span class="hljs-punctuation">:</span> <span class="hljs-string">5M2P5M</span><br></code></pre></td></tr></table></figure></li><li><p>&#x3D;：sequence match 正确匹配</p></li><li><p>X：sequence mismatch 错误匹配</p></li></ul><blockquote><p>perl CIGAR代码 为了检测每个read的甲基化情况</p></blockquote>  <figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">my</span> @f=<span class="hljs-keyword">split</span>(<span class="hljs-regexp">/\s+/</span>,$line);<br><br><span class="hljs-keyword">my</span> $flag = $f[<span class="hljs-number">1</span>];<br><span class="hljs-keyword">my</span> $chr = $f[<span class="hljs-number">2</span>];<br><span class="hljs-keyword">my</span> $pos = $f[<span class="hljs-number">3</span>];<br><span class="hljs-keyword">my</span> $cigar_2 = $f[<span class="hljs-number">5</span>];<br><br><span class="hljs-comment"># parsing CIGAR string</span><br><span class="hljs-keyword">my</span> @len = <span class="hljs-keyword">split</span> (<span class="hljs-regexp">/\D+/</span>,$cigar_2); <span class="hljs-comment"># storing the length per operation</span><br><span class="hljs-keyword">my</span> @ops = <span class="hljs-keyword">split</span> (<span class="hljs-regexp">/\d+/</span>,$cigar_2); <span class="hljs-comment"># storing the operation</span><br><span class="hljs-keyword">shift</span> @ops; <span class="hljs-comment"># remove the empty first element</span><br><span class="hljs-keyword">die</span> <span class="hljs-string">&quot;CIGAR string contained a non-matching number of lengths and operations ($cigar_2)\n&quot;</span> <span class="hljs-keyword">unless</span> (<span class="hljs-keyword">scalar</span> @len == <span class="hljs-keyword">scalar</span> @ops);<br><br><span class="hljs-comment">### determining end position of the read</span><br><span class="hljs-keyword">my</span> $readPos = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">my</span> $genomePos = $pos;<br><br><span class="hljs-keyword">foreach</span> <span class="hljs-keyword">my</span> $index(<span class="hljs-number">0</span>..$#len)&#123;<br><br><span class="hljs-keyword">my</span> $lengthSeg = $len[$index];<br><br><span class="hljs-keyword">if</span> ($ops[$index] eq <span class="hljs-string">&#x27;M&#x27;</span>)&#123;  <span class="hljs-comment"># standard matching bases</span><br><br>$readPos += $lengthSeg;<br>$genomePos += $lengthSeg;<br>  <br>&#125;<br><span class="hljs-keyword">elsif</span>($ops[$index] eq <span class="hljs-string">&#x27;I&#x27;</span>)&#123; <span class="hljs-comment"># insertions do not affect the end position</span><br>  <br>$readPos += $lengthSeg;<br><br>&#125;<br><span class="hljs-keyword">elsif</span>($ops[$index] eq <span class="hljs-string">&#x27;D&#x27;</span>)&#123; <span class="hljs-comment"># deletions do affect the end position</span><br>  $genomePos += $lengthSeg;<br><br>&#125;<span class="hljs-keyword">elsif</span>($ops[$index] eq <span class="hljs-string">&#x27;S&#x27;</span>)&#123; <span class="hljs-comment"># deletions do affect the end position</span><br>    $readPos += $lengthSeg;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="7-RNEXT"><a href="#7-RNEXT" class="headerlink" title="7.RNEXT"></a>7.RNEXT</h3><ul><li>该read的mate read比对上的参考序列的名字，该名字出现在Header section的@SQ行的SN标识中，</li><li>如果和该read所在行的第三列“RNAME”一样，则用“&#x3D;”表示，说明这对read比对到了同一条参考序列上；</li><li>如果mate read没有比对上，第七列则用“*”表示；</li><li>如果这对read没有比对到同一条参考序列，那么这一列则是mate read所在行第三列的“RNAME”。</li></ul><h3 id="8-PNEXT"><a href="#8-PNEXT" class="headerlink" title="8.PNEXT"></a>8.PNEXT</h3><ul><li>该read的mate read比对到的参考序列“RNAME”<strong>最左侧</strong>的位置坐标，也是mate read CIGAR中第一个比对标识“M”对应的最左侧碱基在参考序列的位置，未比对上的read在参考序列中没有坐标，此列标识为“0”。</li></ul><h3 id="9-ISIZE"><a href="#9-ISIZE" class="headerlink" title="9.ISIZE"></a>9.ISIZE</h3><ul><li><p>表示pair read完全匹配到同一条参考序列时，两个read之间的长度，可简单理解为测序文库的长度。这个定义有两种情况（虚线表示未比对上的序列，即soft-clipped bases）：</p></li><li><p>第一种情况如图左所示，Read1和Read2比对到同一条参考序列，此时ISIZE即为Read2的最右侧比对坐标减去Read1最左侧比对坐标；</p></li><li><p>第二种情况如图右所示，由于至今没有明确的定义和共识，因此ISIZE可以是TLEN#1，也可以是TLEN#2，视情况而定。</p></li></ul><figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs brainfuck">                                            <span class="hljs-comment">|</span>&lt;<span class="hljs-literal">--</span><span class="hljs-comment">TLEN#1</span><span class="hljs-literal">----</span>&gt;<span class="hljs-comment">|</span><br><span class="hljs-literal">-------------------------------</span>   <span class="hljs-literal">-----------------------------------</span><br><span class="hljs-comment">|</span><span class="hljs-literal">---</span><span class="hljs-comment">R1</span><span class="hljs-literal">---</span>&gt; <span class="hljs-comment">99                               |</span><span class="hljs-literal">---</span><span class="hljs-comment">R1</span><span class="hljs-literal">-----------------</span>&gt; <span class="hljs-comment">99</span> <br><br>                &lt;<span class="hljs-literal">----</span><span class="hljs-comment">R2</span><span class="hljs-literal">----</span><span class="hljs-comment">| 147</span>     &lt;<span class="hljs-literal">----------</span><span class="hljs-comment">R2</span><span class="hljs-literal">---------</span><span class="hljs-comment">|  147</span><br><span class="hljs-literal">-------------------------------</span>   <span class="hljs-literal">------------------------------------</span><br><span class="hljs-comment">|</span>&lt;<span class="hljs-literal">-------</span><span class="hljs-comment">TLEN #1/#2</span><span class="hljs-literal">-------</span>&gt;<span class="hljs-comment">|         |</span>&lt;<span class="hljs-literal">-------</span><span class="hljs-comment">TLEN #2</span><span class="hljs-literal">--------------</span>&gt;<span class="hljs-comment">|</span><br></code></pre></td></tr></table></figure><h3 id="10-SEQ"><a href="#10-SEQ" class="headerlink" title="10.SEQ"></a>10.SEQ</h3><ul><li>存储的序列，没有存储，此列则用“*”标识。该序列的长度<strong>一定等于</strong>CIGAR标识中“M”，“I”，“S”，“&#x3D;”，“X”标识的碱基长度之和。</li></ul><h3 id="11-QUAL"><a href="#11-QUAL" class="headerlink" title="11.QUAL"></a>11.QUAL</h3><ul><li><p>Base quality score:序列的每个碱基对应一个碱基质量字符，每个碱基质量字符对应的ASCII码值减去33（Sanger Phred-33 质量值体系），即为该碱基的测序质量得分（Phred Quality Score）。不同Phred Quality Score代表不同的碱基测序错误率，如Phred Quality Score值为20和30分别表示碱基测序错误率为1%和0.1%。（ASCII码从0-127，为什么很多Phred评分从33开始呢？因为33是第一个肉眼可见的字符!，在此之前的都是控制符，比如空格、制表等，不方便用这些控制符来表示一个碱基的质量。）</p></li><li><p>假设一个碱基测序错误的概率是P，那么此时对应的Phred quality score（常用Q表示）</p><blockquote><p>$Q &#x3D; -10log_{10}(P)$</p></blockquote></li><li><p>假设100个碱基中有1个出现错误，即P&#x3D;0.01，根据上式可以计算，此时Q&#x3D;20；同理，当测序错误率为0.001时，此时Q&#x3D;30。<br>测序结果中的每一个碱基都有这么一个Phred评分。为了便于描述，人们习惯上将Phred评分对应一个ASCII码，这样每一个碱基的质量都可以用一个字符来表述了。</p></li></ul><table><thead><tr><th align="left">P</th><th align="center">Q (Phred quality score)</th><th align="center">Sanger Phred</th><th align="left">ASCII</th></tr></thead><tbody><tr><td align="left">0.01</td><td align="center">20</td><td align="center">53</td><td align="left"><strong>5</strong></td></tr><tr><td align="left">0.001</td><td align="center">30</td><td align="center">63</td><td align="left"><strong>?</strong></td></tr><tr><td align="left">0.0001</td><td align="center">40</td><td align="center">73</td><td align="left"><strong>I</strong></td></tr><tr><td align="left">0.00001</td><td align="center">50</td><td align="center">83</td><td align="left"><strong>S</strong></td></tr></tbody></table><h3 id="12-可选的区域"><a href="#12-可选的区域" class="headerlink" title="12.可选的区域"></a>12.可选的区域</h3><ul><li>格式类似AS:i:-1 XN:i:0 XM:i:1 XO:i:0 XG:i:0 NM:i:1 MD:Z:35T0 YT:Z:UU<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs stylus">AS:<span class="hljs-selector-tag">i</span>  匹配的得分<br>XS:<span class="hljs-selector-tag">i</span>  第二好的匹配的得分<br>YS:<span class="hljs-selector-tag">i</span>  mate 序列匹配的得分<br>XN:<span class="hljs-selector-tag">i</span>  在参考序列上模糊碱基的个数<br>XM:<span class="hljs-selector-tag">i</span>  错配的个数<br>XO:<span class="hljs-selector-tag">i</span>  <span class="hljs-attribute">gap</span> open的个数<br>XG:<span class="hljs-selector-tag">i</span>  <span class="hljs-attribute">gap</span> 延伸的个数<br>NM:<span class="hljs-selector-tag">i</span>  经过编辑的序列<br>YF:<span class="hljs-selector-tag">i</span>  说明为什么这个序列被过滤的字符串<br>YT:Z 值为UU表示不是pair中一部分(单末端？)、<span class="hljs-built_in">CP</span>(是pair且可以完美匹配)、<span class="hljs-built_in">DP</span>(是pair但不能很好的匹配)、<span class="hljs-built_in">UP</span>(是pair但是无法比对到参考序列上)<br>MD:Z  代表序列和参考序列错配的字符串<br></code></pre></td></tr></table></figure></li></ul><h2 id="3-samtools-软件使用"><a href="#3-samtools-软件使用" class="headerlink" title="3. samtools 软件使用"></a>3. samtools 软件使用</h2><h3 id="常用比对软件"><a href="#常用比对软件" class="headerlink" title="常用比对软件"></a>常用比对软件</h3><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-comment">#使用BWA进行比对</span><br><span class="hljs-attribute">bwa</span> mem -M ref.fa r1.fq.gz r2.fq.gz -t <span class="hljs-number">4</span> | samtools view -Sb - | samtools sort -o sorted_reads.bam<br><br><span class="hljs-comment">#使用Bowtie2进行比对</span><br><span class="hljs-attribute">bowtie2</span> -x genome -<span class="hljs-number">1</span> read1.fq.gz -<span class="hljs-number">2</span> read2.fq.gz -p <span class="hljs-number">4</span> | samtools view -Sb - | samtools sort -o sorted_reads.bam<br></code></pre></td></tr></table></figure><h3 id="sort：sort-alignment-file"><a href="#sort：sort-alignment-file" class="headerlink" title="sort：sort alignment file"></a>sort：sort alignment file</h3><ul><li>本命令对bam文件中的序列进行排序，默认下是按序列在fasta文件中的顺序（即header）和序列从左往右的位点排序。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">samtools <span class="hljs-built_in">sort</span> [-T out.prefix][-@ threads][-m maxMem][-o out.sorted.bam][in.bam]<br>samtools <span class="hljs-built_in">sort</span> -@ 10 -o abc.sorted.bam abc.bam<br>samtools <span class="hljs-built_in">sort</span> -m 500000000 -o abc.sorted.bam abc.bam <span class="hljs-comment"># 500M dang abc.bam文件比较大，split的文件比较多，比如200多个。</span><br></code></pre></td></tr></table></figure><h3 id="merge：-merge-sorted-alignments"><a href="#merge：-merge-sorted-alignments" class="headerlink" title="merge： merge sorted alignments"></a>merge： merge sorted alignments</h3><ul><li><p>本命令将多个排好序的bam比对文件进行合并，产生一个排好序的bam输出文件(合并后的文件不需要再进行sort)，这个文件含有所有的输入记录，并且保留了他们原来的顺序。</p><blockquote><p>samtools merge [out.bam][in1.bam][in2.bam][in3.bam]</p></blockquote></li></ul><h3 id="index：index-alignment"><a href="#index：index-alignment" class="headerlink" title="index：index alignment"></a>index：index alignment</h3><ul><li><p>本命令对bam文件建立索引并产生后缀为.bai的文件，用于快速的随机处理。很多后续分析的过程需要有bai文件的存在，特别是显示序列比对情况下，比如samtool的tview命令等。#必须对bam文件进行默认情况下的排序后，才能进行index。否则会报错</p><blockquote><p>samtools index aln.sorted.bam</p></blockquote></li></ul><h3 id="view：SAMBAMCRAM-conversion"><a href="#view：SAMBAMCRAM-conversion" class="headerlink" title="view：SAM&lt;-&gt;BAM&lt;-&gt;CRAM conversion"></a>view：SAM&lt;-&gt;BAM&lt;-&gt;CRAM conversion</h3><ul><li>本命令将sam文件转换成bam文件；然后对bam文件进行各种操作，比如数据的排序和提取(这些操作是对bam文件进行的，不能对sam文件进行该操作)；最后将排序或提取得到的数据输出为bam或sam格式。bam文件优点：bam文件为二进制文件，占用的磁盘空间比sam文本文件小；利用bam二进制文件的运算速度快。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">samtools view -b abc.sam &gt; abc.bam<br>samtools view -b abc.sam -o abc.bam<br>samtools view abc.bam chr1 |less<br>samtools view abc.bam chr1:1000000-2000000 |less<br></code></pre></td></tr></table></figure><h3 id="tview"><a href="#tview" class="headerlink" title="tview"></a>tview</h3><ul><li>直观显示reads比对到基因组的情况，与IGV类似需要先sort和index</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">samtools tview abc.sorted.bam hg19.fasta<br></code></pre></td></tr></table></figure><ul><li>press <strong>g</strong> to check the alignment start from a region in the format like chr10:10,000,000 or &#x3D;10,000,000 when viewing the same reference sequence.</li><li>c, C, n …</li></ul><h3 id="depth"><a href="#depth" class="headerlink" title="depth"></a>depth</h3><ul><li>统计每个碱基位点的测序深度;需要使用重定向定义输出文件；要使用构建过索引的bam Usage: bam2depth [-r reg] [-q baseQthres] [-Q mapQthres] [-b in.bed] […] -r：（region）加染色体号； -q：要求测序碱基质量最低值； -Q：要求比对的质量最低值<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">samtools depth abc.sorted.bam &gt;abc.depth<br></code></pre></td></tr></table></figure></li></ul><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li>Li H, Handsaker B, Wysoker A, et al. The Sequence Alignment&#x2F;Map format and SAMtools[J]. Bioinformatics, 2009, 25(16): 2078-2079.</li><li><a href="https://samtools.github.io/hts-specs/SAMv1.pdf">https://samtools.github.io/hts-specs/SAMv1.pdf</a></li><li><a href="https://www.samformat.info/sam-format-flag">https://www.samformat.info/sam-format-flag</a></li><li><a href="https://broadinstitute.github.io/picard/explain-flags.html">https://broadinstitute.github.io/picard/explain-flags.html</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>生物信息学</category>
      
    </categories>
    
    
    <tags>
      
      <tag>samtools</tag>
      
      <tag>bam</tag>
      
      <tag>sam</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>3.Fastq/Fasta文件格式详解</title>
    <link href="/2024/01/24/3.fastqFormat/"/>
    <url>/2024/01/24/3.fastqFormat/</url>
    
    <content type="html"><![CDATA[<p>在生物信息学中，基础数据文件通常采用平面文件格式，即由ASCII码编码的文本文件。这种文件格式易于编辑和解析，但占用的存储空间很大。例如，一个原始的FASTQ文件在压缩前后的存储空间对比显示，未压缩数据大约是压缩后数据的<strong>十倍</strong>。尽管压缩可以节省存储空间，但需要注意的是，在某些数据处理过程中，文件需要解压，这会消耗额外的计算资源。例如，通过JellyFish进行k-mer统计时，需要先解压FASTQ文件。这类程序通常依赖于zcat或gunzip等工具来解压文件，以确保正常运行。</p><p>文件压缩不仅是存储优化的手段，也是生物信息学操作的必要步骤。例如，对于变异检测结果的VCF文件，基于基因组位置的查询是基本操作。大多数程序使用<strong>htslib</strong>套装中的<strong>tabix</strong>进行索引操作，从而加快查询速度。htslib是测序相关生物信息学领域中应用最广泛的工具之一。</p><p><strong>在此膜拜李恒大神!!</strong></p><h1 id="FASTQ文件格式"><a href="#FASTQ文件格式" class="headerlink" title="FASTQ文件格式"></a>FASTQ文件格式</h1><p>FASTQ是产生自测序仪的原始测序数据，它由测序的图像数据转换过来，也是文本文件，文件大小依照不同的测序量（或测序深度）而有很大差异，小的可能只有几M，大的则常常有几十G上百G，文件后缀通常都是.fastq，.fq或者.fq.gz（gz压缩）。</p><h2 id="FASTQ文件命名规则"><a href="#FASTQ文件命名规则" class="headerlink" title="FASTQ文件命名规则"></a>FASTQ文件命名规则</h2><p>Illumina测序仪下机FASTQ命名为（NextSeq CN500下机数据为bcl格式，经过bcl2fastq转化后名称类似），例如：</p><p>Samplexx_S53_L002_R1_001.fastq.gz</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">Samplexx 样本名，与上机时在sampleSheet中填写的一致； <br>S53   S后跟的数字与样本在sampleSheet中的顺序一致，从1开始； <br>L002  L00*，lane编号； <br>R1    R*，R1表示read1，R2表示read2。R1和R2为paired end reads。同一个样本的配对的FASTQ，只有这个地方不同； <br>001   001，通常为001；<br>Undetermined_S0_L001_R1_001.fastq.gz  存储index不匹配的reads，由于根据index没有拆分出reads的文件。<br></code></pre></td></tr></table></figure><h2 id="FASTQ格式"><a href="#FASTQ格式" class="headerlink" title="FASTQ格式"></a>FASTQ格式</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">@SIM:1:FCX:1:15:6329:1045:GATTACT+GTCTTAAC 1:N:0:ATCCGA<br>TTGCAAAAAATTTCTCTCATTCTGTAGGTTGCCTGTTCACTCTGATGATAGTTTGTTTTGG<br>+<br>FFKKKFKKFKF&lt;KK&lt;F,AFKKKKK7FFK77&lt;FKK,&lt;F7K,,7AF&lt;FF7FKK7AA,7&lt;FA,,<br></code></pre></td></tr></table></figure><p>fastq有着自己独特的格式：每四行成为一个独立的单元，我们称之为read。具体的格式描述如下：</p><h3 id="第一行，Sequence-identifier"><a href="#第一行，Sequence-identifier" class="headerlink" title="第一行，Sequence identifier"></a>第一行，Sequence identifier</h3><p>以‘@’开头，是这一条read的名字，这个字符串是根据测序时的状态信息转换过来的，它是 每一条read的唯一标识符，同一份FASTQ文件中不会重复出现，甚至不同的FASTQ文件里也不会有重复；</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs bash">@SIM:1:FCX:1:15:6329:1045:GATTACT+GTCTTAAC 1:N:0:ATCCGA<br><span class="hljs-comment">#官网给的格式解释如下：</span><br>@&lt;instrument&gt;:&lt;run number&gt;:&lt;flowcell ID&gt;:&lt;lane&gt;:&lt;tile&gt;:&lt;x-pos&gt;:&lt;y-pos&gt;:&lt;UMI&gt; &lt;<span class="hljs-built_in">read</span>&gt;:&lt;is filtered&gt;:&lt;control number&gt;:&lt;index&gt;<br><br>@开始的标记符号<br>@SIM:1:FCX测序仪唯一的设备名称<br>1lane的编号<br>15<span class="hljs-built_in">tail</span>的坐标<br>6329在<span class="hljs-built_in">tail</span>中的X坐标<br>1045在<span class="hljs-built_in">tail</span>中的Y坐标<br>GATTACT+GTCTTAAC  1，当sampleSheet存在UMI(Unique Molecular indentifier，用于提高测序的准确性)时该项存在；为Read1的UMI序列+Read2的UMI序列信息，下图为文库中UMI的位置<br>1     1表示single <span class="hljs-built_in">read</span>；2表示paired end<br>N     是否过滤，Y表示被过滤，否则为N<br>0     0表示十进制？否则是一个偶数<br>ATCCGA  index序列<br></code></pre></td></tr></table></figure><img src="/2024/01/24/3.fastqFormat/umi.webp" class=""><h3 id="第二行：Sequence"><a href="#第二行：Sequence" class="headerlink" title="第二行：Sequence"></a>第二行：Sequence</h3><p>测序read的序列，由A，C，G，T和N这五种字母构成，这也是我们真正关心的DNA序列，N代表的是测序时那些无法被识别出来的碱基；</p><h3 id="第三行：Quality-score-identifier-line-consisting-only-of-a"><a href="#第三行：Quality-score-identifier-line-consisting-only-of-a" class="headerlink" title="第三行：Quality score identifier line (consisting only of a +)"></a>第三行：Quality score identifier line (consisting only of a +)</h3><p>以‘+’开头，在旧版的FASTQ文件中会直接重复第一行的信息，但现在一般什么也不加（节省存储空间）；</p><h3 id="第四行：Quality-score，测序质量值"><a href="#第四行：Quality-score，测序质量值" class="headerlink" title="第四行：Quality score，测序质量值"></a>第四行：Quality score，测序质量值</h3><p>测序read的质量值，这个和第二行的碱基信息一样重要，它描述的是每个测序碱基的可靠程度，用ASCII码表示。我们平时长听到的Q20，Q30即为该字符对应的值</p><h3 id="质量值"><a href="#质量值" class="headerlink" title="质量值"></a>质量值</h3><p><strong>重点说一下什么是质量值</strong></p><blockquote><p>Q &#x3D; -10log(p_error)</p></blockquote><ul><li>质量值是测序错误率的对数（10为底数）乘以-10（并取整）。这个公式也是目前测序质量值的计算公式，它非常简单，p_error的值和测序时的多个因素有关，体现为测序图像数据点的清晰程度，并由测序过程中的base calling算法计算出来；</li><li>公式右边的Q我们称之为Phred quality score，就是用它来描述测序碱基的靠谱程度。比如，如果该碱基的测序错误率是0.01，那么质量值就是20（俗称Q20），如果是0.001，那么质量值就是30（俗称Q30）。Q20和Q30的比例常常被我们用来评价某次测序结果的好坏，比例越高就越好。下面我也详细给出一个表，更进一步地解释质量值高低的含义：<table><thead><tr><th>Phred Quality Score</th><th>Probability of incorrect base call</th><th>Base call accuracy</th></tr></thead><tbody><tr><td>10</td><td>1 in 10</td><td>90%</td></tr><tr><td>20</td><td>1 in 100</td><td>99%</td></tr><tr><td>30</td><td>1 in 1000</td><td>99.9%</td></tr><tr><td>40</td><td>1 in 10,000</td><td>99.99%</td></tr><tr><td>50</td><td>1 in 100,000</td><td>99.999%</td></tr><tr><td>60</td><td>1 in 1,000,000</td><td>99.9999%</td></tr></tbody></table></li></ul><h3 id="Phred质量评分与ASCII字符的关系"><a href="#Phred质量评分与ASCII字符的关系" class="headerlink" title="Phred质量评分与ASCII字符的关系"></a>Phred质量评分与ASCII字符的关系</h3><p>用ASCII码来代表Phred质量评分，ASCII码虽然能够从小到大表示0-127的整数，但是并非所有的ASCII码都是<strong>可见的字符</strong>，比如所有小于33的ASCII码值所表示的都是不可见字符，比如空格，换行符等，因此<strong>为了能够让碱基的质量值表达出来，必须避开所有这些不可见字符</strong>。最简单的做法就是加上一个固定的整数！<br>但一开始对于要加哪一个整数，并没有什么指导标准，这就导致了在刚开始的时候，不同的测序平台加的整数也不同，总的来说有以下3种质量体系，演变到现在也基本只剩下第一种了，如下表：</p><table><thead><tr><th>测序平台</th><th>ASCII码范围</th><th>下限</th><th>质量值类型</th><th>质量值范围</th><th>备注</th></tr></thead><tbody><tr><td>Sanger, Illumina(版本1.8及以上)</td><td>33-126</td><td>33</td><td>Phred quality score</td><td>0-93</td><td>现在沿用</td></tr><tr><td>Solexa, Illumina早期版本(&lt;1.3版本)</td><td>59-126</td><td>64</td><td>Solexa quality score</td><td>5-62</td><td>除了已测序数据之外，不再使用</td></tr><tr><td>Illumina(版本1.3-1.7)</td><td>64-126</td><td>64</td><td>Phred quality score</td><td>0-62</td><td>除了已测序数据之外，不再使用</td></tr></tbody></table><p>从表中可以看到下限有33和64两个值，我们把加33的的质量值体系称之为Phred33，加64的称之为Phred64（Solexa的除外，它叫Solexa64）。不过，现在一般都是使用Phred33这个体系，而且33也恰好是ASCII的第一个可见字符（’!’），完美+2。</p><img src="/2024/01/24/3.fastqFormat/ASCII.png" class=""><h1 id="FASTA文件格式"><a href="#FASTA文件格式" class="headerlink" title="FASTA文件格式"></a>FASTA文件格式</h1><p>这个格式比较简单，主要由两行组成，序列的描述信息和序列数据。头信息独占一行，以大于号（&gt;）开头作为识别标记</p><p>例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">&gt;ENSMUSG00000020122|ENSMUST00000138518 <br>CCCTCCTATCATGCTGTCAGTGTATCTCTAAATAGCACTCTCAACCCCCGTGAACTTGGT <br>TATTAAAAACATGCCCAAAGTCTGGGAGCCAGGGCTGCAGGGAAATACCACAGCCTCAGT <br>TCATCAAAACAGTTCATTGCCCAAAATGTTCTCAGCTGCAGCTTTCATGAGGTAACTCCA <br>GGGCCCACCTGTTCTCTGGT<br></code></pre></td></tr></table></figure><h2 id="第一行：序列描述信息"><a href="#第一行：序列描述信息" class="headerlink" title="第一行：序列描述信息"></a>第一行：序列描述信息</h2><p>以&lt;开头，格式没有严格要求。用一个空格把头信息分为两个部分：第一部分是序列名字，它和大于号（&gt;）紧接在一起；第二部分是注释信息，这个可以没有，看具体需要。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">&gt;ENSMUSG00000020122|ENSMUST00000138518<br></code></pre></td></tr></table></figure><p>相同的序列被不同的人处理之后、甚至是在不同的网站上或者数据库中它们的头信息都不尽相同，比如以下的几种情况都是可能存在的。在业内也慢慢地有一些不成文的规则被大家所使用，那就是，用一个空格把头信息分为两个部分：第一部分是序列名字，它和大于号（&gt;）紧接在一起；第二部分是注释信息，这个可以没有，就看具体需要。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">&gt;ENSMUSG00000020122|ENSMUST00000125984<br>&gt;ENSMUSG00000020122|ENSMUST00000125984<br>&gt;ENSMUSG00000020122|ENSMUST00000125984|epidermal growth <span class="hljs-built_in">factor</span> receptor<br>&gt;ENSMUSG00000020122|ENSMUST00000125984|Egfr<br>&gt;ENSMUSG00000020122|ENSMUST00000125984|11|ENSFM00410000138465<br></code></pre></td></tr></table></figure><h2 id="第二行：序列数据"><a href="#第二行：序列数据" class="headerlink" title="第二行：序列数据"></a>第二行：序列数据</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">CCCTCCTATCATGCTGTCAGTGTATCTCTAAATAGCACTCTCAACCCCCGTGAACTTGGT <br>TATTAAAAACATGCCCAAAGTCTGGGAGCCAGGGCTGCAGGGAAATACCACAGCCTCAGT <br>TCATCAAAACAGTTCATTGCCCAAAATGTTCTCAGCTGCAGCTTTCATGAGGTAACTCCA <br>GGGCCCACCTGTTCTCTGGT<br></code></pre></td></tr></table></figure><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><a href="https://www.plob.org/article/11672.html">https://www.plob.org/article/11672.html</a></li><li><a href="https://zhuanlan.zhihu.com/p/158694643">https://zhuanlan.zhihu.com/p/158694643</a></li><li><a href="http://www.xtaohub.com/BI-solutions/Bioinformatics-files-formats.html">http://www.xtaohub.com/BI-solutions/Bioinformatics-files-formats.html</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>生物信息学</category>
      
    </categories>
    
    
    <tags>
      
      <tag>fastq</tag>
      
      <tag>fasta</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2.常见生信软件安装</title>
    <link href="/2024/01/23/2.BioinfoSoftwareInstall/"/>
    <url>/2024/01/23/2.BioinfoSoftwareInstall/</url>
    
    <content type="html"><![CDATA[<h1 id="常见生信软件安装"><a href="#常见生信软件安装" class="headerlink" title="常见生信软件安装"></a>常见生信软件安装</h1><ul><li>为了有效地组织和管理软件安装目录，简化可执行文件的调用路径，并保持系统目录的整洁和安全，可以按照以下步骤执行命令：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 1. 将所有安装软件放在 ~/software 下面</span><br><span class="hljs-comment"># 这一步假设你已经将软件解压或安装到了 ~/software 下的子目录中</span><br><br><span class="hljs-comment"># 2. 建立文件夹，用于存放所有可执行文件的软连接</span><br><span class="hljs-built_in">mkdir</span> -p ~/software/bin<br><br><span class="hljs-comment"># 3. 编辑 ~/.bashrc 文件，添加以下内容以更新环境变量</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;export PATH=&quot;~/software/bin:$PATH&quot;&#x27;</span> &gt;&gt; ~/.bashrc<br><br><span class="hljs-comment"># 4. 保存文件后，使修改立即生效</span><br><span class="hljs-built_in">source</span> ~/.bashrc<br><br><span class="hljs-comment"># 5. 创建软连接（示例，假设 liftOver 在 ~/software/liftOver 下）</span><br><span class="hljs-built_in">ln</span> -s ~/software/liftOver/liftOver ~/software/bin/liftOver<br></code></pre></td></tr></table></figure></li></ul><h2 id="1-手动安装"><a href="#1-手动安装" class="headerlink" title="1.手动安装"></a>1.手动安装</h2><ul><li>bwa, samtools, bgzip, tabix, bcftools</li></ul><h3 id="BWA"><a href="#BWA" class="headerlink" title="BWA"></a>BWA</h3><ul><li>说明:BWA是用于将DNA与大型参考基因组（例如人类基因组）进行比对的开源软件。</li><li>版本 0.7.17</li><li>下载安装<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> ~/software<br><span class="hljs-built_in">mkdir</span> bwa &amp;&amp; <span class="hljs-built_in">cd</span> bwa<br><br><span class="hljs-comment"># 从官方网站下载</span><br>wget https://sourceforge.net/projects/bio-bwa/files/bwa-0.7.17.tar.bz2<br>tar -jxvf bwa-0.7.17.tar.bz2<br><span class="hljs-built_in">cd</span> bwa-0.7.17<br>make<br><br><span class="hljs-built_in">ln</span> -s `<span class="hljs-built_in">pwd</span>`/bwa ~/software/bin/bwa<br></code></pre></td></tr></table></figure></li><li>使用<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 建立参考基因组索引</span><br>bwa index ref.fa  <br><br><span class="hljs-comment"># single end</span><br>bwa mem ref.fa reads.fq.gz &gt; mem-se.sam<br><br><span class="hljs-comment"># paired end</span><br>bwa mem ref.fa r1.fq.gz r2.fq.gz &gt; mem-pe.sam<br><br><span class="hljs-comment">#使用 BWA 进行比对，并通过管道传递给 Samtools 进行转换和排序</span><br>bwa mem ref.fa r1.fq.gz r2.fq.gz | samtools view -Sb - | samtools <span class="hljs-built_in">sort</span> -o sorted_reads.bam<br>bwa mem -t 4 -M -R <span class="hljs-string">&quot;\@RG\tID:&#123;library&#125;\tLB:&#123;library&#125;\tPL:Illumina\tPU:&#123;sample&#125;\tSM:&#123;sample&#125;\tDT:&#123;time&#125;\&quot; ref.fa read1.fq.gz read2.fq.gz | samtools view -Sb - | samtools sort -o sorted_reads.bam</span><br><span class="hljs-string">bwa mem -t 4 -M -R &quot;</span>\@RG\tID:&#123;library&#125;\tLB:&#123;library&#125;\tPL:Illumina\tPU:&#123;sample&#125;\tSM:&#123;sample&#125;\tDT:&#123;time&#125;\&quot; ref.fa read1.fq.gz read2.fq.gz | samtools <span class="hljs-built_in">sort</span> -o sorted_reads.bam<br></code></pre></td></tr></table></figure></li></ul><h3 id="Samtools-Tabix-Bgzip"><a href="#Samtools-Tabix-Bgzip" class="headerlink" title="Samtools Tabix Bgzip"></a>Samtools Tabix Bgzip</h3><ul><li>说明:</li></ul><ol><li>Samtools是一组用于处理SAM（Sequence Alignment&#x2F;Map）和BAM（Binary Alignment&#x2F;Map）格式文件的工具。它能够实现二进制查看、格式转换、排序及合并等功能。结合SAM格式中的flag、tag等信息，还可以完成比对结果的统计汇总。同时，利用Linux中的grep、awk等操作命令，可以大大扩展Samtools的使用范围与功能。Samtools包含许多命令，例如 view、sort、index、flagstat等。</li><li>Tabix 可以对NGS分析中常见格式的文件建立索引，从而加快访问速度。它不仅支持VCF文件，还支持BED、GFF、SAM等格式。只要是带有排序过的位置信息，都可以有效建立索引和查询。</li><li>Bgzip 是一个用于压缩和索引生物信息学数据文件的工具，可以在压缩文件大小和读取性能之间取得平衡，提高对大型生物信息学文件的处理效率。它是基于GZIP算法，并在其基础上添加了块压缩和索引功能。由于SNP位点数量巨大，对应的VCF文件也非常大，为了节省存储空间，最常见的做法就是压缩。只要是带有排序过的位置信息的文件，都可以有效压缩。</li></ol><ul><li><p>版本 1.20</p></li><li><p>下载安装</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">mkdir</span> samtools &amp;&amp; <span class="hljs-built_in">cd</span> samtools<br>wget https://github.com/samtools/samtools/releases/download/1.20/samtools-1.20.tar.bz2<br>tar -jxvf samtools-1.20.tar.bz2<br><br><span class="hljs-comment">#安装samtools，tabix，bgzip</span><br><span class="hljs-built_in">cd</span> samtools-1.x    <span class="hljs-comment"># and similarly for bcftools and htslib</span><br>./configure --prefix=`<span class="hljs-built_in">pwd</span>` <span class="hljs-comment">#非root</span><br>make all all-htslib<br>make install install-htslib<br><br><span class="hljs-built_in">ln</span> -s `<span class="hljs-built_in">pwd</span>`/bin/samtools ~/software/bin/samtools<br><span class="hljs-built_in">ln</span> -s `<span class="hljs-built_in">pwd</span>`/bin/tabix ~/software/bin/tabix<br><span class="hljs-built_in">ln</span> -s `<span class="hljs-built_in">pwd</span>`/bin/bgzip ~/software/bin/bgzip<br></code></pre></td></tr></table></figure></li><li><p>samtools使用</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#view</span><br>samtools view -Sb sample.sam &gt; sample.bam<br>samtools view -Sb sample.sam -o sample.bam<br>samtools view sample.bam | <span class="hljs-built_in">head</span><br><br><span class="hljs-comment">#tview</span><br>samtools tview sorted.bam ref.fa<br><br><span class="hljs-comment">#indexing</span><br>samtools faidx ref.fa <span class="hljs-comment">#生成ref.fa.fai</span><br>samtools index sorted.bam <span class="hljs-comment">#生成sorted.bam.bai</span><br><br><span class="hljs-comment">#sort</span><br>samtools <span class="hljs-built_in">sort</span> input.bam -o sorted.bam<br><br><span class="hljs-comment">#mpileup has been removed in samtools</span><br>samtools mpileup sorted.dup.bam -o sorted.dup.bcf<br><br><span class="hljs-comment">#statistics</span><br>samtools flagstat sorted.bam &gt; t1.flagstat.txt<br>samtools depth sorted.bam &gt; depth.txt<br><br><span class="hljs-comment">#merge</span><br>samtools merge out.bam in1.bam in2.bam in3.bam<br></code></pre></td></tr></table></figure></li><li><p>bgzip和tabix 配合使用</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 压缩 VCF 文件，生成 sorted.vcf.gz</span><br>bgzip sorted.vcf<br><br><span class="hljs-comment"># 解压缩 VCF 文件</span><br>bgzip -d sorted.vcf.gz<br>gunzip -c sorted.vcf.gz | less<br><br><span class="hljs-comment"># 对vcf, gff文件建立索引，生成一个后缀为 .tbi 的文件</span><br>tabix -p vcf sorted.vcf.gz<br>tabix -p gff sorted.gff.gz<br><span class="hljs-comment"># 对任意带有位置信息的文件建立索引</span><br>tabix -s 1 -b 2 -e 2 sorted.vcf.gz<br><br><br><span class="hljs-comment"># 构建好索引之后，可以快速获取指定区域的内容。</span><br><span class="hljs-comment"># 获取位于11号染色体的SNP位点</span><br>tabix sorted.vcf.gz chr11<br><br><span class="hljs-comment"># 获取位于11号染色体上突变位置大于或等于2343545的SNP位点</span><br>tabix sorted.vcf.gz chr11:2343545 | less<br><br><span class="hljs-comment"># 获取位于11号染色体上突变位置介于2343540到2343596的SNP位点</span><br>tabix sorted.vcf.gz chr11:2343540-2343596 | less<br><br><span class="hljs-comment"># 批量检索，regions.txt 文件中每行包含一个位置（chromosome:start-end）</span><br>tabix sorted.vcf.gz -R regions.txt | bgzip -c &gt; sorted.regions.vcf.gz<br></code></pre></td></tr></table></figure></li></ul><h3 id="BCFtools"><a href="#BCFtools" class="headerlink" title="BCFtools"></a>BCFtools</h3><ul><li>说明:BCFtools（Binary Call Format tools）是一个用于处理Variant Call Format (VCF) 和Binary Call Format (BCF)文件的命令行工具集。它是与Samtools一起开发的，用于对比对后的BAM文件进行SNP和Indel的检测。bcftools可以用于SNP和Indel的过滤、注释、统计和可视化等操作。</li><li>版本 1.20</li><li>下载安装<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">mkdir</span> bcftools &amp;&amp; <span class="hljs-built_in">cd</span> bcftools<br>wget https://github.com/samtools/bcftools/releases/download/1.20/bcftools-1.20.tar.bz2<br>tar -jxvf bcftools-1.20.tar.bz2<br><br><span class="hljs-comment">#安装</span><br><span class="hljs-built_in">cd</span> bcftools-1.x<br>./configure --prefix=`<span class="hljs-built_in">pwd</span>` <span class="hljs-comment">#非root</span><br>make<br>make install<br><br><span class="hljs-built_in">ln</span> -s `<span class="hljs-built_in">pwd</span>`/bin/bcftools ~/software/bin/bcftools<br></code></pre></td></tr></table></figure></li><li>使用<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#查看VCF/BCF文件信息</span><br>bcftools view -h file.vcf.gz<br><br><span class="hljs-comment">#过滤SNP和Indel</span><br>bcftools filter -i <span class="hljs-string">&#x27;%QUAL&gt;20&#x27;</span> file.vcf.gz &gt; filtered.vcf<br>bcftools filter -o z file.vcf.gz &gt; filtered.vcf.gz<br><br><span class="hljs-comment">#统计SNP和Indel</span><br>bcftools stats file.vcf &gt; stats.txt<br><span class="hljs-comment">#可视化SNP和Indel</span><br>plot-vcfstats -p plots/ stats.txt<br><br><span class="hljs-comment">#calling variants</span><br>bcftools mpileup -Ou -f ref.fa aln.bam | \<br>    bcftools call -Ou -<span class="hljs-built_in">mv</span> | \<br>    bcftools filter -s LowQual -e <span class="hljs-string">&#x27;%QUAL&lt;20 || DP&gt;100&#x27;</span> -O z &gt; var.flt.vcf.gz<br><br><span class="hljs-comment">#合并VCF.gz文件</span><br>bcftools merge -O z -o merged.vcf.gz file1.vcf.gz file2.vcf.gz file3.vcf.gz<br></code></pre></td></tr></table></figure></li></ul><h3 id="Bedtools2"><a href="#Bedtools2" class="headerlink" title="Bedtools2"></a>Bedtools2</h3><ul><li><p>说明:bedtools工具是用于广泛的基因组学分析任务的一把利器。最广泛使用的工具能够实现基因组算术：即基因组上的集合理论。例如，bedtools允许人们从广泛使用的基因组文件格式（如BAM、BED、GFF&#x2F;GTF、VCF）的多个文件中交叉、合并、计数、互补和洗牌基因组区间。虽然每个单独的工具被设计用来做一个相对简单的任务（例如，与两个区间文件相交），但通过在UNIX命令行上结合多个bedtools操作可以进行相当复杂的分析。</p></li><li><p>版本 2.31.1</p></li><li><p>下载安装</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">mkdir</span> bedtools &amp;&amp; <span class="hljs-built_in">cd</span> bedtools<br>wget https://github.com/arq5x/bedtools2/releases/download/v2.31.1/bedtools-2.31.1.tar.gz<br>tar -zxvf bedtools-2.31.1.tar.gz<br><span class="hljs-built_in">cd</span> bedtools2<br>make<br><br><span class="hljs-built_in">ln</span> -s `<span class="hljs-built_in">pwd</span>`/bin/bedtools ~/software/bin/bedtools<br></code></pre></td></tr></table></figure></li><li><p>使用</p><img src="/2024/01/23/2.BioinfoSoftwareInstall/intersect-glyph.webp" class=""><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#显示cpg.bed中和exons.bed有重叠的intervals</span><br>bedtools intersect -a cpg.bed -b exons.bed<br><br><span class="hljs-comment">#cpg.bed文件中不和exons.bed任何intervals重叠的记录</span><br>bedtools intersect -a cpg.bed -b exons.bed -v<br><br><span class="hljs-comment"># 同时显示重叠区域的A、B文件中的原始记录</span><br>bedtools intersect -a exons.bed -b cpg.bed -wa -wb<br><br><span class="hljs-comment">#merge要求输入文件先排序</span><br><span class="hljs-comment">#排序，输入文件先按染色体排序，然后按起始位置排序。</span><br><span class="hljs-built_in">sort</span> -k1,1 -k2,2n test.bed &gt;test.sorted.bed<br><span class="hljs-comment">#显示最终的&quot;合并&quot;区间</span><br>bedtools merge -i exons.bed | <span class="hljs-built_in">head</span> -n 20<br><br><span class="hljs-comment">#合并距离不超过1000的区间，</span><br>bedtools merge -i exons.bed -d 1000 -c 1 -o count | <span class="hljs-built_in">head</span> -20<br></code></pre></td></tr></table></figure></li></ul><h3 id="liftover"><a href="#liftover" class="headerlink" title="liftover"></a>liftover</h3><ul><li><p>说明：LiftOver是一个广泛使用的工具，用于在不同版本的基因组参考序列之间转换基因组坐标。例如，可以将基因组坐标从GRCh37(hg19)转换到GRCh38(hg38)。LiftOver可以通过UCSC工具或者通过命令行使用。</p><p>人类基因组计划启动20年，目前出了很多基因组版本，UCSC、NCBI、Ensembl、1000 Genomes Project、Broad Institute等机构和项目也会对人类基因组参考序列进行命名和使用。</p><p>2022年的T2T-CHM13&#x2F;hs1<br>2013年的GRCh38&#x2F;hg38<br>2009年的GRCh37&#x2F;hg19<br>2006年的GRCh36&#x2F;hg18<br>2004年的GRCh35&#x2F;hg17</p></li><li><p>版本</p></li><li><p>下载安装</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">##网页版提交</span><br>https://genome.sph.umich.edu/wiki/LiftOver <span class="hljs-comment">#Web_interface</span><br><br><span class="hljs-comment">#软件下载</span><br><span class="hljs-built_in">mkdir</span> liftover &amp;&amp; <span class="hljs-built_in">cd</span> liftover<br>wget http://hgdownload.soe.ucsc.edu/admin/exe/linux.x86_64/liftOver<br><span class="hljs-built_in">chmod</span> 755 liftOver<br><br><span class="hljs-built_in">ln</span> -s `<span class="hljs-built_in">pwd</span>`/liftOver ~/software/bin/liftOver<br><br><span class="hljs-comment">#下载所需的链文件（Chain Files）</span><br>wget http://hgdownload.soe.ucsc.edu/goldenPath/hg38/liftOver/hg38ToHg19.over.chain.gz<br>wget http://hgdownload.soe.ucsc.edu/goldenPath/hg19/liftOver/hg19ToHg38.over.chain.gz<br>wget http://hgdownload.soe.ucsc.edu/goldenPath/hg19/liftOver/hg19ToHg18.over.chain.gz<br>wget http://hgdownload.soe.ucsc.edu/goldenPath/hg18/liftOver/hg18ToHg19.over.chain.gz<br>wget http://hgdownload.soe.ucsc.edu/goldenPath/hg18/liftOver/hg18ToHg38.over.chain.gz<br><br>wget https://raw.githubusercontent.com/xiaoqiangq/Fastq2Vcf/master/lib/makeAnnovarIndex.pl<br><br></code></pre></td></tr></table></figure></li><li><p>使用</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs bash">less hg38_cosmic91.txt |sed <span class="hljs-string">&#x27;s/^/chr/g&#x27;</span> |perl -lane <span class="hljs-string">&#x27;print join(&quot;\t&quot;,@F[0,1],$F[2]+1,join(&quot;\:&quot;,@F[3..@F-1])) &#x27;</span> &gt;hg38_cosmic91.txt2<br><br>liftOver hg38_cosmic91.txt2 hg38ToHg19.over.chain.gz output.bed unlifted.bed <span class="hljs-comment">#output.bed 染色体没有sort，所以排序</span><br><br><span class="hljs-comment">#排序</span><br><span class="hljs-keyword">for</span> c <span class="hljs-keyword">in</span> &#123;1..22&#125; X Y MT ;<span class="hljs-keyword">do</span> <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;less output.bed |sed &#x27;s/:/\t/g&#x27; |sed &#x27;s/^chr//&#x27;|perl -lane &#x27;if(\$F[0] eq \&quot;<span class="hljs-variable">$c</span>\&quot;)&#123;print join(\&quot;\\t\&quot;,@F[0,1],\$F[2]-1,@F[3..@F-1])&#125;&#x27; |sort -k2,2n -k3,3n &gt;chr<span class="hljs-variable">$c</span>.tmp&quot;</span>;<span class="hljs-keyword">done</span> |local-run -n 25<br><br><span class="hljs-comment">#合并</span><br>less chr1.tmp chr2.tmp chr3.tmp chr4.tmp chr5.tmp chr6.tmp chr7.tmp chr8.tmp chr9.tmp chr10.tmp chr11.tmp chr12.tmp chr13.tmp chr14.tmp chr15.tmp chr16.tmp chr17.tmp chr18.tmp chr19.tmp chr20.tmp chr21.tmp chr22.tmp chrX.tmp chrY.tmp &gt; hg19_gnomad312_genome.txt <span class="hljs-comment"># 加入header</span><br><br><span class="hljs-comment">#生成idx</span><br>perl makeAnnovarIndex.pl hg19_gnomad312_genome.txt 1000 <span class="hljs-comment">#idx</span><br></code></pre></td></tr></table></figure></li></ul><h3 id="sra-tools"><a href="#sra-tools" class="headerlink" title="sra-tools"></a>sra-tools</h3><ul><li><p>说明:SRA-Tools是一组命令行工具，用于从 NCBI 的 Sequence Read Archive(SRA)下载和处理测序数据。这些工具包括fastq-dump、prefetch、fasterq-dump等，主要用于从SRA下载和转换测序数据。</p></li><li><p>版本:3.1.0</p></li><li><p>安装</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">mkdir</span> sra-tools &amp;&amp; <span class="hljs-built_in">cd</span> sra-tools<br><span class="hljs-comment">#wget https://github.com/ncbi/sra-tools/archive/refs/tags/3.1.0.tar.gz</span><br>wget https://ftp-trace.ncbi.nlm.nih.gov/sra/sdk/3.1.0/sratoolkit.3.1.0-centos_linux64.tar.gz<br>tar -zxvf sratoolkit.3.1.0-centos_linux64.tar.gz<br><span class="hljs-built_in">mv</span> sratoolkit.3.1.0-centos_linux64 sratoolkit.3.1.0<br><span class="hljs-built_in">cd</span> sratoolkit.3.1.0<br><span class="hljs-comment">#无需编译</span><br><br><span class="hljs-built_in">ln</span> -s `<span class="hljs-built_in">pwd</span>`/bin/prefetch ~/software/bin/prefetch<br><span class="hljs-built_in">ln</span> -s `<span class="hljs-built_in">pwd</span>`/bin/fastq-dump ~/software/bin/fastq-dump<br></code></pre></td></tr></table></figure></li><li><p>使用</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#prefetch:用于从SRA下载数据</span><br>prefetch SRR123456<br><br><span class="hljs-comment">#将SRA文件转换为FASTQ</span><br><span class="hljs-comment">#用于将SRA文件转换为FASTQ格式</span><br>fastq-dump SRR123456.sra<br><span class="hljs-comment">#用于更快地将 SRA 文件转换为 FASTQ 格式</span><br>fasterq-dump SRR123456.sra<br></code></pre></td></tr></table></figure></li></ul><h3 id="FastQC"><a href="#FastQC" class="headerlink" title="FastQC"></a>FastQC</h3><ul><li><p>说明:FastQC是一个用于高通量测序数据质量控制的工具。它可以快速生成一系列图表和统计信息，用于评估原始数据的质量。FastQC支持多种文件格式，包括FASTQ、BAM和SAM文件。</p></li><li><p>版本:0.12.1。</p></li><li><p>安装</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">mkdir</span> fastqc and <span class="hljs-built_in">cd</span> fastqc<br>wget https://www.bioinformatics.babraham.ac.uk/projects/fastqc/fastqc_v0.12.1.zip<br><br>unzip fastqc_v0.12.1.zip<br><span class="hljs-built_in">mv</span> FastQC fastqc_v0.12.1<br><span class="hljs-built_in">cd</span> fastqc_v0.12.1<br><br><span class="hljs-built_in">ln</span> -s `<span class="hljs-built_in">pwd</span>`/fastqc ~/software/bin/fastqc<br></code></pre></td></tr></table></figure></li><li><p>使用</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs bash">fastqc -t 4 -f fastq -o ~/QC R1.fastq.gz R2.fastq.gz<br><span class="hljs-comment">#输出质控网页报告</span><br>QC<br>├── R1_fastqc.html<br>├── R1_fastqc.zip<br>├── R2_fastqc.html<br>└── R2_fastqc.zip<br><br><span class="hljs-comment">#质检报告提供了以下信息（绿勾合格，黄色叹号警告，红叉不合格）：</span><br>①Basic Statistics<br>②Per base sequence quality<br>③Per sequence quality scores<br>④Per base sequence content<br>⑤Per sequence GC content<br>⑥Per base N content<br>⑦Sequence Length Distribution<br>⑧Sequence Duplication Levels<br>⑨Overrepresented sequences<br>⑩Adapter Content<br><br></code></pre></td></tr></table></figure></li></ul><h3 id="Bowtie2"><a href="#Bowtie2" class="headerlink" title="Bowtie2"></a>Bowtie2</h3><ul><li>说明:Bowtie是一种超快速、内存高效的短序列比对器，特别适用于大量短序列数据的比对。Bowtie通过采用Burrows-Wheeler变换和FM索引，实现了快速且高效的比对，同时对内存使用进行了高度优化。在使用Bowtie进行序列比对时，end-to-end（全局比对）模式是一种常用模式。在这种模式下，比对器尝试将每个读取（read）在其整个长度上与参考基因组进行比对，要求比对必须覆盖读取的全部长度。这种方式适用于对比对精度要求较高的应用场景。因此，在进行比对之前，需要先去除序列中的接头（adapters）以确保比对的准确性。</li><li>版本 2.5.4</li><li>下载安装<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">mkdir</span> bowtie2 &amp;&amp; <span class="hljs-built_in">cd</span> bowtie2<br>wget https://sourceforge.net/projects/bowtie-bio/files/bowtie2/2.5.4/bowtie2-2.5.4-linux-x86_64.zip<br>unzip bowtie2-2.5.4-linux-x86_64.zip<br><span class="hljs-built_in">mv</span> bowtie2-2.5.4-linux-x86_64 bowtie2-2.5.4<br><br><span class="hljs-built_in">cd</span> bowtie2-2.5.4<br><span class="hljs-comment">#不用编译安装</span><br><br><span class="hljs-built_in">ln</span> -s `<span class="hljs-built_in">pwd</span>`/bowtie2 ~/software/bin/bowtie2<br><span class="hljs-built_in">ln</span> -s `<span class="hljs-built_in">pwd</span>`/bowtie2-build ~/software/bin/bowtie2-build<br></code></pre></td></tr></table></figure></li><li>使用<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#构建索引</span><br>bowtie2-build genome.fa genome<br><br><span class="hljs-comment">#进行比对</span><br><span class="hljs-comment">#单端数据</span><br>bowtie2 -x genome -U reads.fq.gz -S output.sam<br>bowtie2 -x genome -U reads.fq.gz | samtools view -bS -o output.bam<br><span class="hljs-comment">#双端数据</span><br>bowtie2 -x genome -1 read1.fq.gz -2 read2.fq.gz -p 4 -S output.sam <br>bowtie2 -x genome -1 read1.fq.gz -2 read2.fq.gz -p 4 | samtools view -bS -o output.bam<br></code></pre></td></tr></table></figure></li></ul><h3 id="Bismark"><a href="#Bismark" class="headerlink" title="Bismark"></a>Bismark</h3><ul><li>说明:Bismark 是一个专门用于比对二代测序数据中的甲基化数据的工具。它可以将比对到参考基因组的结果直接转换为甲基化状态，同时还可以处理全基因组亚硫酸氢盐测序(WGBS)和简化代表性亚硫酸氢盐测序(RRBS)数据。Bismark通过调用Bowtie2或HISAT2进行比对，并自动生成甲基化调用结果。</li><li>版本:0.24.2</li><li>下载安装:<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">mkdir</span> bismark &amp;&amp; <span class="hljs-built_in">cd</span> bismark<br><span class="hljs-comment"># 从官方网站下载</span><br>wget https://github.com/FelixKrueger/Bismark/archive/refs/tags/v0.24.2.tar.gz<br>tar -xzvf v0.24.2.tar.gz<br><br><span class="hljs-built_in">cd</span> Bismark-0.24.2<br><span class="hljs-comment">#不用编译安装</span><br><br><span class="hljs-built_in">ln</span> -s `<span class="hljs-built_in">pwd</span>`/bismark ~/software/bin/bismark<br></code></pre></td></tr></table></figure></li><li>使用<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 建立参考基因组索引</span><br>./bismark_genome_preparation --path_to_aligner ~/software/bowtie2/bowtie2-2.5.4/ --verbose /path/to/genome/ --bowtie2<br><br><span class="hljs-comment"># single end</span><br>bismark /path/to/genome/ \<br> -path_to_bowtie <span class="hljs-variable">$hash_config</span>&#123;<span class="hljs-string">&quot;bowtie2&quot;</span>&#125; --bowtie2 -q -p 2 \<br>sample.fq.gz  -o sample.bismark<br><br><span class="hljs-comment"># paired end</span><br>bismark /path/to/genome/ \<br>-path_to_bowtie <span class="hljs-variable">$hash_config</span>&#123;<span class="hljs-string">&quot;bowtie2&quot;</span>&#125; --bowtie2 -q -p 2 \<br>--samtools_path <span class="hljs-variable">$hash_config</span>&#123;<span class="hljs-string">&quot;samtools_dir&quot;</span>&#125; \<br>-1 R1.fq.gz -2 R2.fq.gz -o sample.bismark<br><br><span class="hljs-comment">#去重</span><br>deduplicate_bismark --bam /path/to/output/*.bam<br><br><span class="hljs-comment">#提取甲基化信息</span><br>bismark_methylation_extractor -s --comprehensive dedupped.sortn.rm.bam \<br>-o <span class="hljs-variable">$opt_out_dir</span> --gzip --no_overlap --report --bedGraph --cytosine_report \<br>--genome_folder /path/to/genome/ --multicore 2 --samtools_path samtools_dir<br><br><br><span class="hljs-comment">#转成tabix格式</span><br>gunzip -c dedupped.sortn.rm.CpG_report.txt.gz | bgzip -c &gt; CpG_report.txt.gz &amp;&amp; \<br>tabix -s 1 -b 2 -e 2 CpG_report.txt.gz  &amp;&amp; \<br><span class="hljs-built_in">rm</span> -f dedupped.sortn.rm.CpG_report.txt.gz  &amp;&amp; \<br>tabix CpG_report.txt.gz 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 X Y MT | bgzip -c &gt; CpG.txt.gz &amp;&amp; \<br>tabix -s 1 -b 2 -e 2 CpG.txt.gz <br></code></pre></td></tr></table></figure></li></ul><h3 id="Biscuit"><a href="#Biscuit" class="headerlink" title="Biscuit"></a>Biscuit</h3><ul><li>说明:Biscuit 是一种专门用于甲基化数据分析的工具，能够处理全基因组亚硫酸氢盐测序 (WGBS) 数据。Biscuit 提供了从原始序列数据的比对到甲基化位点调用的全套流程，并且对性能进行了高度优化，适用于大规模数据集的处理。与其他甲基化分析软件相比，Biscuit 综合表现优异，具有以下特点：</li></ul><ol><li>使用 BWA 算法进行比对，具有较高的比对精度和速度。</li><li>能够调用突变（mutations），提供更全面的数据分析能力。</li></ol><ul><li>版本:1.5.0</li><li>下载安装:<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">mkdir</span> biscuit &amp;&amp; <span class="hljs-built_in">cd</span> biscuit<br>wget https://github.com/huishenlab/biscuit/releases/download/v1.5.0.20240506/biscuit_1_5_0_linux_amd64 -O biscuit2<br><br>wget https://github.com/huishenlab/biscuit/archive/refs/tags/v1.5.0.20240506.tar.gz<br>tar -xzvf v1.5.0.20240506.tar.gz<br><span class="hljs-built_in">mv</span> biscuit-1.5.0.20240506 biscuit-1.5.0<br><span class="hljs-built_in">cd</span> biscuit-1.5.0<br><br><span class="hljs-built_in">mkdir</span> build &amp;&amp; <span class="hljs-built_in">cd</span> build<br>cmake -DCMAKE_INSTALL_PREFIX=../ ../<br>make &amp;&amp; make install<br><br><br></code></pre></td></tr></table></figure></li><li>使用<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#准备基因组</span><br>biscuit index /path/to/genome.fa<br><br><span class="hljs-comment">#进行比对</span><br>biscuit align /path/to/genome.fa read1.fastq read2.fastq -o output.bam<br><br><span class="hljs-comment"># 甲基化调用</span><br>biscuit pileup /path/to/genome.fa dedup_output.bam -o methylation_output.vcf<br><br><span class="hljs-comment">#过滤和分析</span><br>biscuit vcf2bed -c 10 methylation_output.vcf &gt; filtered_methylation.bed<br></code></pre></td></tr></table></figure></li></ul><h3 id="GATK"><a href="#GATK" class="headerlink" title="GATK"></a>GATK</h3><ul><li>说明:GATK（Genome Analysis Toolkit）是一个由Broad Institute开发的强大的工具包，广泛应用于处理和分析高通量测序数据。它主要用于变异检测、基因组校准、重校正和其他基因组分析任务。</li><li>版本 4.3.0.0 java8; &gt;&#x3D;4.4.0.0，需要Java17。</li><li>安装<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">mkdir</span> GATK &amp;&amp; <span class="hljs-built_in">cd</span> GATK<br>wget https://github.com/broadinstitute/gatk/releases/download/4.3.0.0/gatk-4.3.0.0.zip<br>unzip gatk-4.3.0.0.zip<br><br><span class="hljs-built_in">cd</span> gatk-4.3.0.0<br><br><span class="hljs-built_in">ln</span> -s `<span class="hljs-built_in">pwd</span>`/gatk ~/software/bin/gatk<br><br><span class="hljs-comment">#GATK需要的R包</span><br>install.packages(<span class="hljs-string">&quot;ggplot2&quot;</span>)<br>install.packages(c(<span class="hljs-string">&quot;bitops&quot;</span>, <span class="hljs-string">&quot;caTools&quot;</span>, <span class="hljs-string">&quot;colorspace&quot;</span>, <span class="hljs-string">&quot;gdata&quot;</span>,<span class="hljs-string">&quot;gplots&quot;</span>,<span class="hljs-string">&quot;gtools&quot;</span>,<span class="hljs-string">&quot;RColorBrewer&quot;</span>,<span class="hljs-string">&quot;reshape&quot;</span>,<span class="hljs-string">&quot;gsalib&quot;</span>))<br></code></pre></td></tr></table></figure></li><li>使用<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#查看 GATK 工具列表</span><br>gatk --list<br><br><span class="hljs-comment">#命令用于为参考基因组文件（如FASTA文件）创建一个序列字典文件。序列字典文件包含参考基因组中各个染色体或序列的名称、长度和顺序等信息。</span><br>gatk CreateSequenceDictionary -R hg19.fa -O hg19.dict<br><br><span class="hljs-comment">#使用MarkDuplicatesSpark工具来去除重复项，Picard已经整合到GATK当中</span><br>gatk MarkDuplicatesSpark \<br>    -I input.bam \<br>    -O deduped.bam \<br>    -M metrics.txt<br><br><span class="hljs-comment">#BaseRecalibrator 用于执行碱基质量重校正</span><br>gatk BaseRecalibrator \<br>  -I input.bam \<br>  -R reference.fasta \<br>  --known-sites known_sites.vcf \<br>  -O recal_data.table<br><br><span class="hljs-comment">#ApplyBQSR 用于应用 BaseRecalibrator 生成的重校正数据</span><br>gatk ApplyBQSR \<br>  -R reference.fasta \<br>  -I input.bam \<br>  --bqsr-recal-file recal_data.table \<br>  -O recalibrated.bam<br><br><span class="hljs-comment">#HaplotypeCaller 用于变异检测</span><br>gatk HaplotypeCaller \<br>  -R reference.fasta \<br>  -I input.bam \<br>  -O output.vcf<br><br></code></pre></td></tr></table></figure></li></ul><h3 id="R"><a href="#R" class="headerlink" title="R"></a>R</h3><ul><li>说明:R语言是一种用于统计计算和数据可视化的编程语言和环境。它在统计计算、数据可视化、数据处理和转换等方面广泛应用。</li><li>版本：4.4.0</li><li>安装 建议使用conda安装<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">mkdir</span> R &amp;&amp; <span class="hljs-built_in">cd</span> R<br>wget https://cran.r-project.org/src/base/R-4/R-4.4.0.tar.gz<br><br>tar -xvf R-4.4.0.tar.gz <br><span class="hljs-built_in">cd</span> R-4.4.0/<br><br>./configure --prefix=`<span class="hljs-built_in">pwd</span>`<br><span class="hljs-comment">#configure: WARNING: --with-libdeflate-compression requires libdeflate</span><br><br>make<br>make install<br><br><span class="hljs-comment">#可能需要的环境 sudo</span><br>yum install readline-devel<br>yum install libXext-devel libXt-devel <span class="hljs-comment">#libX11-devel 库里面有</span><br>yum install pcre2-devel<br>yum install libcurl-devel<br>yum install java-1.8.0-openjdk-devel<br>yum groupinstall <span class="hljs-string">&quot;Development Tools&quot;</span><br></code></pre></td></tr></table></figure></li></ul><h2 id="2-Conda安装包安装"><a href="#2-Conda安装包安装" class="headerlink" title="2.Conda安装包安装"></a>2.Conda安装包安装</h2><ul><li><p>说明：Conda 是一个流行的包管理器和环境管理器，广泛用于 Python 和其他数据科学工具的安装和管理。</p></li><li><p>版本:24.1.2</p></li><li><p>安装</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs bash">wget https://repo.anaconda.com/archive/Anaconda3-2024.02-1-Linux-x86_64.sh --no-check-certificate<br>bash Anaconda3-2024.02-1-Linux-x86_64.sh<br><br><span class="hljs-comment">#Please, press ENTER to continue</span><br>&gt;&gt;&gt; enter<br><br><span class="hljs-comment"># More，继续按Enter or 空格，最后输入yes同意用户许可证就行</span><br><span class="hljs-comment">#Do you accept the license terms? [yes|no]</span><br>&gt;&gt;&gt; <span class="hljs-built_in">yes</span><br><br><span class="hljs-comment">#修改安装路径</span><br>[/data/home/usr1/anaconda3] &gt;&gt;&gt; ~/software/anaconda3<br><br><span class="hljs-comment">#You can undo this by running `conda init --reverse $SHELL`? [yes|no]</span><br>&gt;&gt;&gt; <span class="hljs-built_in">yes</span><br><br><span class="hljs-built_in">source</span> ~/.bashrc<br><br>conda --version<br>conda info <span class="hljs-comment">#python: 3.11.7.final.0</span><br></code></pre></td></tr></table></figure></li><li><p>使用</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#环境</span><br>conda create --name python27 python=2.7 <span class="hljs-comment">#创建环境</span><br>conda activate python27 <span class="hljs-comment">#激活环境</span><br>conda deactivate <span class="hljs-comment">#离开当前环境</span><br>conda <span class="hljs-built_in">env</span> remove -n python27 <span class="hljs-comment">#删除指定的环境</span><br>conda <span class="hljs-built_in">env</span> list <span class="hljs-comment">#列出所有可用环境</span><br><br>conda <span class="hljs-built_in">env</span> <span class="hljs-built_in">export</span> &gt; environment.yml <span class="hljs-comment">#将当前的环境保存到文件中包保存为yaml文件</span><br>conda <span class="hljs-built_in">env</span> update -f=environment.yml <span class="hljs-comment">#用于更新Conda环境中的包列表</span><br><br><br><span class="hljs-comment">#包</span><br>conda install matplotlib <span class="hljs-comment">#安装 matplotlib 在当前环境</span><br>conda update matplotlib <span class="hljs-comment"># 包更新</span><br>conda remove matplotlib   <span class="hljs-comment"># 删除包 </span><br><br>conda install -p /home/weiq1/lib/conda/ -c bioconda cutadapt<br>conda list <span class="hljs-comment">#列出当前环境中安装的所有包</span><br><br><span class="hljs-comment">#要在其他环境中共享 base 环境中已安装的包</span><br><span class="hljs-comment">#1.确定 base 环境的包目录</span><br>conda info --base<br><br><span class="hljs-comment">#2.该目录下的pkgs目录中的软件包链接到其他环境的pkgs目录中：</span><br><span class="hljs-built_in">ln</span> -s /path/to/base_env/pkgs/* /path/to/new_env/pkgs/<br></code></pre></td></tr></table></figure></li></ul><h3 id="Conda常用必备包"><a href="#Conda常用必备包" class="headerlink" title="Conda常用必备包"></a>Conda常用必备包</h3><p>#已经默认安装的包</p><table><thead><tr><th>软件</th><th>版本</th></tr></thead><tbody><tr><td>python</td><td>3.11.7</td></tr><tr><td>numpy</td><td>1.26.4</td></tr><tr><td>pandas</td><td>2.1.4</td></tr><tr><td>matplotlib</td><td>3.8.0</td></tr><tr><td>scikit-learn</td><td>1.2.2</td></tr><tr><td>jupyterlab</td><td>4.0.11</td></tr><tr><td>tensorflow</td><td>–</td></tr><tr><td>scipy</td><td>1.11.4</td></tr></tbody></table><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#NumPy是Python中用于科学计算的基础包，提供了多维数组和各种数学函数，是许多其他数据科学库的基础。</span><br>conda install numpy<br><br><span class="hljs-comment">#Pandas是一个用于数据处理和分析的强大工具，提供了灵活的数据结构和数据操作方法。</span><br>conda install pandas<br><br><span class="hljs-comment">#Matplotlib是Python中用于绘制图表和可视化数据的库，提供了丰富的绘图功能。</span><br>conda install matplotlib<br><br><span class="hljs-comment">#scikit-learn 是一个流行的机器学习库，提供了各种机器学习算法和工具，用于分类、回归、聚类等任务。</span><br>conda install scikit-learn<br><br><span class="hljs-comment">#JupyterLab是Jupyter Notebook的下一代界面，提供了一个交互式的数据科学开发环境，支持笔记本、代码编辑器、终端等功能。</span><br>conda install -c conda-forge jupyterlab<br><br><span class="hljs-comment">#tensorflow 或 pytorch: 如果你需要进行深度学习任务，你可能需要安装 TensorFlow 或 PyTorch。</span><br>conda install tensorflow<br>conda install pytorch torchvision torchaudio cudatoolkit=11.1 -c pytorch -c nvidia<br><br><span class="hljs-comment">#SciPy 是一个用于科学计算和技术计算的库，提供了数值积分、优化、插值、线性代数等功能。</span><br>conda install scipy<br></code></pre></td></tr></table></figure><h3 id="1-conda-install-c-bioconda-pysam-会安装一下3个包"><a href="#1-conda-install-c-bioconda-pysam-会安装一下3个包" class="headerlink" title="1.conda install -c bioconda pysam #会安装一下3个包"></a>1.conda install -c bioconda pysam #会安装一下3个包</h3><pre><code class="hljs">samtools=1.3.1bcftools=1.3.1htslib=1.3.1</code></pre><h3 id="2-snakemake"><a href="#2-snakemake" class="headerlink" title="2.snakemake"></a>2.snakemake</h3><ul><li>说明:Snakemake是一种基于Python的工作流管理系统，能够用于创建可重复和可扩展的数据分析的工具。其编写的流程可以无缝部署到服务器、集群等环境，而无需对流程进行修改。依托于conda包管理系统，不需要我们手动安装依赖软件，可以做到只修改配置文件便能运行整个流程。会自动检查文件时间戳，能够从上次中断的位置继续往下跑，而不用重复执行。</li><li>版本:8.11.3</li><li>安装<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs bash">conda create -n snakemake -c conda-forge -c bioconda snakemake<br>conda activate snakemake<br><br><span class="hljs-comment">#如果你的conda安装很慢或者获取不了最新版本的软件，可以使用下面的命令安装：</span><br>conda install -c conda-forge mamba<br>mamba create -c conda-forge -c bioconda -n snakemake snakemake<br>conda activate snakemake<br>snakemake --<span class="hljs-built_in">help</span><br><br><span class="hljs-built_in">ln</span> -s /data/software/anaconda3/envs/snakemake/bin/snakemake ~/software/bin/snakemake<br><br><span class="hljs-comment">####</span><br>git <span class="hljs-built_in">clone</span> https://bitbucket.org/snakemake/snakemake-tutorial.git<br><span class="hljs-built_in">cd</span> snakemake-tutorial<br>tree<br><br><span class="hljs-comment">#安装pipeline所需要的包，比如bwa，samtools等</span><br>conda install -c conda-forge graphviz <span class="hljs-comment">#dot画图2.42.3装在snakemake的环境下面。</span><br><br>snakemake --dag  | dot -Tsvg &gt; dag.svg <span class="hljs-comment">#生成有向无环图(DAG)</span><br>snakemake --cores 1 <br>snakemake --cores 1<br>snakemake -s Snakefile<br></code></pre></td></tr></table></figure></li><li>使用<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><br><br><br></code></pre></td></tr></table></figure></li></ul><h3 id="3-R安装"><a href="#3-R安装" class="headerlink" title="3.R安装"></a>3.R安装</h3><ul><li><p>说明:R语言是一种用于统计计算和数据可视化的编程语言和环境。它在统计计算、数据可视化、数据处理和转换等方面广泛应用。</p></li><li><p>版本：4.3.3</p></li><li><p>安装</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#conda install -c conda-forge r-base=4.1.3 #装不上，需要建立新环境</span><br>conda create -n r4-base -c conda-forge r-base r-ggplot2<br>conda activate r4-base<br><br><span class="hljs-built_in">ln</span> -s ~/software/anaconda3/envs/r4-base/bin/R ~/software/bin/R<br><span class="hljs-built_in">ln</span> -s ~/software/anaconda3/envs/r4-base/bin/Rscript ~/software/bin/Rscript<br></code></pre></td></tr></table></figure></li><li><p>使用</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#显示R中的包路径，通常情况下，第一个路径是系统级别的路径，第二个路径是用户级别的路径。</span><br>.libPaths()<br><br><span class="hljs-comment">#列出当前环境中已安装的所有包的信息，包括包名、版本、描述、依赖关系等</span><br>installed.packages()<br></code></pre></td></tr></table></figure><table><thead><tr><th></th><th>Package</th><th>LibPath</th></tr></thead><tbody><tr><td>base</td><td>“base”</td><td>“anaconda3&#x2F;envs&#x2F;r4-base&#x2F;lib&#x2F;R&#x2F;library”</td></tr><tr><td>compiler</td><td>“compiler”</td><td>“…”</td></tr><tr><td>datasets</td><td>“datasets”</td><td>“…”</td></tr><tr><td>graphics</td><td>“graphics”</td><td>“…”</td></tr><tr><td>grDevices</td><td>“grDevices”</td><td>“…”</td></tr><tr><td>grid</td><td>“grid”</td><td>“…”</td></tr><tr><td>methods</td><td>“methods”</td><td>“…”</td></tr><tr><td>parallel</td><td>“parallel”</td><td>“…”</td></tr><tr><td>splines</td><td>“splines”</td><td>“…”</td></tr><tr><td>stats</td><td>“stats”</td><td>“…”</td></tr><tr><td>stats4</td><td>“stats4”</td><td>“…”</td></tr><tr><td>tcltk</td><td>“tcltk”</td><td>“…”</td></tr><tr><td>tools</td><td>“tools”</td><td>“…”</td></tr><tr><td>utils</td><td>“utils”</td><td>“…”</td></tr></tbody></table></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">###安装常用包</span><br><span class="hljs-comment">#install.packages(&quot;ggplot2&quot;)</span><br>install.packages(c(<span class="hljs-string">&quot;bitops&quot;</span>, <span class="hljs-string">&quot;caTools&quot;</span>, <span class="hljs-string">&quot;colorspace&quot;</span>, <span class="hljs-string">&quot;gdata&quot;</span>,<span class="hljs-string">&quot;gplots&quot;</span>,<span class="hljs-string">&quot;gtools&quot;</span>,<span class="hljs-string">&quot;RColorBrewer&quot;</span>,<span class="hljs-string">&quot;reshape&quot;</span>,<span class="hljs-string">&quot;gsalib&quot;</span>))<br><br><span class="hljs-comment">#指定安装位置</span><br>install.packages(<span class="hljs-string">&quot;bitops&quot;</span>, lib=<span class="hljs-string">&quot;/scratch/cgg/usr1/software/R-3.0.2/R-packages/&quot;</span>)<br><br><span class="hljs-comment">#显示当前工作目录</span><br>getwd()<br><br><span class="hljs-comment">#修改当前的工作目录为mydirectory</span><br>setwd(<span class="hljs-string">&quot;mydirctory&quot;</span>)<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>生物信息学</category>
      
    </categories>
    
    
    <tags>
      
      <tag>bwa</tag>
      
      <tag>samtools</tag>
      
      <tag>bgzip</tag>
      
      <tag>tabix</tag>
      
      <tag>liftover</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>GATK使用方法详解-变异检测</title>
    <link href="/2024/01/23/GATK4%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95%E8%AF%A6%E8%A7%A3-%E5%8F%98%E5%BC%82%E6%A3%80%E6%B5%8B/"/>
    <url>/2024/01/23/GATK4%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95%E8%AF%A6%E8%A7%A3-%E5%8F%98%E5%BC%82%E6%A3%80%E6%B5%8B/</url>
    
    <content type="html"><![CDATA[<p>GATK4是最新的GATK版本，它在算法上进行了优化，运行速率得到提高，而且整合了picard。GATK4依然是用java 语言开发的，但使用方式上更加人性化，比如所有命令都是gatk cmd方式，这里的cmd是任何可以用的cmd。GATK4 的最佳实践给出了5套pipeline: <strong>Germline SNP&#x2F;Indel</strong>, Somatic SNV&#x2F;Indel, RNAseq SNP&#x2F;Indel, Germline CNV, Somatic CNV。目前版本号是 4.2.4 <a href="https://gatk.broadinstitute.org/hc/en-us">https://gatk.broadinstitute.org/hc/en-us</a> </p><h1 id="1-建立索引"><a href="#1-建立索引" class="headerlink" title="1. 建立索引"></a>1. 建立索引</h1><ol><li>gatk  CreateSequenceDictionary -R hg19.fa -O hg19.dict</li><li>samtools faidx genome.fasta # .fai</li><li>bwa index ref.fa # .amb, .ann, .bwt, .pac, .sa</li><li>qplot –reference ucsc.hg19.fasta  –create_gc ucsc.hg19.winsize100.gc #.winsize100.gc</li><li>bowtie-build ucsc.hg19.fasta ucsc.hg19 ##</li><li>bowtie2-build human_g1k_v37.fa human_g1k_v37 #bowtie2-2.4.1</li></ol><h1 id="2-比对"><a href="#2-比对" class="headerlink" title="2. 比对"></a>2. 比对</h1><ul><li>BWA for DNA, STAR for RNA-seq</li></ul><h2 id="2-1-bwa-比对"><a href="#2-1-bwa-比对" class="headerlink" title="2.1 bwa 比对"></a>2.1 bwa 比对</h2><p>bwa mem -M -t 4 -R ‘@RG\tID:id1\tPL:illumina\tSM:test’ ref.fa test_1.fq test_2.fq | samtools view -bS - &gt;test.bam</p><p><strong>参数</strong><br>-R 设置reads group，gatk必须要的信息，其中ID，PL和SM信息是必须要的<br>GATK 要求read group的格式</p><h2 id="2-2-排序"><a href="#2-2-排序" class="headerlink" title="2.2 排序"></a>2.2 排序</h2><p>samtools sort -@ 3 -o test.sorted.bam test.bam<br>samtools index test.sorted.bam<br>rm -rf test.bam</p><p>ID &#x3D; Read group identifier<br>　　每一个read group 独有的ID，每一对reads 均有一个独特的ID，可以自定义命名；</p><p>PL &#x3D; Platform<br>　　测序平台；ILLUMINA, SOLID, LS454, HELICOS and PACBIO，不区分大小写；</p><p>SM &#x3D; sample<br>　　reads属于的样品名；SM要设定正确，因为GATK产生的VCF文件也使用这个名字;</p><p>LB &#x3D; DNA preparation library identifier<br>　　对一个read group的reads进行重复序列标记时，需要使用LB来区分reads来自那条lane;有时候，同一个库可能在不同的lane上完成测序;为了加以区分，</p><p>　　同一个或不同库只要是在不同的lane产生的reads都要单独给一个ID. 一般无特殊说明，成对儿read属于同一库，可自定义，比如：library1</p><p>若是忘记添加read group信息还以通过 AddOrReplaceReadGroups 添加</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">gatk AddOrReplaceReadGroups -I .bam -O .add.bam -LB library1 -PL illumina -PU pl1 -SM name<br><br><span class="hljs-comment">##参数</span><br>-I Input file (BAM <span class="hljs-keyword">or</span> SAM <span class="hljs-keyword">or</span> a GA4GH url)；<br>-O  Output file (BAM <span class="hljs-keyword">or</span> SAM)；<br>-LB <span class="hljs-keyword">Read</span>-<span class="hljs-keyword">Group</span> <span class="hljs-title">library</span>；<br>-PL  <span class="hljs-keyword">Read</span>-<span class="hljs-keyword">Group</span> <span class="hljs-title">platform</span> (e.g. ILLUMINA, SOLID)；<br>-PU <span class="hljs-keyword">Read</span>-<span class="hljs-keyword">Group</span> <span class="hljs-title">platform</span> unit (eg. run barcode)；<br>-SM <span class="hljs-keyword">Read</span>-<span class="hljs-keyword">Group</span> <span class="hljs-title">sample</span> name<br><br></code></pre></td></tr></table></figure><h2 id="2-3-标记重复序列"><a href="#2-3-标记重复序列" class="headerlink" title="2.3 标记重复序列"></a>2.3 标记重复序列</h2><p>gatk  MarkDuplicates -I test.sorted.bam -O test.sorted.markdup.bam -M test.sorted.markdup_metrics.txt –CREATE_INDEX true -VALIDATION_STRINGENCY LENIENT</p><p>rm -f test.sorted.bam test.sorted.bam.bai</p><p>##参数<br>-I 排序后的一个或者多个bam或者sam文件<br>-M 输出重复矩阵<br>-O 输出文件</p><h2 id="2-4-BQSR-BaseRecalibrator"><a href="#2-4-BQSR-BaseRecalibrator" class="headerlink" title="2.4 BQSR BaseRecalibrator"></a>2.4 BQSR BaseRecalibrator</h2><ul><li>所谓的变异位点，就是与参考基因组不同的部分，假设原始数据中就存在着一些由于测序仪器产生的系统性误差，那么变异位点识别过程中找到的variant，就会存在大量的假阳性。这一步主要目的是调整原始碱基的质量分数。</li></ul><p>gatk –java-options “-Xmx8g -XX:+UseParallelGC -XX:ParallelGCThreads&#x3D;1” BaseRecalibrator -R hg19.fa -I test.sorted.markdup.bam –known-sites $hash_config{“dbsnp”} –known-sites $hash_config{“Mills_and_1000G_gold_standard_indels”}  -O sample.recal.grp –default-base-qualities 1 2&gt;&gt;$log_dir/$sample.log 1&gt;&gt;$log_dir/$sample.log&#x2F;;  ##–known-sites $hash_config{“KG_phase1_indels”}</p><p>gatk –java-options “-Xmx8g -XX:+UseParallelGC -XX:ParallelGCThreads&#x3D;1” ApplyBQSR -R hg19.fa -I test.sorted.markdup.bam -bqsr sample.recal.grp -O sample.recal.bam</p><h2 id="2-5-检测变异"><a href="#2-5-检测变异" class="headerlink" title="2.5 检测变异"></a>2.5 检测变异</h2><p>##两种方法</p><p>##（1）多样本一起call，此次只有一个样本，若有多个样本，则继续用 -I 参数添加即可<br>gatk –java-options -Xmx4G HaplotypeCaller -I test.sorted.markup.bam -O test.gvcf1 -R ref.fa</p><h2 id="（2）单个样本call，然后在合并"><a href="#（2）单个样本call，然后在合并" class="headerlink" title="（2）单个样本call，然后在合并"></a>（2）单个样本call，然后在合并</h2><h2 id="生成中间文件gvcf"><a href="#生成中间文件gvcf" class="headerlink" title="生成中间文件gvcf"></a>生成中间文件gvcf</h2><p>gatk –java-options -Xmx4G HaplotypeCaller -I test.sorted.markup.bam -O test.gvcf -R ref.fa –emit-ref-confidence GVCF</p><p>gatk –java-options “-Xmx8g -XX:+UseParallelGC -XX:ParallelGCThreads&#x3D;1” HaplotypeCaller -R hg19.fa -I test.sorted.markup.recal.bam –dbsnp $hash_config{“dbsnp”} -O sample.1.g.vcf.gz –emit-ref-confidence GVCF</p><p>##通过gvcf检测变异, -V 添加上步得到的gvcf<br>gatk GenotypeGVCFs -R ref.fa -V test.gvcf -O test.vcf</p><p>##参数<br>-I BAM&#x2F;SAM&#x2F;CRAM file<br>-O  输出文件<br>-R 参考基因组<br>–java-options: 若设置java则需要添加<br>-Xmx4G：内存为4G，防止内存太大<br>-V  A VCF file containing variants</p><h1 id="2-6-qplot"><a href="#2-6-qplot" class="headerlink" title="2.6 qplot"></a>2.6 qplot</h1><h1 id="2-7-merge-gvcf"><a href="#2-7-merge-gvcf" class="headerlink" title="2.7 merge gvcf"></a>2.7 merge gvcf</h1><p>-按照每条染色体<br>gatk –java-options “-Xmx16g” CombineGVCFs -R hg19.fa $inputgvcf -O combine.1.g.vcf.gz -L 1 </p><h1 id="2-8-calling-variants"><a href="#2-8-calling-variants" class="headerlink" title="2.8 calling variants"></a>2.8 calling variants</h1><p>gatk –java-options “-Xmx8g -XX:+UseParallelGC -XX:ParallelGCThreads&#x3D;1” GenotypeGVCFs -R hg19.fa -V sample.1.g.vcf.gz -O sample.1.vcf.gz –dbsnp $hash_config{“dbsnp”} -L 1</p><h1 id="3-VQSR-or-hardFilter"><a href="#3-VQSR-or-hardFilter" class="headerlink" title="3. VQSR or hardFilter"></a>3. VQSR or hardFilter</h1><h2 id="3-1-VQSR"><a href="#3-1-VQSR" class="headerlink" title="3.1 VQSR"></a>3.1 VQSR</h2><p>#SNP calling</p><h1 id="rescource-文件需要先index，参考文件尽量全，最后三行的文件都是输出"><a href="#rescource-文件需要先index，参考文件尽量全，最后三行的文件都是输出" class="headerlink" title="rescource 文件需要先index，参考文件尽量全，最后三行的文件都是输出"></a>rescource 文件需要先index，参考文件尽量全，最后三行的文件都是输出</h1><h1 id="步骤1-4"><a href="#步骤1-4" class="headerlink" title="步骤1-4"></a>步骤1-4</h1><p>$ time gatk VariantRecalibrator -R &#x2F;path&#x2F;to&#x2F;hg38.fa -V 19P0126636WES.HC.vcf <br>-resource:hapmap,known&#x3D;false,training&#x3D;true,truth&#x3D;true,prior&#x3D;15.0 &#x2F;gatkdoc&#x2F;hapmap_3.3.hg38.vcf <br>-resource:omini,known&#x3D;false,training&#x3D;true,truth&#x3D;false,prior&#x3D;12.0 &#x2F;gatkdoc&#x2F;resources_broad_hg38_v0_1000G_omni2.5.hg38.vcf <br>-resource:1000G,known&#x3D;false,training&#x3D;true,truth&#x3D;false,prior&#x3D;10.0 &#x2F;gatkdoc&#x2F;resources_broad_hg38_v0_1000G_phase1.snps.high_confidence.hg38.vcf <br>-resource:dbsnp,known&#x3D;true,training&#x3D;false,truth&#x3D;false,prior&#x3D;2.0 &#x2F;gatkdoc&#x2F;resources_broad_hg38_v0_Homo_sapiens_assembly38.dbsnp138.vcf <br>-an DP -an QD -an FS -an SOR -an ReadPosRankSum -an MQRankSum -mode SNP -tranche 100.0 <br>-tranche 99.9 -tranche 99.0 -tranche 95.0 -tranche 90.0 <br>-O 19P0126636WES.snp.recal <br>–tranches-file 19P0126636WES.snp.tranches <br>–rscript-file 19P0126636WES.snp.plots.R</p><h1 id="步骤5"><a href="#步骤5" class="headerlink" title="步骤5"></a>步骤5</h1><p>$time gatk ApplyVQSR -R &#x2F;path&#x2F;to&#x2F;hg38.fa -V 19P0126636WES.HC.vcf <br>–ts-filter-level 99.0 –tranches-file 19P0126636WES.snp.tranches <br>–recal-file 19P0126636WES.snp.recal <br>-mode SNP<br>-O 19P0126636WES.snps.VQSR.vcf.gz</p><h2 id="查看数据文件"><a href="#查看数据文件" class="headerlink" title="查看数据文件"></a>查看数据文件</h2><p>$ cat 19P0126636WES.snp.tranches</p><h1 id="Variant-quality-score-tranches-file"><a href="#Variant-quality-score-tranches-file" class="headerlink" title="Variant quality score tranches file"></a>Variant quality score tranches file</h1><h1 id="Version-number-5"><a href="#Version-number-5" class="headerlink" title="Version number 5"></a>Version number 5</h1><p>targetTruthSensitivity,numKnown,numNovel,knownTiTv,novelTiTv,minVQSLod,filterName,model,accessibleTruthSites,callsAtTruthSites,truthSensitivity<br>90.00,1096434,69773,2.1008,1.6731,5.6910,VQSRTrancheSNP0.00to90.00,SNP,665207,598687,0.9000<br>95.00,1200002,98879,2.0923,1.6863,5.0278,VQSRTrancheSNP90.00to95.00,SNP,665207,631946,0.9500<br>99.00,1285374,122947,2.0888,1.6682,3.0695,VQSRTrancheSNP95.00to99.00,SNP,665207,658554,0.9900<br>99.90,1320241,151100,2.0868,1.6411,-1.4500,VQSRTrancheSNP99.00to99.90,SNP,665207,664541,0.9990<br>100.00,1334104,169658,2.0828,1.5982,-1179.7969,VQSRTrancheSNP99.90to100.00,SNP,665207,665207,1.0000</p><ul><li>-tranche默认是输出[100,99.9,99.0,90.0]4个tranche阈值的统计结果，如果想看其他阈值的结果，需要自行加上；结果就是看19P0126636WES.snp.tranches，而19P0126636WES.snp.recal文件则是用于ApplyVQSR的</li></ul><h3 id="INDEL-calling"><a href="#INDEL-calling" class="headerlink" title="INDEL calling"></a>INDEL calling</h3><p>#加了–max-gaussians 6用于设定Gaussians（clusters of variants that have similar properties）的数目，即减少聚类的组数，从而使得每个组的变异位点数目达到要求<br>$time gatk VariantRecalibrator -R &#x2F;path&#x2F;to&#x2F;hg38.fa -V 19P0126636WES.snps.VQSR.vcf.gz <br>-resource:mills,known&#x3D;true,training&#x3D;true,truth&#x3D;true,prior&#x3D;12.0 &#x2F;gatkdoc&#x2F;resources_broad_hg38_v0_Mills_and_1000G_gold_standard.indels.hg38.vcf <br>-an DP -an QD -an FS -an SOR -an ReadPosRankSum -an MQRankSum <br>-mode INDEL –max-gaussians 6 <br>–rscript-file 19P0126636WES_L1.snp.indel.plots.R <br>–tranches-file 19P0126636WES.snp.indel.tranches <br>-O data&#x2F;19P0126636WES.snp.indel.recal</p><p>$ time gatk ApplyVQSR -R &#x2F;path&#x2F;to&#x2F;hg38.fa -V data&#x2F;19P0126636WES.snps.VQSR.vcf.gz <br>–ts-filter-level 99.0 <br>–tranches-file 19P0126636WES.snp.indel.tranches –recal-file 19P0126636WES.snp.indel.recal <br>-mode INDEL <br>-O 19P0126636WES.VQSR.vcf.gz<br>（上面这个就是我们千辛万苦想得到的文件啦！）</p><p>VQSR大概步骤：</p><ol><li>GATK认为VQSR比根据各种annotations进行hard-filtering过滤要好，减少了人为阈值的局限性，避免了一刀切的弊端，从而在sensitivity和specificity之间达到一定的平衡</li><li>VQSR根据机器学习算法从highly validated变异位点数据集（每个位点的annotation profile，一般使用5-8个annotation）中获取到good variants&#x2F;bad variants</li><li>根据上述的位点从我们自己数据集中挑选出一个变异子集（probably true positives）来建模训练，获得一个可识别good variants的模型；bad variants的模型也是如此获得</li><li>然后根据上述获得的模型，对自己数据集的每个变异位点进行一个总的打分</li><li>最后根据设定的sensitivity阈值对变异位点进行过滤</li></ol><p>按照官方教程，<br>SNP的VQSR过滤，选用的resource datasets为：</p><ul><li>HapMap，hapmap_3.3.hg38.vcf.gz，truth&#x3D;true表示VQSR将这个数据集中的变异位点作为真位点true sites，training&#x3D;true表示VQSR将true sites用于训练recalibration model，并赋予这些变异位点prior likelihood值为Q15 (96.84%)</li><li>Omni，1000G_omni2.5.hg38.vcf.gz，truth&#x3D;true，training&#x3D;false（文档中写着是true，参数建议中写着的是false。。。我就按照参数上的来了），Q12 (93.69%)</li><li>1000G，1000G_phase1.snps.high_confidence.hg38.vcf.gz，truth&#x3D;false表示VQSR考虑到在1000G数据集中的不仅包含了true variants还有false positives，training&#x3D;true，Q10 (90%)</li><li>dbSNP，dbsnp_146.hg38.vcf.gz&#x2F;dbsnp_138.hg38.vcf.gz，truth&#x3D;false表示VQSR未将dbSNP数据集中的位点作为可信数据集，training&#x3D;false表示不用于训练数据集，known&#x3D;true表示stratify output metrics such as Ti&#x2F;Tv ratio by whether variants are present in dbsnp or not，Q2 (36.90%)</li></ul><p>INDEL的VQSR过滤，选用的resource datasets为：</p><ul><li>Mills，Mills_and_1000G_gold_standard.indels.hg38.vcf.gz，truth&#x3D;true，training&#x3D;true，Q12 (93.69%)</li><li>dbSNP，dbsnp_146.hg38.vcf.gz&#x2F;dbsnp_138.hg38.vcf.gz，truth&#x3D;false，training&#x3D;false，known&#x3D;true，Q2 (36.90%)</li></ul><h2 id="3-2-gatk-VariantFiltration-O-test-snp-fil-vcf-temp-V-test-snp-vcf-–filter-expression-‘QUAL-30-0-QD-2-0-FS-60-0-SOR-4-0’-–filter-name-lowQualFilter-–cluster-window-size-10-–cluster-size-3-–missing-values-evaluate-as-failing"><a href="#3-2-gatk-VariantFiltration-O-test-snp-fil-vcf-temp-V-test-snp-vcf-–filter-expression-‘QUAL-30-0-QD-2-0-FS-60-0-SOR-4-0’-–filter-name-lowQualFilter-–cluster-window-size-10-–cluster-size-3-–missing-values-evaluate-as-failing" class="headerlink" title="3.2 gatk VariantFiltration -O test.snp.fil.vcf.temp -V test.snp.vcf –filter-expression ‘QUAL &lt; 30.0 || QD &lt; 2.0 || FS &gt; 60.0 ||  SOR &gt; 4.0’ –filter-name lowQualFilter –cluster-window-size 10  –cluster-size 3 –missing-values-evaluate-as-failing"></a>3.2 gatk VariantFiltration -O test.snp.fil.vcf.temp -V test.snp.vcf –filter-expression ‘QUAL &lt; 30.0 || QD &lt; 2.0 || FS &gt; 60.0 ||  SOR &gt; 4.0’ –filter-name lowQualFilter –cluster-window-size 10  –cluster-size 3 –missing-values-evaluate-as-failing</h2><h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><p>-O 输出filt.vcf文件<br>-V 输入vcf文件<br>–filter-expression 过滤条件, VCF INFO 信息<br>–cluster-window-size 以10个碱基为一个窗口<br>–cluster-size 10个碱基为窗口，若存在3以上个则过滤<br>–filter-name 被过滤掉的SNP不会删除，而是给一个标签， 比如 Filter<br>–missing-values-evaluate-as-failing 当筛选标准比较多的时候，可能有一些位点没有筛选条件当中的一条或几条，例如下面的这个表达式；QUAL &lt; 30.0 || QD &lt; 2.0 || FS &gt; 60.0 || MQ &lt; 40.0 || HaplotypeScore &gt; 13.0 并不一定所有位点都有这些信息，这种情况下GATK运行的时候会报很多WARNING信息，用这个参数可以把这些缺少某些FLAG的位点也给标记成没有通过筛选的。</p><h1 id="4-annovar"><a href="#4-annovar" class="headerlink" title="4. annovar"></a>4. annovar</h1><p>################<br>##4.2 ANNOVOR<br>################<br>###annovar database download<br>#gene-based<br>.&#x2F;annotate_variation.pl -buildver hg19 -downdb -webfrom annovar refGene humandb ## RefSeq does not have mitochondria gene definition<br>.&#x2F;annotate_variation.pl -buildver hg19 -downdb -webfrom annovar knownGene humandb ## UCSC Known Gene<br>.&#x2F;annotate_variation.pl -buildver hg19 -downdb -webfrom annovar ensGene humandb # Ensembl Gene<br>.&#x2F;annotate_variation.pl -build hg19 -downdb wgEncodeGencodeBasicV19  humandb #pass</p><p>#region-based<br>.&#x2F;annotate_variation.pl -buildver hg19 -downdb phastConsElements46way humandb&#x2F; # Conserved by 46-way<br>.&#x2F;annotate_variation.pl -buildver hg19 -downdb phastConsElements100way humandb&#x2F; # by 100-way alignment<br>.&#x2F;annotate_variation.pl -build hg19 -downdb tfbsConsSites humandb&#x2F; # Transcription factor binding site annotation<br>.&#x2F;annotate_variation.pl -buildver hg19 -downdb cytoBand humandb&#x2F; # represent cytogenetic bands<br>.&#x2F;annotate_variation.pl -build hg19 -downdb wgRna humandb&#x2F; # Identify variants disrupting microRNAs and snoRNAs<br>.&#x2F;annotate_variation.pl -build hg19 -downdb targetScanS humandb&#x2F; # Identify variants disrupting predicted microRNA binding sites<br>.&#x2F;annotate_variation.pl -buildver hg19 -downdb genomicSuperDups humandb&#x2F; # Identify variants located in segmental duplications<br>.&#x2F;annotate_variation.pl -build hg19 -downdb dgvMerged humandb&#x2F; # Identify previously reported structural variants in DGV (Database of Genomic Variants). deletions and duplications<br>.&#x2F;annotate_variation.pl -buildver hg19 -downdb gwasCatalog humandb&#x2F; # Identify variants reported in previously published GWAS</p><p>#now only for hg18. Identify variants in ENCODE annotated regions (transcribed regions, H3K4Me1 regions, H3K4Me3 regions, H3K27Ac regions, DNaseI hypersensitivity regions, transcription factor ChIP-Seq regions, etc)<br>.&#x2F;annotate_variation.pl -downdb wgEncodeCaltechRnaSeqRawSignalRep1Gm12878CellLongpolyaBb12x75 humandb&#x2F;<br>.&#x2F;annotate_variation.pl -downdb wgEncodeBroadChipSeqPeaksGm12878H3k4me1 humandb&#x2F;<br>.&#x2F;annotate_variation.pl -downdb wgEncodeRegDnaseClustered humandb&#x2F;<br>.&#x2F;annotate_variation.pl -downdb wgEncodeRegTfbsClustered humandb&#x2F;<br>.&#x2F;annotate_variation.pl -downdb wgEncodeBroadHmmGm12878HMM humandb&#x2F; #Identify non-coding variants that disrupt enhancers, repressors, promoters<br>.&#x2F;annotate_variation.pl -downdb wgEncodeUwDnaseSeqHotspotsRep2Gm12878 humandb&#x2F; #Identify variants in other genomic regions annotated with other functions</p><p>#filter-based<br>.&#x2F;annotate_variation.pl -buildver hg19 -downdb 1000g2015aug humandb&#x2F;<br>.&#x2F;annotate_variation.pl -buildver hg19 -downdb -webfrom annovar avsnp150  humandb&#x2F;<br>.&#x2F;annotate_variation.pl  -build hg19 -downdb -webfrom annovar popfreq_all humandb&#x2F; #?? PopFreqMax 1000G2012APR_ALL 1000G2012APR_AFR 1000G2012APR_AMR 1000G2012APR_ASN 1000G2012APR_EUR ESP6500si_ALL ESP6500si_AA ESP6500si_EA CG46.<br>.&#x2F;annotate_variation.pl  -build hg19 -downdb -webfrom annovar nci60 humandb&#x2F;<br>.&#x2F;annotate_variation.pl  -build hg19 -downdb -webfrom annovar popfreq_max humandb&#x2F; </p><p>.&#x2F;annotate_variation.pl -buildver hg19 -downdb -webfrom annovar dbnsfp35a humandb<br>.&#x2F;annotate_variation.pl -buildver hg19 -downdb -webfrom annovar dbnsfp31a_interpro humandb<br>.&#x2F;annotate_variation.pl -buildver hg19 -downdb -webfrom annovar dbscsnv11 humandb<br>.&#x2F;annotate_variation.pl -downdb -buildver hg19 -webfrom annovar gerp++gt2 humandb&#x2F;</p><p>.&#x2F;annotate_variation.pl -buildver hg19 -downdb -webfrom annovar esp6500siv2_all humandb&#x2F;<br>.&#x2F;annotate_variation.pl -buildver hg19 -downdb -webfrom annovar esp6500siv2_aa humandb&#x2F;<br>.&#x2F;annotate_variation.pl -buildver hg19 -downdb -webfrom annovar esp6500siv2_ea humandb&#x2F;<br>.&#x2F;annotate_variation.pl -buildver hg19 -downdb -webfrom annovar clinvar_20200316 humandb<br>或者 <a href="ftp://ftp.ncbi.nlm.nih.gov/pub/clinvar/">ftp://ftp.ncbi.nlm.nih.gov/pub/clinvar/</a> # <a href="ftp://ftp.ncbi.nlm.nih.gov/pub/clinvar/vcf_GRCh37//weekly/clinvar_20220115.vcf.gz">ftp://ftp.ncbi.nlm.nih.gov/pub/clinvar/vcf_GRCh37//weekly/clinvar_20220115.vcf.gz</a></p><p>.&#x2F;annotate_variation.pl -buildver hg19 -downdb -webfrom annovar cadd13gt10 humandb&#x2F;<br>.&#x2F;annotate_variation.pl -buildver hg19 -downdb -webfrom annovar cosmic70 humandb&#x2F;</p><p>.&#x2F;annotate_variation.pl -buildver hg19 -downdb -webfrom annovar exac03 humandb&#x2F;<br>.&#x2F;annotate_variation.pl -buildver hg19 -downdb -webfrom annovar exac03nontcga humandb&#x2F;<br>.&#x2F;annotate_variation.pl -buildver hg19 -downdb -webfrom annovar exac03nonpsych humandb&#x2F;<br>.&#x2F;annotate_variation.pl -buildver hg19 -downdb -webfrom annovar kaviar_20150923 humandb&#x2F;<br>.&#x2F;annotate_variation.pl -buildver hg19 -downdb -webfrom annovar hrcr1 humandb&#x2F;<br>.&#x2F;annotate_variation.pl -buildver hg19 -downdb -webfrom annovar intervar_20180118 humandb&#x2F;</p><p>.&#x2F;annotate_variation.pl -buildver hg19 -downdb -webfrom annovar mitimpact24 humandb&#x2F;</p><p>perl ..&#x2F;prepare_annovar_user.pl -dbtype cosmic CosmicMutantExport.tsv  -vcf CosmicCodingMuts.vcf &gt; hg38_cosmic91.txt<br>perl ..&#x2F;prepare_annovar_user.pl -dbtype cosmic CosmicNCV.tsv  -vcf CosmicNonCodingVariants.vcf &gt; hg38_cosmic91.txt.noncoding</p><p>cosmic,clinvar</p><p>&#x2F;scratch&#x2F;cgg&#x2F;software&#x2F;annovar&#x2F;2014Jul14&#x2F;table_annovar.pl vcf.avi &#x2F;scratch&#x2F;cgg&#x2F;software&#x2F;annovar&#x2F;2014Jul14&#x2F;humandb&#x2F; -buildver hg19 -out myanno2 -remove -protocol refGene,cytoBand,genomicSuperDups,dgvMerged,popfreq_all,snp138,ljb23_all,caddgt10,cosmic68,clinvar_20140702,gwasCatalog,phastConsElements100way,tfbsConsSites,wgRna,targetScanS  -operation g,r,r,r,f,f,f,f,f,f,r,r,r,r,r -nastring . -csvout</p><p>#cg69<br>#cg46<br>nci60<br>popfreq_all<br>gerp++elem<br>gerp++gt2<br>####<br>1.gene-based<br>    refGene;knownGene;ensGene;<br>2.region-based<br>    phastConsElements46way;phastConsElements100way;tfbsConsSites;cytoBand;wgRna;genomicSuperDups;</p>]]></content>
    
    
    <categories>
      
      <category>二代测序流程</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>1. Linux 常用命令</title>
    <link href="/2024/01/22/1.linuxCommandLine/"/>
    <url>/2024/01/22/1.linuxCommandLine/</url>
    
    <content type="html"><![CDATA[<h1 id="基础知识点"><a href="#基础知识点" class="headerlink" title="基础知识点"></a>基础知识点</h1><ol><li>Linux大小写敏感</li><li>文件名最多256个字符，包括数字、.、_、-等</li><li>文件名前带.表示隐藏文件</li><li>在配置文件中，#表示注释。修改配置文件时，尽量不要删除，可以使用#注释掉。</li><li>Linux是继承性的多用户操作系统，个人设定（配置文件）存放在个人主目录下。</li><li>整个系统范围的设定一般放在&#x2F;etc下。</li><li>在处理不同操作系统下的文件时，需要注意换行符：</li></ol><table><thead><tr><th>操作系统</th><th>换行符</th></tr></thead><tbody><tr><td>Windows</td><td>\r\n，即回车加换行</td></tr><tr><td>类 Unix</td><td>\n，即换行</td></tr><tr><td>Mac</td><td>\r，即回车</td></tr></tbody></table><p>常见情况如下：</p><ol><li>在类Unix系统或Mac系统中编辑的文件，在Windows记事本中多行文字会变成一行（但是有些智能编辑器会自动识别不同系统的换行符，并进行转换，如UE、Notepad++）。</li><li>在Windows记事本中编辑的文件，在其他系统中会多显示一个控制字符^M（在Linux中，回车符\r会作为控制字符^M显示）。</li></ol><h1 id="Linux-常用命令汇总"><a href="#Linux-常用命令汇总" class="headerlink" title="Linux 常用命令汇总"></a>Linux 常用命令汇总</h1><h2 id="文件常用命令"><a href="#文件常用命令" class="headerlink" title="文件常用命令"></a>文件常用命令</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">touch</span> 创建文件<br><br><span class="hljs-built_in">cp</span> file1 file2    将file1拷贝成file2<br><span class="hljs-built_in">cp</span> /usr/file2 ./  将/usr目录下的文件file2拷到当前目录下<br><span class="hljs-built_in">cp</span> -i    覆盖相同名称文件前先询问用户<br><span class="hljs-built_in">cp</span> -R    递归拷贝，即拷贝时将所有目录一并拷贝<br><span class="hljs-built_in">cp</span> -p    可以保持源文件的时间属性。否则新文件为当前时间<br><span class="hljs-built_in">cp</span> -rfp  所有目录，强制，时间<br><br><span class="hljs-built_in">mv</span> file1 file2      将file1改名为file2<br><span class="hljs-built_in">mv</span> ./test /sdb/cgg/ 将文件<span class="hljs-built_in">test</span>移至/sdb/cgg目录下<br><br><span class="hljs-built_in">rm</span> file1 file2 file3  删除三个文件<br><span class="hljs-built_in">rm</span> *                  删除当前目录下所有文件（目录不删除）<br><span class="hljs-built_in">rm</span> -f   强制删除文件，删除时，不提出任何警告讯息<br><span class="hljs-built_in">rm</span> -i   删除文件之前均会询问是否真要删除 **强烈建议将这个参数输入到环境变量中 <span class="hljs-built_in">alias</span> <span class="hljs-built_in">rm</span>=<span class="hljs-string">&#x27;rm -i&#x27;</span>**<br><span class="hljs-built_in">rm</span> -r   递归式的删除，即逐级删除目录下的子目录。<br><br><span class="hljs-built_in">ls</span>      显示当前目录中所有文件。<br><span class="hljs-built_in">ls</span> /usr/bin     显示/usr/bin目录下的文件<br><span class="hljs-built_in">ls</span> -a /home/cgg 显示/home/cgg目录下所有的文件和目录，包括<span class="hljs-string">&quot;.&quot;</span>的文件<br><br>find /home/cgg -name example.txt 以文件名查找<br><span class="hljs-built_in">ln</span>    创建链接文件硬链接<br><span class="hljs-built_in">ln</span> -s file1 file2 创建了一个名为file2的符号软链接，指向file1。<br><br>less -S example.txt 分列显示文件内容<br>gunzip -c example.gz | less 无需解压，就可以查看example.gz文件<br>more example.txt 显示文件内容<br><span class="hljs-built_in">cat</span> example.txt  显示文件内容<br><br><span class="hljs-built_in">head</span> -5 example.txt   查看example.txt的前5行。<br><span class="hljs-built_in">tail</span> -5 example.txt         查看文件example.txt的最后5行<br>sed -n <span class="hljs-string">&#x27;5,10p&#x27;</span> example.txt  只查看文件的第5行到第10行。<br>grep -n mrna UCSC.list  找出文件UCSC.list中含有mrna字段的行<br><br><span class="hljs-built_in">sort</span> 排序<br><span class="hljs-built_in">uniq</span> 删除重复行<br><span class="hljs-built_in">wc</span> -l test.txt 统计文件中的行数<br><span class="hljs-built_in">wc</span> -c test.txt 统计文件中的字符数<br><span class="hljs-built_in">wc</span> -w test.txt 统计文件中的单词数<br><span class="hljs-built_in">split</span> -b 30k UCSC.list TEST  将文件UCSC.list拆分前缀为TEST的文件，每份30k<br><span class="hljs-built_in">cut</span> -f 1-2 -d <span class="hljs-string">&#x27;,&#x27;</span> UCSC.list  以<span class="hljs-string">&quot;,&quot;</span>为分隔符，取文件的第一列和第二列<br><br><span class="hljs-built_in">chmod</span> 755 example.txt 修改文件权限（r4 w2 x1）<br><span class="hljs-built_in">chmod</span> g+rw  file   增加文件组内可读写的权限<br><span class="hljs-built_in">chmod</span> o=rx  file   更改文件的权限，使其他用户可读可执行<br><span class="hljs-built_in">chmod</span> -R  以递归的方式<br><span class="hljs-built_in">chgrp</span> 改变文件或目录所属的用户组<br><span class="hljs-built_in">chown</span> -R soft:bgi genome/ 将genome目录下所有文件及文件的所有者及变成bgi组的soft用户。<br></code></pre></td></tr></table></figure><h2 id="目录常用命令"><a href="#目录常用命令" class="headerlink" title="目录常用命令"></a>目录常用命令</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> .. 切换至上一层目录<br><span class="hljs-built_in">cd</span> /  切换至根目录<br><span class="hljs-built_in">cd</span> /usr/bin  切换至/usr/bin目录<br><span class="hljs-built_in">cd</span> 或者 <span class="hljs-built_in">cd</span> ~        切换到当前用户的主目录下<br><br><span class="hljs-built_in">mkdir</span> data       在当前目录下建立子目录data<br><span class="hljs-built_in">mkdir</span> /usr/data  在/usr/目录下建立子目录data，此时/usr目录必须已经存在<br><span class="hljs-built_in">mkdir</span> -p /usr/data  建立目录/usr/data，如果/usr目录不存在，直接建立<br><br><span class="hljs-built_in">rm</span> -rf tmp 删除非空目录<br><br>tar -cf bin.tar /usr/bin 将/usr/bin目录下所有文件打包成bin.tar<br>tar -xf bin.tar       提出bin.tar包里所有文件<br>tar -tvf bin.tar      给出bin包里的文件列表，并不解压缩<br>tar -zxvf bin.tar.gz  解压bin.tar.gz文件<br>tar -jxvf bin.tar.bz2 解压bin.tar.bz2文件<br>gzip 压缩<br>gunzip 解压缩<br>gunzip -c example.gz | less 无需解压，就可以查看example.gz文件<br>unzip 压缩的文件一般后缀为.zip<br>compress 压缩后的文件会加<br><br><span class="hljs-built_in">pwd</span> 显示用户当前所在的全路径<br></code></pre></td></tr></table></figure><h2 id="磁盘及系统管理"><a href="#磁盘及系统管理" class="headerlink" title="磁盘及系统管理"></a>磁盘及系统管理</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs bash">hostname  查看主机名<br><span class="hljs-built_in">date</span> -R   查看系统时间<br><span class="hljs-built_in">uname</span> -a  查看kernel的版本<br><span class="hljs-built_in">cat</span> /etc/issue  查看linux的发行版本<br>shutdown -h now 关闭系统<br>shutdown -r now 重启<br><span class="hljs-built_in">logout</span>    注销<br><br>passwd user1 修改用户user1的密码,然后输入两次新密码即可<br><br><span class="hljs-built_in">df</span> 检查文件系统的磁盘空间占用情况<br><span class="hljs-built_in">du</span> 显示该目录占用文件系统数据块(1024字节)的情况<br>free 查看当前系统内存的使用情况<br>top  即时显示进程动态<br><span class="hljs-built_in">history</span> 查询历史命令记录<br>ps   显示用户的运行程序或系统程序<br><span class="hljs-built_in">kill</span> 杀掉某一进程<br></code></pre></td></tr></table></figure><h2 id="软件安装"><a href="#软件安装" class="headerlink" title="软件安装"></a>软件安装</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">tar -zxvf software.tar.gz<br><span class="hljs-built_in">cd</span> software   进入文件夹<br>./configure   配置<br>make          调用make命令进行编译<br>make install  安装可执行程序<br>make clean    删除安装时产生的临时文件<br>make uninstall 卸载软件<br></code></pre></td></tr></table></figure><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs bash">&gt;file   将结果输出到文件file中，如果该文件原本就存在，则该文件原有的内容会被**删除**。<br>&gt;&gt;file  将结果输出到文件file中，如果原文件存在，则附加在原文件后面，原文件的内容**不会被清除**。<br>| 管道符<br><br>screen  用于多重视窗管理程序<br>-A 　        将所有的视窗都调整为目前终端机的大小。<br>-d&lt;作业名称&gt;  将指定的screen作业离线。<br>-h&lt;行数&gt;     指定视窗的缓冲区行数。<br>-m 　        即使目前已在作业中的screen作业，仍强制建立新的screen作业。<br>-r&lt;作业名称&gt;  恢复离线的screen作业。<br>-s\&lt;shell\&gt;  指定建立新视窗时，所要执行的shell。<br>-S&lt;作业名称&gt;  指定screen作业的名称。<br>-R      先试图恢复离线的作业。若找不到离线的作业，即建立新的screen作业。<br>-v      显示版本信息。<br>-x      恢复之前离线的screen作业。<br>-<span class="hljs-built_in">ls</span>或--list  显示目前所有的screen作业。<br>-wipe        检查目前所有的screen作业，并删除已经无法使用的screen作业。<br></code></pre></td></tr></table></figure><h1 id="Linux-常用命令详解"><a href="#Linux-常用命令详解" class="headerlink" title="Linux 常用命令详解"></a>Linux 常用命令详解</h1><h2 id="1-文件的cp、rm和mv命令"><a href="#1-文件的cp、rm和mv命令" class="headerlink" title="1. 文件的cp、rm和mv命令"></a>1. 文件的cp、rm和mv命令</h2><h3 id="cp-复制"><a href="#cp-复制" class="headerlink" title="cp 复制"></a>cp 复制</h3><ul><li>说明:该命令的功能是将指定的文件或目录拷贝到另一文件或目录中。可以使用通配符拷贝具有同一特征的所有文件。</li><li>语法: cp [参数] 源文件或目录 目标文件或目录</li><li>参数:<br>-a  该选项通常在拷贝目录时使用。它保留链接、文件属性，并递归地拷贝目录，其作用等于dpR选项的组合。<br>-d  拷贝时保留链接。<br>-f  删除已经存在的目标文件而不提示。<br>-i  和f选项相反，在覆盖目标文件之前将给出提示要求用户确认。回答y时目标文件将被覆盖，是交互式拷贝。为防止用户在不经意的情况下用cp命令破坏另一个文件，如用户指定的目标文件名已存在，用cp命令拷贝文件后，这个文件就会被新源文件覆盖，因此，建议用户在使用cp命令拷贝文件时，最好使用i选项。<br>-p  此时cp除复制源文件的内容外，还将把其修改时间和访问权限也复制到新文件中。<br>-r  若给出的源文件是一目录文件，此时cp将递归复制该目录下所有的子目录和文件。此时目标文件必须为一个目录名。<br>-l  不作拷贝，只是链接文件。</li><li>例子:<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cp</span> file1 file2    将file1拷贝成file2<br><span class="hljs-built_in">cp</span> /usr/file2 ./  将/usr目录下的文件file2拷到当前目录下<br><span class="hljs-built_in">cp</span> –i      覆盖相同名称文件前先询问用户<br><span class="hljs-built_in">cp</span> –R      递归拷贝，即拷贝时将所有目录一并拷贝<br><span class="hljs-built_in">cp</span> -p      可以保持源文件的时间属性。否则新文件为当前时间<br><span class="hljs-built_in">cp</span> -rfp    所有目录，强制，时间<br><span class="hljs-built_in">cp</span> --<span class="hljs-built_in">help</span>  查阅命令详细使用信息<br></code></pre></td></tr></table></figure></li></ul><h3 id="mv-删除"><a href="#mv-删除" class="headerlink" title="mv 删除"></a>mv 删除</h3><ul><li>说明:用户可以使用mv命令来为文件或目录改名或将文件由一个目录移入另一个目录中。mv命令中第二个参数类型的不同(是目标文件还是目标目录)，mv命令将文件重命名或将其移至一个新的目录中。当第二个参数类型是文件时，mv命令完成文件重命名，此时，源文件只能有一个(也可以是源目录名)，它将所给的源文件或目录重命名为给定的目标文件名。当第二个参数是已存在的目录名称时，源文件或目录参数可以有多个，mv命令将各参数指定的源文件均移至目标目录中。在跨文件系统移动文件时，mv先拷贝，再将原有文件删除，而链至该文件的链接也将丢失。</li><li>语法:mv [参数] 源文件或目录 目标文件或目录</li><li>参数:<br>-i  交互方式操作。如果mv操作将导致对已存在的目标文件的覆盖，此时系统询问是否重写，要求用户回答y或n，这样可以避免误覆盖文件。<br>-f  强制执行，在mv操作要覆盖某已有的目标文件时不给任何指示，指定此选项后，i选项将不再起作用。如果所给目标文件(不是目录)已存在，此时该文件的内容将被新文件覆盖。为防止用户用mv命令破坏另一个文件，使用mv命令移动文件时，最好使用i选项。</li><li>例子:<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">mv</span> file1 file2      将file1改名为file2<br><span class="hljs-built_in">mv</span>./test /sdb/cgg/  将文件<span class="hljs-built_in">test</span>移至/sdb/cgg目录下<br><span class="hljs-built_in">mv</span> -<span class="hljs-built_in">help</span>   查阅命令详细使用信息<br></code></pre></td></tr></table></figure></li></ul><h3 id="rm-移动"><a href="#rm-移动" class="headerlink" title="rm 移动"></a>rm 移动</h3><ul><li>说明:用户可以用rm命令删除不需要的文件。该命令可删除一个目录中的一个或多个文件或目录，它也可以将某个目录及其下的所有文件及子目录均删除。对于链接文件，只是断开链接，原文件保持不变。如果没有使用-r选项，则rm不会删除目录。</li><li>语法:rm [参数] 文件…</li><li>参数:<br>-f  忽略不存在的文件，不给任何提示。<br>-r  将列出的全部目录和子目录逐级递归地删除。<br>-i  进行交互式删除。文件被删除后是不能被恢复的。为防止误删有用文件，可以使用i选项来逐个确认要删除的文件。如果用户输入y，文件将被删除。否则文件不会删除。</li><li>例子:<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">rm</span> file1 file2 file3  删除三个文件<br><span class="hljs-built_in">rm</span> *                  删除当前目录下所有文件(目录不删除)<br><span class="hljs-built_in">rm</span> –f   强制删除文件，删除时，不提出任何警告讯息<br><span class="hljs-built_in">rm</span> -i   删除文件之前均会询问是否真要删除，y/n指示下一步<br>**强烈建议将这个参数输入到环境变量中 <span class="hljs-built_in">alias</span> <span class="hljs-built_in">rm</span>=\&#x27;<span class="hljs-built_in">rm</span> -i\&#x27;**<br><br><span class="hljs-built_in">rm</span> -r     递回式的删除，即逐级删除目录下的子目录。<br><span class="hljs-built_in">rm</span> -<span class="hljs-built_in">help</span>  查阅命令详细使用信息<br></code></pre></td></tr></table></figure></li></ul><h2 id="2-目录的mkdir、rmdir、cd、pwd及ls命令"><a href="#2-目录的mkdir、rmdir、cd、pwd及ls命令" class="headerlink" title="2.目录的mkdir、rmdir、cd、pwd及ls命令"></a>2.目录的mkdir、rmdir、cd、pwd及ls命令</h2><h3 id="mkdir-创建"><a href="#mkdir-创建" class="headerlink" title="mkdir 创建"></a>mkdir 创建</h3><ul><li>说明:创建一个目录(类似MSDOS下的md命令)。要求创建目录的用户在当前目录中(dir-name的父目录中)具有写权限，并且dirname不能是当前目录中已有的目录或文件名称。</li><li>语法:mkdir [参数] 目录名</li><li>参数:<br>-m  对新建目录设置存取权限。也可以用chmod命令设置。<br>-p  可以是一个路径名称。此时若路径中的某些目录尚不存在，加上此选项后，系统将自动建立好那些尚不存在的目录，即一次可以建立多个目录。</li><li>例子:<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">mkdir</span> data       在当前目录下建立子目录data<br><span class="hljs-built_in">mkdir</span> /usr/data  在/usr/目录下建立子目录data，此时/usr目录必须已经存在。<br></code></pre></td></tr></table></figure></li></ul><h3 id="rmdir-删除"><a href="#rmdir-删除" class="headerlink" title="rmdir 删除"></a>rmdir 删除</h3><ul><li>说明:该命令从一个目录中删除一个或多个子目录项。一个目录被删除之前必须是空的。rm -r dir 命令可代替 rmdir。</li><li>语法:rmdir [参数] 目录名</li><li>参数:<br>-p  递归删除目录，当子目录删除后其父目录为空时，也一同被删除。如果整个路径被删除或者由于某种原因保留部分路径，则系统在标准输出上显示相应的信息。</li></ul><h3 id="cd-更改目录"><a href="#cd-更改目录" class="headerlink" title="cd 更改目录"></a>cd 更改目录</h3><ul><li>说明:该命令将当前目录改变至指定的目录。若没有指定目录，则回到用户的主目录。</li><li>语法:cd [目录名]</li><li>例子:<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> /usr/bin  切换至/usr/bin目录<br><span class="hljs-built_in">cd</span> .. 切换至上一层目录<br><span class="hljs-built_in">cd</span> /  切换至根目录<br><span class="hljs-built_in">cd</span> ~  切换至宿主目录(用户登录时所在的目录)，效果等同于不加指定目录<br></code></pre></td></tr></table></figure></li></ul><h3 id="pwd-命令"><a href="#pwd-命令" class="headerlink" title="pwd 命令"></a>pwd 命令</h3><ul><li>说明:该命令显示用户当前所在的路径，为全路径。</li><li>语法:pwd</li></ul><h3 id="ls-命令"><a href="#ls-命令" class="headerlink" title="ls 命令"></a>ls 命令</h3><ul><li>说明:ls是英文单词list的简写，其功能为列出目录的内容。对于每个目录，该命令将列出其中的所有子目录与文件。对于每个文件，ls将输出其文件名以及所要求的其他信息。默认情况下，输出条目按字母顺序排序。当未给出目录名或是文件名时，就显示当前目录的信息。</li><li>语法:ls [参数] [目录或是文件]</li><li>参数:<br>-a  显示指定目录下所有子目录与文件，包括隐藏文件。<br>-c  按文件的修改时间排序。<br>-F  在文件后面加上类型标识:如果是目录，则在后面加“&#x2F;”，如果是可执行文件，则在后面加“*”，如果是个链接，则在后面加“@”，管道(或FIFO)后面标记“|”，socket文件后面标记“&#x3D;”<br>-L  若指定的名称为一个符号链接文件，则显示链接所指向的文件。<br>-r  按字母逆序或最早优先的顺序显示输出结果。<br>-R  递归式地显示指定目录的各个子目录中的文件。<br>-s  给出每个目录项所用的块数，包括间接块。<br>-t  显示时按修改时间(最近优先)而不是按名字排序。若文件修改时间相同，则按字典顺序。<br>-l  以长格式来显示文件的详细信息。最常用的参数之一。每行列出的信息依次是:文件类型与权限、链接数、文件属主、文件属组、文件大小、建立或最近修改的时间、文件名。用此参数命令显示的信息中，开头是由10个字符构成的字符串，其中第一个字符表示文件类型，它可以是下述类型之一:-普通文件;d目录;l符号链接;b块设备文件;c字符设备文件。后面的9个字符表示文件的访问权限，分为3组，每组3位。对于目录，表示进入权限。第一组表示文件属主的权限，第二组表示同组用户的权限，第三组表示其他用户的权限。每一组的三个字符分别表示对文件的读(r)、写(w)和执行权限(x)。</li><li>例子:<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">ls</span>               显示目前目录中所有文件。<br><span class="hljs-built_in">ls</span> /usr/bin      显示/usr/bin目录下的文件<br><span class="hljs-built_in">ls</span> -a /home/cgg  显示/home/cgg目录下所有的文件和目录，若无此参数，“.”开始的隐藏文件和目录不会显示。此命令显示结果为:<br><br>. ..   .bash_history  .bash_profile  .bashrc  .tsshrc<br><br><span class="hljs-built_in">ls</span> -l file1<br>-rwxr-xr--  1  weiq1  cgg  Aug 8 05:08  file1<br><br>- 第一列是文件的属性:<br> - 第一个字符(-)表示是单纯的文件<br> - 第2-4字符“rwx”表示此文件属主weiq1对文件file1的权利为“可读、可写、可执行”;<br> - 第5-7字符“r-x”表示此用户组cgg内的用户对文件file1的权利为:“可读、不可写、可执行”;<br> - 第8-10字符“r--”表示其他用户对文件file1的权利为“可读、不可写、不可执行”。<br>- 第二列表示文件的链接数为1。<br>- 第三列别是此文件或目录的拥有者是weiq1用户。<br>- 第四列表示文件所有者weiq1用户所属的组是cgg。<br>- 第五列表示文件大小为8byte。<br>- 第六列表示文件的修改日期是8月8日。<br>- 第七列表示文件名为file1。<br></code></pre></td></tr></table></figure></li></ul><h2 id="3-文本查看命令"><a href="#3-文本查看命令" class="headerlink" title="3.文本查看命令"></a>3.文本查看命令</h2><h3 id="less-命令"><a href="#less-命令" class="headerlink" title="less 命令"></a>less 命令</h3><ul><li>说明:less命令的功能几乎和more命令一样，也是用来按页显示文件。此命令可以使用方向键滚动文件。用less命令显示文件时，若需要在文件中往前移动，按b键;要移动到用文件的百分比表示的某位置，则指定一个0到100之间的数，并按p即可。</li><li>语法:less [参数] 文件 参数:</li><li>例子:<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">less -S     分列显示<br>less -<span class="hljs-built_in">help</span>  显示详细说明文档<br>gunzip -c tmp.gz | less 在不解压缩文件的情况下查看其内容，尤其是对于大型压缩文件<br></code></pre></td></tr></table></figure></li></ul><h3 id="more-命令"><a href="#more-命令" class="headerlink" title="more 命令"></a>more 命令</h3><ul><li><p>说明:在终端屏幕按屏显示文本文件，该命令一次显示一屏文本，显示满之后，停下来，并在终端底部打印出“–More–”，系统还将同时显示出已显示文本占全部文本的百分比，若要继续显示，按回车或空格键即可。若要退出，按q或Q。</p></li><li><p>语法:more [参数] 文件</p></li><li><p>参数:<br>-p  显示下一屏之前先清屏。<br>-c  作用同-p基本一样<br>-l  不处理ctrl+l(换页符)。如果没有给出这个选项，则more命令在显示了一个包含有ctrl+l字符的行后将暂停显示，并等待接收命令。<br>-s  文件中连续的空白行压缩成一个空白行显示。</p></li><li><p>例子:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">more -c -5 example.txt 执行该命令后，先清屏，然后将以每五行的方式显示文件example.txt的内容。<br></code></pre></td></tr></table></figure></li></ul><h3 id="cat-命令"><a href="#cat-命令" class="headerlink" title="cat 命令"></a>cat 命令</h3><ul><li><p>说明:该命令功能之一是用来显示文件，它依次读取其后所指文件的内容并将其输出到标准输出。该命令功能之二是用来将两个或多个文件连接起来。</p></li><li><p>语法:cat [参数] 文件</p></li><li><p>参数:<br>-v  用一种特殊形式显示控制字符，LFD与TAB除外。加了-v选项后，-T和-E选项将起作用。<br>-T  将TAB显示为“ù I”。该选项需要与-v选项一起使用。即如果没有使用-v选项，则这个选项将被忽略。<br>-E  在每行的末尾显示一个$符。该选项需要与-v选项一起使用。-A等于-vET。<br>-t  等于-vT。<br>-e  等于-vE。<br>-n  在文件的每行前面显示行号。<br>-b  和-n相似，只不过对于空白行不编号。<br>-s  当遇到有连续两行以上的空白行时，就代换为一行的空白行。</p></li><li><p>例子:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cat</span> -A example.txt   在屏幕上显示出example.txt文件的内容，而且如果文件中含有特殊字符的话，一并显示。<br><span class="hljs-built_in">cat</span> file1 file2 &gt; file3 这样就把文件file1和文件file2的内容合并起来，放入文件file3中(此时在屏幕上并不能直接看到该命令执行后的结果)。<br></code></pre></td></tr></table></figure></li></ul><h3 id="head-命令"><a href="#head-命令" class="headerlink" title="head 命令"></a>head 命令</h3><ul><li>说明:显示指定文件的前若干行。该命令显示每个指定文件的前面n行。如果没有给出n值，缺省设置为10。如果没有指定文件，head就从标准输入读取。</li><li>语法:head [参数] 文件</li><li>参数:<br>-line<br>-n line</li><li>例子:<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">head</span> -5 example.txt  查看example.txt的前5行。<br></code></pre></td></tr></table></figure></li></ul><h3 id="tail-命令"><a href="#tail-命令" class="headerlink" title="tail 命令"></a>tail 命令</h3><ul><li>说明:输出文件内容后面的部分，默认为最后十行。</li><li>语法:tail [参数] 文件</li><li>参数:<br>-n  只显示后面的n行。<br>-c  显示最后几个字节。<br>-f  动态显示，常用于跟踪消息文件。</li><li>例子:<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">tail</span> -5 /etc/passwd        查看文件/etc/passwd的最后5行<br><span class="hljs-built_in">tail</span> -n 5 test.txt         查看text.txt文件的后5行<br><span class="hljs-built_in">tail</span> -f /var/log/messages  动态显示文件/var/log/messages的最后10行<br><span class="hljs-built_in">tail</span> -c 10 test.txt        查看text.txt文件的后10个字节<br></code></pre></td></tr></table></figure></li></ul><h3 id="sed-命令"><a href="#sed-命令" class="headerlink" title="sed 命令"></a>sed 命令</h3><ul><li>说明:此命令功能强大，用法也较复杂，我们这里只给出查看文件中间几行的用法。</li><li>例子:<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sed -n <span class="hljs-string">&#x27;5,10p&#x27;</span> /etc/passwd  只查看文件的第5行到第10行。<br></code></pre></td></tr></table></figure></li></ul><h3 id="grep-命令"><a href="#grep-命令" class="headerlink" title="grep 命令"></a>grep 命令</h3><ul><li>说明:是一过滤器，它可搜索文件并过滤出有某个特征的行。</li><li>语法:grep [参数] 匹配模式 文件</li><li>参数:<br>-n  把所找到的行在行前加上行号列出<br>-v  把不包含匹配模式的行列出</li><li>例子:<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">grep -n mrna UCSC.list  找出文件UCSC.list中含有mrna字段的行，并标注行号输出<br></code></pre></td></tr></table></figure></li></ul><h2 id="4-文本处理命令"><a href="#4-文本处理命令" class="headerlink" title="4.文本处理命令"></a>4.文本处理命令</h2><h3 id="sort-命令"><a href="#sort-命令" class="headerlink" title="sort 命令"></a>sort 命令</h3><ul><li>说明:sort命令的功能是对文件中的各行进行排序，并将结果显示在标准输出上。如不指定输入文件或使用“-”，则表示排序内容来自标准输入。sort排序是根据从输入行抽取的一个或多个关键字进行比较来完成的。排序关键字定义了用来排序的最小的字符序列。默认以整行为关键字按ASCII字符顺序进行排序。</li><li>语法:sort [参数] 文件</li><li>参数:<br>-u  对排序后认为相同的行只留其中一行。<br>-o  输出文件，将排序输出写到输出文件中而不是标准输出，如果输出文件是输入文件之一，sort先将该文件的内容写入一个临时文件，然后再排序和写输出结果。<br>-d  按字典顺序排序，比较时仅字母、数字、空格和制表符有意义。<br>-f  将小写字母与大写字母同等对待。<br>-I  忽略非打印字符。<br>-M  作为月份比较:“JAN”&lt;“FEB”。<br>-r  按逆序输出排序结果。<br>+posl -pos2  指定一个或几个字段作为排序关键字，字段位置从posl开始，到pos2为止(包括posl，不包括pos2)。如不指定pos2，则关键字为从posl到行尾。字段和字符的位置从0开始。<br>-b  在每行中寻找排序关键字时忽略前导的空白(空格和制表符)。<br>-t separator  指定字符separator作为字段分隔符。</li></ul><h3 id="uniq-命令"><a href="#uniq-命令" class="headerlink" title="uniq 命令"></a>uniq 命令</h3><ul><li>说明:uniq命令将文件中的重复行中删除，只留下每条记录的唯一样本。如果输入文件用“-”表示，则从标准输入读取。</li><li>语法:uniq [参数] 文件</li><li>参数:<br>-c  显示输出中，在每行行首加上本行在文件中出现的次数。它可取代-u和-d选项。<br>-d  只显示重复行。<br>-u  只显示文件中不重复的各行。<br>-n  前n个字段与每个字段前的空白一起被忽略。一个字段是一个非空格、非制表符的字符串，彼此由制表符和空格隔开(字段从0开始编号)。<br>+n  前n个字符被忽略，之前的字符被跳过(字符从0开始编号)。-f n与-n相同，这里n是字段数。<br>-s n  与+n相同，这里n是字符数。</li></ul><h3 id="wc-命令"><a href="#wc-命令" class="headerlink" title="wc 命令"></a>wc 命令</h3><ul><li>说明:用来统计给定文件中的字节数、字数、行数。如果没有给出文件名，则从标准输入读取。wc同时也给出所有指定文件的总统计数。字是由空格字符区分开的最大字符串。</li><li>语法:wc [参数] 文件</li><li>参数:<br>-c  统计字节数。<br>-l  统计行数。<br>-w  统计字数。</li></ul><p>这些选项可以组合使用。输出列的顺序和数目不受选项的顺序和数目的影响。总是按下述顺序显示并且每项最多一列:行数、字数、字节数、文件名<br>如果命令行中没有文件名，则输出中不出现文件名。</p><ul><li>例子:<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">wc</span> test.txt    统计test.txt文件，显示结果如下: 35 103 957 test.txt<br><span class="hljs-built_in">wc</span> -l test.txt 统计test.txt文件中的行数，显示结果如下: 35 test.txt<br><span class="hljs-built_in">wc</span> -c test.txt 统计test.txt文件中的字符数，显示结果如下: 957 test.txt<br><span class="hljs-built_in">wc</span> -w test.txt 统计test.txt文件中的单词数，显示结果如下: 103 test.txt<br></code></pre></td></tr></table></figure></li></ul><h3 id="split-命令"><a href="#split-命令" class="headerlink" title="split 命令"></a>split 命令</h3><ul><li><p>说明:将一个文件分割成数个，生成文件依次为前缀aa、前缀ab……默认前缀为x。</p></li><li><p>语法:split [参数] 文件 [前缀]</p></li><li><p>参数:<br>-b SIZE    SIZE值为每一输出文件的大小，单位为byte。SIZE可加入单位:b、k、m。<br>-l NUMBER  NUMBER值为每一输出文件的行数。</p></li><li><p>例子:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">split</span> -b 30k UCSC.list TEST  将文件UCSC.list按每份30k大小进行拆分，并生成前缀为TEST的各拆分文件。<br></code></pre></td></tr></table></figure></li></ul><h3 id="cut-命令"><a href="#cut-命令" class="headerlink" title="cut 命令"></a>cut 命令</h3><ul><li><p>说明:截取文件中的某字段。</p></li><li><p>语法:cut [参数] 文件</p></li><li><p>参数:<br>-c m-n  表示显示每一行的第m个字元到第n个字元。<br>-f m-n  表示显示第 m 栏到第n栏(使用tab分隔)。<br>-d ‘分隔符’  用来定义分隔符(单个字符)，默认为tab键，和-f配合使用。</p></li><li><p>例子:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cut</span> -f 1-2 -d <span class="hljs-string">&#x27;,&#x27;</span> UCSC.list  以“，”为分隔符，取文件UCSC.list的第一列和第二列。<br></code></pre></td></tr></table></figure></li></ul><h3 id="awk-命令"><a href="#awk-命令" class="headerlink" title="awk 命令"></a>awk 命令</h3><ul><li><p>说明:对文件进行信息提取等处理。</p></li><li><p>语法:awk ‘{操作代码}’ 文件</p></li><li><p>例子:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">awk <span class="hljs-string">&#x27;&#123; print &#125;&#x27;</span> /etc/passwd     此命令输出/etc/passwd文件的内容。<br>awk -F:<span class="hljs-string">&quot;:&quot;</span> <span class="hljs-string">&#x27;&#123; print $1 &#125;&#x27;</span> /etc/passwd  使用-F选项来指定<span class="hljs-string">&quot;:&quot;</span>作为字段分隔符，打印出在输入文件中每一行中出现的第一个字段。<br></code></pre></td></tr></table></figure></li></ul><h2 id="5-改变文件或目录的权限命令"><a href="#5-改变文件或目录的权限命令" class="headerlink" title="5.改变文件或目录的权限命令"></a>5.改变文件或目录的权限命令</h2><ul><li><p>Linux&#x2F;Unix 系统中的每个文件和目录都有访问许可权限，用它来确定谁可以通过何种方式对文件和目录进行访问和操作。文件或目录的访问权限分为只读(r)，只写(w)和可执行(x)三种，可用-表示没有权限。有三种不同类型的用户可对文件或目录进行访问:文件所有者(u)、同组用户(g)和其他用户(o)。所有者一般是文件的创建者,所有者可以将文件的访问权限赋予同组用户或系统中的其他用户。</p></li><li><p>每一文件或目录的访问权限都有三组，每组用三位表示，分别为文件属主的读、写和执行权限;与属主同组的用户的读、写和执行权限;系统中其他用户的读、写和执行权限。当用ls -l命令显示文件或目录的详细信息时，最左边的一列为文件的访问权限。例如:</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">ls</span> -l GC_content.pl<br>-rwxx--x-- 1 weiq1 cgg 1437 Feb 25 17:3l GC_content.pl<br></code></pre></td></tr></table></figure><p>  GC_content.pl的属主weiq1有读写及执行权限;与GC_content.pl属主同组cgg的用户只有可执行权限;其他用户也只有可执行权限。<br>  文件的权限及所有者及其属于的用户组都可以用一些命令来改变，下面分别对这些命令加以介绍。</p><h3 id="chmod-命令"><a href="#chmod-命令" class="headerlink" title="chmod 命令"></a>chmod 命令</h3><ul><li>说明:chmod命令用于改变文件或目录的访问权限。用户用它控制文件或目录的访问权限。</li><li>语法:该命令有两种用法。一种是包含字母和操作符表达式的文字设定法;另一种是包含数字的数字设定法。</li><li>1.文字设定法:chmod [用户] [操作] [权限类型] 文件名 用户可是下述字母中的任一个或者它们的组合:<br>  u  表示“用户(user)”，即文件或目录的所有者。<br>  g  表示“同组(group)用户”，即与文件属主有相同组ID的所有用户。o表示“其他(others)用户”。<br>  a  表示“所有(all)用户”，系统默认值。<ul><li>操作可以是:<br>‘+’ 添加某个权限。<br>‘-‘ 取消某个权限。<br>&#x3D;   赋予给定权限并取消其他所有权限(如果有的话)。</li><li>权限类型可用下述字母的任意组合，在一个命令行中可给出多个权限方式，其间用逗号隔开:<br>r  可读。<br>w  可写。<br>x  可执行。<br>u  与文件属主拥有一样的权限。<br>g  与和文件属主同组的用户拥有一样的权限。<br>o  与其他用户拥有一样的权限。</li><li>文件名:以空格分开的要改变权限的文件列表，支持通配符。</li></ul></li><li>例子:<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">chmod</span> g+r,o+r GC_content.pl 使同组和其他用户对文件GC_content.pl增加可读权限。<br><span class="hljs-built_in">chmod</span> g+rw  file   增加文件组内可读写的权限<br><span class="hljs-built_in">chmod</span> o=rx  file   更改文件的权限，使其他用户可读可执行<br></code></pre></td></tr></table></figure></li><li><ol start="2"><li>数字设定法:chmod [ddd] 文件名</li></ol></li></ul><p>数字属性的格式为3个从0到7的八进制数，其代表的用户顺序为(u)(g)(o)。0表示没有权限，1表示可执行权限，2表示可写权限，4表示可读权限，数字可以相加表示权限的累加。</p><ul><li>例子:<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">chmod</span> 755 GC_content.pl 将文件GC_content.pl的权限改为属主可读可写可执行，组内用户及其他用户为可读及可执行。7=4(可执行)+2(可写)+1(可读),5=4(可执行)+1(可读)<br></code></pre></td></tr></table></figure></li><li>参数:<br>-r更改所有的权限，包括子目录及其内文件。</li></ul><h3 id="chgrp-命令"><a href="#chgrp-命令" class="headerlink" title="chgrp 命令"></a>chgrp 命令</h3><ul><li>说明:改变文件或目录所属的用户组。可以是组ID，也可以是组名(见文件&#x2F;etc&#x2F;group)。如果用户不是该文件的属主或超级用户，则不能改变该文件的组。</li><li>语法:chgrp [参数] group filename</li><li>参数:<br>-R  递归式地改变指定目录及其下的所有子目录和文件的属组。</li></ul><h3 id="chown-命令"><a href="#chown-命令" class="headerlink" title="chown 命令"></a>chown 命令</h3><ul><li>说明:更改某个文件或目录的属主和属组。用户及组名可以是名称或ID。注意:普通用户只能将自己的文件或目录改成他人的，而不能进行逆操作。</li><li>语法:chown [参数] 用户或组 文件</li><li>参数:<br>-R  递归式地改变指定目录及其下的所有子目录和文件的拥有者。<br>-v  显示chown命令所做的工作。</li><li>例子:<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">chown</span> -R soft:bgi genome/ 将genome目录下所有文件及文件的所有者及变成bgi组的soft用户。<br></code></pre></td></tr></table></figure></li></ul><h2 id="6-备份与压缩命令"><a href="#6-备份与压缩命令" class="headerlink" title="6.备份与压缩命令"></a>6.备份与压缩命令</h2><h3 id="tar-命令"><a href="#tar-命令" class="headerlink" title="tar 命令"></a>tar 命令</h3><ul><li><p>说明:tar可以为文件和目录创建档案。利用tar，用户可以为某一特定文件创建档案(备份文件)，也可以在档案中改变文件，或者向档案中加入新的文件。tar命令可以把一大堆的文件和目录全部打包成一个文件，以便于网络传输。</p></li><li><p>语法:tar [参数] 文件或者目录</p></li><li><p>参数:<br>-c  创建新的档案文件。如果用户想备份一个目录或是一些文件，就要选择这个选项。<br>-r  把要存档的文件追加到档案文件的末尾。<br>-t  列出档案文件的内容，查看已经备份了哪些文件。<br>-u  更新文件。就是说，用新增的文件取代原备份文件，如果在备份文件中找不到要更新的文件，则把它追加到备份文件的最后。<br>-x  从档案文件中释放文件。<br>-z  用 gzip 来压缩&#x2F;解压缩文件，加上该选项后可以将档案文件进行压缩，但还原时也一定要使用该选项进行解压缩。</p></li><li><p>例子:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">tar -cf bin.tar  /usr/bin 将/usr/bin目录下所有文件打包成bin.tar<br>tar -xf bin.tar       提出bin.tar包里所有文件<br>tar -tvf bin.tar      给出bin包里的文件列表，并不解压缩<br>tar -zxvf bin.tar.gz  解压bin.tar.gz文件<br>tar -jxvf bin.tar.bz2 解压bin.tar.bz2文件<br>tar -<span class="hljs-built_in">help</span>    显示此命令的帮助信息<br></code></pre></td></tr></table></figure></li></ul><h3 id="gzip-gunzip-命令"><a href="#gzip-gunzip-命令" class="headerlink" title="gzip(gunzip)命令"></a>gzip(gunzip)命令</h3><ul><li><p>说明:对文件进行压缩和解压缩的命令。压缩文件可以减少文件大小，这有两个明显的好处:一是可以减少存储空间，二是通过网络传输文件时，可以减少传输的时间。压缩后默认产生后缀为.gz的压缩文件。</p></li><li><p>语法:gzip [参数] 文件名</p></li><li><p>参数:<br>-c  将输出写到标准输出上，并保留原有文件。<br>-d  将压缩文件解压。<br>-l  对每个压缩文件，显示压缩文件的大小、未压缩时大小、压缩比及文件压缩前名字。<br>-r  递归式地查找指定目录并压缩其中的所有文件或者是解压缩。<br>-t  测试，检查压缩文件是否完整。<br>-v  对每一个压缩和解压的文件，显示文件名和压缩比。<br>-f  如果压缩的文件重名，则强制覆盖<br>-num   用指定的数字num调整压缩的速度，-1或–fast表示最快压缩方法(低压缩比)，-9或-<br>-best  表示最慢压缩方法(高压缩比)。系统缺省值为6。</p></li><li><p>例子:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">gzip -l sprot40.dat.gz<br>执行结果:<br>compressed uncompr. ratio uncompressed_name<br>66088434 320673785 79.3% sprot40.dat<br><br>gzip -d sprot40.dat.gz  解压缩文件sprot40.dat.gz<br>gzip -h    显示此命令的帮助信息<br></code></pre></td></tr></table></figure></li></ul><h3 id="unzip-命令"><a href="#unzip-命令" class="headerlink" title="unzip 命令"></a>unzip 命令</h3><ul><li>说明:用MSWindows下的压缩软件winzip压缩的文件一般后缀为.zip，可以用unzip命令解压缩。</li><li>语法:unzip [参数] 压缩文件名.zip</li><li>参数:<br>-x  文件列表解压缩文件，但不包括指定的file文件。<br>-v  查看压缩文件目录，但不解压。<br>-t  测试文件有无损坏，但不解压。<br>-d  [目录]，把压缩文件解到指定目录下。<br>-z  只显示压缩文件的注解。<br>-n  不覆盖已经存在的文件。<br>-o  覆盖已存在的文件且不要求用户确认。<br>-j  不重建文档的目录结构，把所有文件解压到同一目录下。</li></ul><h3 id="compress-命令"><a href="#compress-命令" class="headerlink" title="compress 命令"></a>compress 命令</h3><ul><li>说明:compress压缩文件，压缩后的文件会加上一个.Z后缀以区别未压缩的文件，可以用uncompress解压缩或使用参数-d解压缩。</li><li>语法:compress [参数] 压缩文件名</li><li>参数:<br>-f  如果压缩的文件重名，则强制覆盖。<br>-d  解压缩文件。<br>-c  将输出写到标准输出上，并保留原有文件。</li></ul><h2 id="7-磁盘及系统管理"><a href="#7-磁盘及系统管理" class="headerlink" title="7.磁盘及系统管理"></a>7.磁盘及系统管理</h2><h3 id="df-命令"><a href="#df-命令" class="headerlink" title="df 命令"></a>df 命令</h3><ul><li>说明:检查文件系统的磁盘空间占用情况。可以利用该命令来获取硬盘被占用了多少空间，目前还剩下多少空间等信息。</li><li>语法:df [参数] [文件系统]</li><li>参数:<br>-a  显示所有文件系统的磁盘使用情况，包括0块(block)的文件系统，如&#x2F;proc文件系统。<br>-k  以k字节为单位显示。<br>-i  显示i节点信息，而不是磁盘块。<br>-t  显示各指定类型的文件系统的磁盘空间使用情况。<br>-x  列出不是某一指定类型文件系统的磁盘空间使用情况(与t选项相反)。<br>-T  显示文件系统类型。</li></ul><h3 id="du-命令"><a href="#du-命令" class="headerlink" title="du 命令"></a>du 命令</h3><ul><li>说明:进入指定目录的每一个子目录并显示该目录占用文件系统数据块(1024字节)的情况。若没有指定目录，则对当前目录进行统计。</li><li>语法:du [参数] [文件或目录]</li><li>参数:<br>-s  对每个文件或目录只给出占用的数据块总数。<br>-a  递归地显示指定目录中各文件及子目录中各文件占用的数据块数。若既不指定-s，也不指定-a，则只显示中的每一个目录及其中的各子目录所占的磁盘块数。<br>-b  以字节为单位列出磁盘空间使用情况(系统缺省以k字节为单位)。-k以1024字节为单位列出磁盘空间使用情况。<br>-c  最后再加上一个总计(系统缺省设置)。<br>-l  计算所有的文件大小，对硬链接文件，则计算多次。<br>-x  跳过在不同文件系统上的目录不予统计。</li></ul><h3 id="free-命令"><a href="#free-命令" class="headerlink" title="free 命令"></a>free 命令</h3><ul><li>说明:查看当前系统内存的使用情况，显示系统中剩余及已用的物理内存和交换内存，以及共享内存和被核心使用的缓冲区。</li><li>语法:free [参数]</li><li>参数:<br>-b  以字节为单位显示。<br>-k  以K字节为单位显示。<br>-m  以兆字节为单位显示。</li></ul><h3 id="top-命令"><a href="#top-命令" class="headerlink" title="top 命令"></a>top 命令</h3><ul><li>说明:即时显示进程动态，进入top命令后可以使用如下几个命令进行操作</li><li>参数:<br>h:  显示帮助信息<br>q:  离开此命令s:更新速度，每几秒更新一次，也可使用空格键手动更新。n:只显示最上面运行的几个进程<br>i:  不显示任何闲置(idle)或无用(zombie)的行程u:单独显示某一用户的进程，“+”为显示所有用户的进程，</li></ul><h3 id="history-命令"><a href="#history-命令" class="headerlink" title="history 命令"></a>history 命令</h3><ul><li>说明:查询历史命令记录</li><li>语法:history [参数]</li><li>参数:<br>number  只显示前面最近使用的几个命令-c从下一个命令开始记录<br>-h  只显示命令历史记录，不显示命令编号、时间等信息<br>-r  反向显示命令的历史纪录，即从最近的一个命令开始显示</li></ul><h3 id="ps-命令"><a href="#ps-命令" class="headerlink" title="ps 命令"></a>ps 命令</h3><ul><li>说明:显示用户的运行程序或系统程序。</li><li>语法:ps [参数]</li><li>参数:<br>-e  列出所有用户的进程<br>-u  [user]列出用户user的进程<br>-f  给出详细列表</li></ul><h3 id="kill-命令"><a href="#kill-命令" class="headerlink" title="kill 命令"></a>kill 命令</h3><ul><li>说明:杀掉某一进程</li><li>语法:kill [参数]</li><li>参数:<br>[-signal] pid signal为0到31的数字，也可以是特定字符串。如数字9代表KILL，可以杀掉一般无法终止的程序。<br>-l  查看 signal代表的意思。常用的signal有HUP、STOP、CONT等。</li></ul><h2 id="8-软件安装简介"><a href="#8-软件安装简介" class="headerlink" title="8.软件安装简介"></a>8.软件安装简介</h2><p>后缀为.tar.gz、tar.Z、tar.bz2或.tgz是使用linux&#x2F;Unix系统打包工具tar打包的解压数据包。首先要解压缩，不同扩展名解压缩命令也不相同，如:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">类型 命令<br>.gz   gunzip<br>.Z    uncompress<br>.zip  unzip<br>.bz2  bunzip2<br></code></pre></td></tr></table></figure><p>进入解压缩目录，查看README&#x2F;INSTALL，如果有此类文件，安装前阅读，里面会有安装过程。不同的软件安装不尽相同。一般大致过程如下:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">./configure   配置<br>make          调用make命令进行编译<br><span class="hljs-comment">#make -f file  指定file文件为描述文件。如果没有&quot;-f&quot;参数，则系统将默认当前目录下名为makefile或者名为Makefile的文件为描述文件。</span><br>make install  安装可执行程序<br>make clean    删除安装时产生的临时文件<br>make uninstall 卸载软件<br></code></pre></td></tr></table></figure><p>有些软件包的源代码编译安装后可以用make uninstall命令卸载。如果不提供此功能，则软件的卸载必须手动删除。</p><h2 id="9-其他"><a href="#9-其他" class="headerlink" title="9.其他"></a>9.其他</h2><h3 id="ln-命令"><a href="#ln-命令" class="headerlink" title="ln 命令"></a>ln 命令</h3><ul><li>说明:此命令用于链接文件或目录。连结又可分为两种:硬连结(hard link)与软连结(symbolic link)，硬连结的意思是一个文件可以有多个名称，而软连结的方式则是产生一个特殊的文件，该文件的内容是指向另一个文件的位置。硬连结是存在同一个文件系统中，而软连结却可以跨越不同的文件系统。</li><li>语法:ln [参数] 源文件或目录 目标文件或目录</li><li>参数:<br>-b  删除，覆盖目标文件之前的备份。<br>-d  或-F建立目录的硬连接。<br>-s  对源文件建立符号连接，而非硬连接。<br>-f  强行建立文件或目录的连接，不论文件或目录是否存在。<br>-i  覆盖既有文件之前先询问用户。</li><li>例子:<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">ln</span> -s file1 file2 创建了一个名为 file2 的符号链接，指向 file1。<br></code></pre></td></tr></table></figure></li></ul><h3 id="find-命令"><a href="#find-命令" class="headerlink" title="find 命令"></a>find 命令</h3><ul><li>说明:在目录结构中搜索文件，并执行指定的操作。该命令提供的寻找条件可以是一个用逻辑运算符not、and、or组成的复合条件。</li><li>语法:find [路径] [参数] [操作]</li><li>参数:<br>-empty  查找系统中空白的文件，或空白的文件目录。<br>-name   要查找的文件名，字串内可用通配符 *、?、[ ]。<br>-user uname  查找属于某个用户的文件。<br>-group gname 查找属于某组的文件。<br>-links n     查找有 n 个链接的文件。<br>-exec    执行操作</li><li>例子:<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">find bin/ -name run.sh  查找bin目录下名字为run.sh的文件。<br>find ! -name tmp  该命令查找文件名不是tmp的所有文件。<br></code></pre></td></tr></table></figure></li></ul><h3 id="man-命令"><a href="#man-命令" class="headerlink" title="man 命令"></a>man 命令</h3><p>man是手册(manual)的意思。用来让使用者查询某一命令的具体使用帮助。</p><ul><li>Ctrl+f  或空格键 后翻一页</li><li>Ctrl+b  或 b 前翻一页</li><li>Ctrl+c  或 q 离开</li></ul><h3 id="info-命令"><a href="#info-命令" class="headerlink" title="info 命令"></a>info 命令</h3><p>获取相关命令的详细使用方法</p><ul><li>例如:<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">info <span class="hljs-built_in">ls</span>  可以获取如何使用info的详细信息。<br></code></pre></td></tr></table></figure></li></ul><h3 id="重定向"><a href="#重定向" class="headerlink" title="&gt; 重定向"></a>&gt; 重定向</h3><p>可将某命令的结果输出到文件中</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">&gt;file   将结果输出到文件file中，如果该文件原本就存在，则该文件原有的内容会被**删除**。<br>&gt;&gt;file  将结果输出到文件file中，如果原文件存在，则附加在原文件后面，原文件的内容**不会被清除**。<br></code></pre></td></tr></table></figure><h3 id="管道符"><a href="#管道符" class="headerlink" title="| 管道符"></a>| 管道符</h3><ul><li>可将某命令的结果输出给另一命令。</li></ul><h3 id="screen-用于多重视窗管理程序"><a href="#screen-用于多重视窗管理程序" class="headerlink" title="screen 用于多重视窗管理程序"></a>screen 用于多重视窗管理程序</h3><p>screen为多重视窗管理程序。此处所谓的视窗，是指一个全屏幕的文字模式画面。通常只有在使用telnet登入主机或是使用老式的终端机时，才有可能用到screen程序。</p><ul><li>语法:screen [-AmRvx -ls -wipe][-d &lt;作业名称&gt;][-h &lt;行数&gt;][-r &lt;作业名称&gt;][-s <shell>][-S &lt;作业名称&gt;]</li><li>参数:<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs bash">-A 　        将所有的视窗都调整为目前终端机的大小。<br>-d&lt;作业名称&gt;  将指定的screen作业离线。<br>-h&lt;行数&gt;     指定视窗的缓冲区行数。<br>-m 　        即使目前已在作业中的screen作业，仍强制建立新的screen作业。<br>-r&lt;作业名称&gt;  恢复离线的screen作业。<br>-s\&lt;shell\&gt;  指定建立新视窗时，所要执行的shell。<br>-S&lt;作业名称&gt;  指定screen作业的名称。<br>-R      先试图恢复离线的作业。若找不到离线的作业，即建立新的screen作业。<br>-v      显示版本信息。<br>-x      恢复之前离线的screen作业。<br>-<span class="hljs-built_in">ls</span>或--list  显示目前所有的screen作业。<br>-wipe        检查目前所有的screen作业，并删除已经无法使用的screen作业。<br></code></pre></td></tr></table></figure></li><li>例子:<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">screen      创建screen终端<br>screen -<span class="hljs-built_in">ls</span>  显示已创建的screen终端<br>screen -r   恢复离线的screen作业<br></code></pre></td></tr></table></figure>设置环境变量~&#x2F;.screenrc<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs bash">startup_message off<br>vbell off<br>defscrollback 512<br><br>caption always <span class="hljs-string">&quot;%&#123;=u kC&#125; %= %-w%L&gt;%&#123;=b G&#125;[:%n %t:]%&#123;-&#125;%52&lt;%+w %L=&quot;</span><br><span class="hljs-comment">#caption always &quot;%?%F%&#123;-b 4w&#125;%:%&#123;-b bb&#125;%? %H | %l | %m-%d %c |%?%F%&#123;-b 4w&#125;%?%L=%-Lw%45&gt;%&#123;-b w4&#125;%n%f* %t%&#123;-&#125;%+Lw%-0&lt;&quot;</span><br><br>escape ^L^L<br><br>deflogin off<br><span class="hljs-comment"># default shell is zsh</span><br><span class="hljs-comment"># defshell /usr/bin/zsh</span><br><span class="hljs-comment"># default starting dir is ~</span><br><span class="hljs-built_in">chdir</span><br><br><span class="hljs-built_in">bindkey</span> -k F1 prev<br><span class="hljs-built_in">bindkey</span> -k F2 next<br><br></code></pre></td></tr></table></figure></li></ul><h3 id="source-命令"><a href="#source-命令" class="headerlink" title="source 命令"></a>source 命令</h3><ul><li>说明:source命令通常用于重新执行刚修改的初始化文件，使之立即生效，而不必注销并重新登录。该命令通常用命令“.”来替代，如 .bash_profile 和 .profile 这些配置文件。</li><li>例子<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">source</span> ~/.bashrc<br>. ~/.bashrc<br></code></pre></td></tr></table></figure></li></ul><h2 id="10-练习作业"><a href="#10-练习作业" class="headerlink" title="10.练习作业"></a>10.练习作业</h2><ul><li><ol><li>添加或修改下面环境变量。提示:~&#x2F;.bashrc<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">alias</span> <span class="hljs-built_in">rm</span>=\&#x27;<span class="hljs-built_in">rm</span> -i\&#x27;<br><span class="hljs-built_in">alias</span> <span class="hljs-built_in">cp</span>=\&#x27;<span class="hljs-built_in">cp</span> -rfp\&#x27;<br><span class="hljs-built_in">export</span> PATH=\&quot;~/software/bin:<span class="hljs-variable">$PATH</span>\&quot;<br></code></pre></td></tr></table></figure></li></ol></li><li><ol start="2"><li>安装bwa，samtools</li></ol></li><li><ol start="3"><li>安装miniconda，并通过conda安装R</li></ol></li></ul><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li>北京华大基因研究中心-生物信息学培训资料</li></ul>]]></content>
    
    
    <categories>
      
      <category>生物信息学</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
